/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_queue.h"

static const char* CMockString_pcQueueGetName = "pcQueueGetName";
static const char* CMockString_pcQueueName = "pcQueueName";
static const char* CMockString_pucQueueStorage = "pucQueueStorage";
static const char* CMockString_pvBuffer = "pvBuffer";
static const char* CMockString_pvItemToQueue = "pvItemToQueue";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxStaticQueue = "pxStaticQueue";
static const char* CMockString_pxTaskWoken = "pxTaskWoken";
static const char* CMockString_ucQueueGetQueueType = "ucQueueGetQueueType";
static const char* CMockString_ucQueueType = "ucQueueType";
static const char* CMockString_uxEventQueueLength = "uxEventQueueLength";
static const char* CMockString_uxInitialCount = "uxInitialCount";
static const char* CMockString_uxItemSize = "uxItemSize";
static const char* CMockString_uxMaxCount = "uxMaxCount";
static const char* CMockString_uxQueueGetQueueNumber = "uxQueueGetQueueNumber";
static const char* CMockString_uxQueueLength = "uxQueueLength";
static const char* CMockString_uxQueueMessagesWaiting = "uxQueueMessagesWaiting";
static const char* CMockString_uxQueueMessagesWaitingFromISR = "uxQueueMessagesWaitingFromISR";
static const char* CMockString_uxQueueNumber = "uxQueueNumber";
static const char* CMockString_uxQueueSpacesAvailable = "uxQueueSpacesAvailable";
static const char* CMockString_vQueueAddToRegistry = "vQueueAddToRegistry";
static const char* CMockString_vQueueDelete = "vQueueDelete";
static const char* CMockString_vQueueSetQueueNumber = "vQueueSetQueueNumber";
static const char* CMockString_vQueueUnregisterQueue = "vQueueUnregisterQueue";
static const char* CMockString_vQueueWaitForMessageRestricted = "vQueueWaitForMessageRestricted";
static const char* CMockString_xCoRoutinePreviouslyWoken = "xCoRoutinePreviouslyWoken";
static const char* CMockString_xCopyPosition = "xCopyPosition";
static const char* CMockString_xMutex = "xMutex";
static const char* CMockString_xNewQueue = "xNewQueue";
static const char* CMockString_xQueue = "xQueue";
static const char* CMockString_xQueueAddToSet = "xQueueAddToSet";
static const char* CMockString_xQueueCRReceive = "xQueueCRReceive";
static const char* CMockString_xQueueCRReceiveFromISR = "xQueueCRReceiveFromISR";
static const char* CMockString_xQueueCRSend = "xQueueCRSend";
static const char* CMockString_xQueueCRSendFromISR = "xQueueCRSendFromISR";
static const char* CMockString_xQueueCreateCountingSemaphore = "xQueueCreateCountingSemaphore";
static const char* CMockString_xQueueCreateCountingSemaphoreStatic = "xQueueCreateCountingSemaphoreStatic";
static const char* CMockString_xQueueCreateMutex = "xQueueCreateMutex";
static const char* CMockString_xQueueCreateMutexStatic = "xQueueCreateMutexStatic";
static const char* CMockString_xQueueCreateSet = "xQueueCreateSet";
static const char* CMockString_xQueueGenericCreate = "xQueueGenericCreate";
static const char* CMockString_xQueueGenericCreateStatic = "xQueueGenericCreateStatic";
static const char* CMockString_xQueueGenericReset = "xQueueGenericReset";
static const char* CMockString_xQueueGenericSend = "xQueueGenericSend";
static const char* CMockString_xQueueGenericSendFromISR = "xQueueGenericSendFromISR";
static const char* CMockString_xQueueGetMutexHolder = "xQueueGetMutexHolder";
static const char* CMockString_xQueueGetMutexHolderFromISR = "xQueueGetMutexHolderFromISR";
static const char* CMockString_xQueueGiveFromISR = "xQueueGiveFromISR";
static const char* CMockString_xQueueGiveMutexRecursive = "xQueueGiveMutexRecursive";
static const char* CMockString_xQueueIsQueueEmptyFromISR = "xQueueIsQueueEmptyFromISR";
static const char* CMockString_xQueueIsQueueFullFromISR = "xQueueIsQueueFullFromISR";
static const char* CMockString_xQueueOrSemaphore = "xQueueOrSemaphore";
static const char* CMockString_xQueuePeek = "xQueuePeek";
static const char* CMockString_xQueuePeekFromISR = "xQueuePeekFromISR";
static const char* CMockString_xQueueReceive = "xQueueReceive";
static const char* CMockString_xQueueReceiveFromISR = "xQueueReceiveFromISR";
static const char* CMockString_xQueueRemoveFromSet = "xQueueRemoveFromSet";
static const char* CMockString_xQueueSelectFromSet = "xQueueSelectFromSet";
static const char* CMockString_xQueueSelectFromSetFromISR = "xQueueSelectFromSetFromISR";
static const char* CMockString_xQueueSemaphoreTake = "xQueueSemaphoreTake";
static const char* CMockString_xQueueSet = "xQueueSet";
static const char* CMockString_xQueueTakeMutexRecursive = "xQueueTakeMutexRecursive";
static const char* CMockString_xSemaphore = "xSemaphore";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xWaitIndefinitely = "xWaitIndefinitely";

typedef struct _CMOCK_xQueueGenericSend_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  const void* Expected_pvItemToQueue;
  TickType_t Expected_xTicksToWait;
  BaseType_t Expected_xCopyPosition;
  int Expected_pvItemToQueue_Depth;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvItemToQueue;
  char IgnoreArg_xTicksToWait;
  char IgnoreArg_xCopyPosition;

} CMOCK_xQueueGenericSend_CALL_INSTANCE;

typedef struct _CMOCK_xQueuePeek_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  TickType_t Expected_xTicksToWait;
  int Expected_pvBuffer_Depth;
  char ReturnThruPtr_pvBuffer_Used;
  void* ReturnThruPtr_pvBuffer_Val;
  int ReturnThruPtr_pvBuffer_Size;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvBuffer;
  char IgnoreArg_xTicksToWait;

} CMOCK_xQueuePeek_CALL_INSTANCE;

typedef struct _CMOCK_xQueuePeekFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  int Expected_pvBuffer_Depth;
  char ReturnThruPtr_pvBuffer_Used;
  void* ReturnThruPtr_pvBuffer_Val;
  int ReturnThruPtr_pvBuffer_Size;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvBuffer;

} CMOCK_xQueuePeekFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueReceive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  TickType_t Expected_xTicksToWait;
  int Expected_pvBuffer_Depth;
  char ReturnThruPtr_pvBuffer_Used;
  void* ReturnThruPtr_pvBuffer_Val;
  int ReturnThruPtr_pvBuffer_Size;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvBuffer;
  char IgnoreArg_xTicksToWait;

} CMOCK_xQueueReceive_CALL_INSTANCE;

typedef struct _CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE;

typedef struct _CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE;

typedef struct _CMOCK_vQueueDelete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_vQueueDelete_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  const void* Expected_pvItemToQueue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  BaseType_t Expected_xCopyPosition;
  int Expected_pvItemToQueue_Depth;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char ReturnThruPtr_pxHigherPriorityTaskWoken_Used;
  BaseType_t* ReturnThruPtr_pxHigherPriorityTaskWoken_Val;
  int ReturnThruPtr_pxHigherPriorityTaskWoken_Size;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvItemToQueue;
  char IgnoreArg_pxHigherPriorityTaskWoken;
  char IgnoreArg_xCopyPosition;

} CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char ReturnThruPtr_pxHigherPriorityTaskWoken_Used;
  BaseType_t* ReturnThruPtr_pxHigherPriorityTaskWoken_Val;
  int ReturnThruPtr_pxHigherPriorityTaskWoken_Size;
  char IgnoreArg_xQueue;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xQueueGiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueReceiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pvBuffer_Depth;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char ReturnThruPtr_pvBuffer_Used;
  void* ReturnThruPtr_pvBuffer_Val;
  int ReturnThruPtr_pvBuffer_Size;
  char ReturnThruPtr_pxHigherPriorityTaskWoken_Used;
  BaseType_t* ReturnThruPtr_pxHigherPriorityTaskWoken_Val;
  int ReturnThruPtr_pxHigherPriorityTaskWoken_Size;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvBuffer;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xQueueReceiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE;

typedef struct _CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCRSendFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  const void* Expected_pvItemToQueue;
  BaseType_t Expected_xCoRoutinePreviouslyWoken;
  int Expected_pvItemToQueue_Depth;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvItemToQueue;
  char IgnoreArg_xCoRoutinePreviouslyWoken;

} CMOCK_xQueueCRSendFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  BaseType_t* Expected_pxTaskWoken;
  int Expected_pvBuffer_Depth;
  int Expected_pxTaskWoken_Depth;
  char ReturnThruPtr_pvBuffer_Used;
  void* ReturnThruPtr_pvBuffer_Val;
  int ReturnThruPtr_pvBuffer_Size;
  char ReturnThruPtr_pxTaskWoken_Used;
  BaseType_t* ReturnThruPtr_pxTaskWoken_Val;
  int ReturnThruPtr_pxTaskWoken_Size;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvBuffer;
  char IgnoreArg_pxTaskWoken;

} CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCRSend_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  const void* Expected_pvItemToQueue;
  TickType_t Expected_xTicksToWait;
  int Expected_pvItemToQueue_Depth;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvItemToQueue;
  char IgnoreArg_xTicksToWait;

} CMOCK_xQueueCRSend_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCRReceive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  TickType_t Expected_xTicksToWait;
  int Expected_pvBuffer_Depth;
  char ReturnThruPtr_pvBuffer_Used;
  void* ReturnThruPtr_pvBuffer_Val;
  int ReturnThruPtr_pvBuffer_Size;
  char IgnoreArg_xQueue;
  char IgnoreArg_pvBuffer;
  char IgnoreArg_xTicksToWait;

} CMOCK_xQueueCRReceive_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateMutex_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueHandle_t ReturnVal;
  int CallOrder;
  uint8_t Expected_ucQueueType;
  char IgnoreArg_ucQueueType;

} CMOCK_xQueueCreateMutex_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueHandle_t ReturnVal;
  int CallOrder;
  uint8_t Expected_ucQueueType;
  StaticQueue_t* Expected_pxStaticQueue;
  int Expected_pxStaticQueue_Depth;
  char ReturnThruPtr_pxStaticQueue_Used;
  StaticQueue_t* ReturnThruPtr_pxStaticQueue_Val;
  int ReturnThruPtr_pxStaticQueue_Size;
  char IgnoreArg_ucQueueType;
  char IgnoreArg_pxStaticQueue;

} CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueHandle_t ReturnVal;
  int CallOrder;
  UBaseType_t Expected_uxMaxCount;
  UBaseType_t Expected_uxInitialCount;
  char IgnoreArg_uxMaxCount;
  char IgnoreArg_uxInitialCount;

} CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueHandle_t ReturnVal;
  int CallOrder;
  UBaseType_t Expected_uxMaxCount;
  UBaseType_t Expected_uxInitialCount;
  StaticQueue_t* Expected_pxStaticQueue;
  int Expected_pxStaticQueue_Depth;
  char ReturnThruPtr_pxStaticQueue_Used;
  StaticQueue_t* ReturnThruPtr_pxStaticQueue_Val;
  int ReturnThruPtr_pxStaticQueue_Size;
  char IgnoreArg_uxMaxCount;
  char IgnoreArg_uxInitialCount;
  char IgnoreArg_pxStaticQueue;

} CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE;

typedef struct _CMOCK_xQueueSemaphoreTake_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  TickType_t Expected_xTicksToWait;
  char IgnoreArg_xQueue;
  char IgnoreArg_xTicksToWait;

} CMOCK_xQueueSemaphoreTake_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGetMutexHolder_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xSemaphore;
  char IgnoreArg_xSemaphore;

} CMOCK_xQueueGetMutexHolder_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  TaskHandle_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xSemaphore;
  char IgnoreArg_xSemaphore;

} CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xMutex;
  TickType_t Expected_xTicksToWait;
  char IgnoreArg_xMutex;
  char IgnoreArg_xTicksToWait;

} CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xMutex;
  char IgnoreArg_xMutex;

} CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE;

typedef struct _CMOCK_vQueueAddToRegistry_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  const char* Expected_pcQueueName;
  char IgnoreArg_xQueue;
  char IgnoreArg_pcQueueName;

} CMOCK_vQueueAddToRegistry_CALL_INSTANCE;

typedef struct _CMOCK_vQueueUnregisterQueue_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_vQueueUnregisterQueue_CALL_INSTANCE;

typedef struct _CMOCK_pcQueueGetName_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  const char* ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_pcQueueGetName_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGenericCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueHandle_t ReturnVal;
  int CallOrder;
  UBaseType_t Expected_uxQueueLength;
  UBaseType_t Expected_uxItemSize;
  uint8_t Expected_ucQueueType;
  char IgnoreArg_uxQueueLength;
  char IgnoreArg_uxItemSize;
  char IgnoreArg_ucQueueType;

} CMOCK_xQueueGenericCreate_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueHandle_t ReturnVal;
  int CallOrder;
  UBaseType_t Expected_uxQueueLength;
  UBaseType_t Expected_uxItemSize;
  uint8_t* Expected_pucQueueStorage;
  StaticQueue_t* Expected_pxStaticQueue;
  uint8_t Expected_ucQueueType;
  int Expected_pucQueueStorage_Depth;
  int Expected_pxStaticQueue_Depth;
  char ReturnThruPtr_pucQueueStorage_Used;
  uint8_t* ReturnThruPtr_pucQueueStorage_Val;
  int ReturnThruPtr_pucQueueStorage_Size;
  char ReturnThruPtr_pxStaticQueue_Used;
  StaticQueue_t* ReturnThruPtr_pxStaticQueue_Val;
  int ReturnThruPtr_pxStaticQueue_Size;
  char IgnoreArg_uxQueueLength;
  char IgnoreArg_uxItemSize;
  char IgnoreArg_pucQueueStorage;
  char IgnoreArg_pxStaticQueue;
  char IgnoreArg_ucQueueType;

} CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_xQueueCreateSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueSetHandle_t ReturnVal;
  int CallOrder;
  UBaseType_t Expected_uxEventQueueLength;
  char IgnoreArg_uxEventQueueLength;

} CMOCK_xQueueCreateSet_CALL_INSTANCE;

typedef struct _CMOCK_xQueueAddToSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueSetMemberHandle_t Expected_xQueueOrSemaphore;
  QueueSetHandle_t Expected_xQueueSet;
  char IgnoreArg_xQueueOrSemaphore;
  char IgnoreArg_xQueueSet;

} CMOCK_xQueueAddToSet_CALL_INSTANCE;

typedef struct _CMOCK_xQueueRemoveFromSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueSetMemberHandle_t Expected_xQueueOrSemaphore;
  QueueSetHandle_t Expected_xQueueSet;
  char IgnoreArg_xQueueOrSemaphore;
  char IgnoreArg_xQueueSet;

} CMOCK_xQueueRemoveFromSet_CALL_INSTANCE;

typedef struct _CMOCK_xQueueSelectFromSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueSetMemberHandle_t ReturnVal;
  int CallOrder;
  QueueSetHandle_t Expected_xQueueSet;
  TickType_t Expected_xTicksToWait;
  char IgnoreArg_xQueueSet;
  char IgnoreArg_xTicksToWait;

} CMOCK_xQueueSelectFromSet_CALL_INSTANCE;

typedef struct _CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  QueueSetMemberHandle_t ReturnVal;
  int CallOrder;
  QueueSetHandle_t Expected_xQueueSet;
  char IgnoreArg_xQueueSet;

} CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  TickType_t Expected_xTicksToWait;
  BaseType_t Expected_xWaitIndefinitely;
  char IgnoreArg_xQueue;
  char IgnoreArg_xTicksToWait;
  char IgnoreArg_xWaitIndefinitely;

} CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE;

typedef struct _CMOCK_xQueueGenericReset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  BaseType_t Expected_xNewQueue;
  char IgnoreArg_xQueue;
  char IgnoreArg_xNewQueue;

} CMOCK_xQueueGenericReset_CALL_INSTANCE;

typedef struct _CMOCK_vQueueSetQueueNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  UBaseType_t Expected_uxQueueNumber;
  char IgnoreArg_xQueue;
  char IgnoreArg_uxQueueNumber;

} CMOCK_vQueueSetQueueNumber_CALL_INSTANCE;

typedef struct _CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE;

typedef struct _CMOCK_ucQueueGetQueueType_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint8_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  char IgnoreArg_xQueue;

} CMOCK_ucQueueGetQueueType_CALL_INSTANCE;

static struct mock_queueInstance
{
  char xQueueGenericSend_IgnoreBool;
  BaseType_t xQueueGenericSend_FinalReturn;
  char xQueueGenericSend_CallbackBool;
  CMOCK_xQueueGenericSend_CALLBACK xQueueGenericSend_CallbackFunctionPointer;
  int xQueueGenericSend_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGenericSend_CallInstance;
  char xQueuePeek_IgnoreBool;
  BaseType_t xQueuePeek_FinalReturn;
  char xQueuePeek_CallbackBool;
  CMOCK_xQueuePeek_CALLBACK xQueuePeek_CallbackFunctionPointer;
  int xQueuePeek_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueuePeek_CallInstance;
  char xQueuePeekFromISR_IgnoreBool;
  BaseType_t xQueuePeekFromISR_FinalReturn;
  char xQueuePeekFromISR_CallbackBool;
  CMOCK_xQueuePeekFromISR_CALLBACK xQueuePeekFromISR_CallbackFunctionPointer;
  int xQueuePeekFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueuePeekFromISR_CallInstance;
  char xQueueReceive_IgnoreBool;
  BaseType_t xQueueReceive_FinalReturn;
  char xQueueReceive_CallbackBool;
  CMOCK_xQueueReceive_CALLBACK xQueueReceive_CallbackFunctionPointer;
  int xQueueReceive_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueReceive_CallInstance;
  char uxQueueMessagesWaiting_IgnoreBool;
  UBaseType_t uxQueueMessagesWaiting_FinalReturn;
  char uxQueueMessagesWaiting_CallbackBool;
  CMOCK_uxQueueMessagesWaiting_CALLBACK uxQueueMessagesWaiting_CallbackFunctionPointer;
  int uxQueueMessagesWaiting_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxQueueMessagesWaiting_CallInstance;
  char uxQueueSpacesAvailable_IgnoreBool;
  UBaseType_t uxQueueSpacesAvailable_FinalReturn;
  char uxQueueSpacesAvailable_CallbackBool;
  CMOCK_uxQueueSpacesAvailable_CALLBACK uxQueueSpacesAvailable_CallbackFunctionPointer;
  int uxQueueSpacesAvailable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxQueueSpacesAvailable_CallInstance;
  char vQueueDelete_IgnoreBool;
  char vQueueDelete_CallbackBool;
  CMOCK_vQueueDelete_CALLBACK vQueueDelete_CallbackFunctionPointer;
  int vQueueDelete_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vQueueDelete_CallInstance;
  char xQueueGenericSendFromISR_IgnoreBool;
  BaseType_t xQueueGenericSendFromISR_FinalReturn;
  char xQueueGenericSendFromISR_CallbackBool;
  CMOCK_xQueueGenericSendFromISR_CALLBACK xQueueGenericSendFromISR_CallbackFunctionPointer;
  int xQueueGenericSendFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGenericSendFromISR_CallInstance;
  char xQueueGiveFromISR_IgnoreBool;
  BaseType_t xQueueGiveFromISR_FinalReturn;
  char xQueueGiveFromISR_CallbackBool;
  CMOCK_xQueueGiveFromISR_CALLBACK xQueueGiveFromISR_CallbackFunctionPointer;
  int xQueueGiveFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGiveFromISR_CallInstance;
  char xQueueReceiveFromISR_IgnoreBool;
  BaseType_t xQueueReceiveFromISR_FinalReturn;
  char xQueueReceiveFromISR_CallbackBool;
  CMOCK_xQueueReceiveFromISR_CALLBACK xQueueReceiveFromISR_CallbackFunctionPointer;
  int xQueueReceiveFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueReceiveFromISR_CallInstance;
  char xQueueIsQueueEmptyFromISR_IgnoreBool;
  BaseType_t xQueueIsQueueEmptyFromISR_FinalReturn;
  char xQueueIsQueueEmptyFromISR_CallbackBool;
  CMOCK_xQueueIsQueueEmptyFromISR_CALLBACK xQueueIsQueueEmptyFromISR_CallbackFunctionPointer;
  int xQueueIsQueueEmptyFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueIsQueueEmptyFromISR_CallInstance;
  char xQueueIsQueueFullFromISR_IgnoreBool;
  BaseType_t xQueueIsQueueFullFromISR_FinalReturn;
  char xQueueIsQueueFullFromISR_CallbackBool;
  CMOCK_xQueueIsQueueFullFromISR_CALLBACK xQueueIsQueueFullFromISR_CallbackFunctionPointer;
  int xQueueIsQueueFullFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueIsQueueFullFromISR_CallInstance;
  char uxQueueMessagesWaitingFromISR_IgnoreBool;
  UBaseType_t uxQueueMessagesWaitingFromISR_FinalReturn;
  char uxQueueMessagesWaitingFromISR_CallbackBool;
  CMOCK_uxQueueMessagesWaitingFromISR_CALLBACK uxQueueMessagesWaitingFromISR_CallbackFunctionPointer;
  int uxQueueMessagesWaitingFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxQueueMessagesWaitingFromISR_CallInstance;
  char xQueueCRSendFromISR_IgnoreBool;
  BaseType_t xQueueCRSendFromISR_FinalReturn;
  char xQueueCRSendFromISR_CallbackBool;
  CMOCK_xQueueCRSendFromISR_CALLBACK xQueueCRSendFromISR_CallbackFunctionPointer;
  int xQueueCRSendFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCRSendFromISR_CallInstance;
  char xQueueCRReceiveFromISR_IgnoreBool;
  BaseType_t xQueueCRReceiveFromISR_FinalReturn;
  char xQueueCRReceiveFromISR_CallbackBool;
  CMOCK_xQueueCRReceiveFromISR_CALLBACK xQueueCRReceiveFromISR_CallbackFunctionPointer;
  int xQueueCRReceiveFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCRReceiveFromISR_CallInstance;
  char xQueueCRSend_IgnoreBool;
  BaseType_t xQueueCRSend_FinalReturn;
  char xQueueCRSend_CallbackBool;
  CMOCK_xQueueCRSend_CALLBACK xQueueCRSend_CallbackFunctionPointer;
  int xQueueCRSend_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCRSend_CallInstance;
  char xQueueCRReceive_IgnoreBool;
  BaseType_t xQueueCRReceive_FinalReturn;
  char xQueueCRReceive_CallbackBool;
  CMOCK_xQueueCRReceive_CALLBACK xQueueCRReceive_CallbackFunctionPointer;
  int xQueueCRReceive_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCRReceive_CallInstance;
  char xQueueCreateMutex_IgnoreBool;
  QueueHandle_t xQueueCreateMutex_FinalReturn;
  char xQueueCreateMutex_CallbackBool;
  CMOCK_xQueueCreateMutex_CALLBACK xQueueCreateMutex_CallbackFunctionPointer;
  int xQueueCreateMutex_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCreateMutex_CallInstance;
  char xQueueCreateMutexStatic_IgnoreBool;
  QueueHandle_t xQueueCreateMutexStatic_FinalReturn;
  char xQueueCreateMutexStatic_CallbackBool;
  CMOCK_xQueueCreateMutexStatic_CALLBACK xQueueCreateMutexStatic_CallbackFunctionPointer;
  int xQueueCreateMutexStatic_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCreateMutexStatic_CallInstance;
  char xQueueCreateCountingSemaphore_IgnoreBool;
  QueueHandle_t xQueueCreateCountingSemaphore_FinalReturn;
  char xQueueCreateCountingSemaphore_CallbackBool;
  CMOCK_xQueueCreateCountingSemaphore_CALLBACK xQueueCreateCountingSemaphore_CallbackFunctionPointer;
  int xQueueCreateCountingSemaphore_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCreateCountingSemaphore_CallInstance;
  char xQueueCreateCountingSemaphoreStatic_IgnoreBool;
  QueueHandle_t xQueueCreateCountingSemaphoreStatic_FinalReturn;
  char xQueueCreateCountingSemaphoreStatic_CallbackBool;
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALLBACK xQueueCreateCountingSemaphoreStatic_CallbackFunctionPointer;
  int xQueueCreateCountingSemaphoreStatic_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCreateCountingSemaphoreStatic_CallInstance;
  char xQueueSemaphoreTake_IgnoreBool;
  BaseType_t xQueueSemaphoreTake_FinalReturn;
  char xQueueSemaphoreTake_CallbackBool;
  CMOCK_xQueueSemaphoreTake_CALLBACK xQueueSemaphoreTake_CallbackFunctionPointer;
  int xQueueSemaphoreTake_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueSemaphoreTake_CallInstance;
  char xQueueGetMutexHolder_IgnoreBool;
  TaskHandle_t xQueueGetMutexHolder_FinalReturn;
  char xQueueGetMutexHolder_CallbackBool;
  CMOCK_xQueueGetMutexHolder_CALLBACK xQueueGetMutexHolder_CallbackFunctionPointer;
  int xQueueGetMutexHolder_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGetMutexHolder_CallInstance;
  char xQueueGetMutexHolderFromISR_IgnoreBool;
  TaskHandle_t xQueueGetMutexHolderFromISR_FinalReturn;
  char xQueueGetMutexHolderFromISR_CallbackBool;
  CMOCK_xQueueGetMutexHolderFromISR_CALLBACK xQueueGetMutexHolderFromISR_CallbackFunctionPointer;
  int xQueueGetMutexHolderFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGetMutexHolderFromISR_CallInstance;
  char xQueueTakeMutexRecursive_IgnoreBool;
  BaseType_t xQueueTakeMutexRecursive_FinalReturn;
  char xQueueTakeMutexRecursive_CallbackBool;
  CMOCK_xQueueTakeMutexRecursive_CALLBACK xQueueTakeMutexRecursive_CallbackFunctionPointer;
  int xQueueTakeMutexRecursive_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueTakeMutexRecursive_CallInstance;
  char xQueueGiveMutexRecursive_IgnoreBool;
  BaseType_t xQueueGiveMutexRecursive_FinalReturn;
  char xQueueGiveMutexRecursive_CallbackBool;
  CMOCK_xQueueGiveMutexRecursive_CALLBACK xQueueGiveMutexRecursive_CallbackFunctionPointer;
  int xQueueGiveMutexRecursive_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGiveMutexRecursive_CallInstance;
  char vQueueAddToRegistry_IgnoreBool;
  char vQueueAddToRegistry_CallbackBool;
  CMOCK_vQueueAddToRegistry_CALLBACK vQueueAddToRegistry_CallbackFunctionPointer;
  int vQueueAddToRegistry_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vQueueAddToRegistry_CallInstance;
  char vQueueUnregisterQueue_IgnoreBool;
  char vQueueUnregisterQueue_CallbackBool;
  CMOCK_vQueueUnregisterQueue_CALLBACK vQueueUnregisterQueue_CallbackFunctionPointer;
  int vQueueUnregisterQueue_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vQueueUnregisterQueue_CallInstance;
  char pcQueueGetName_IgnoreBool;
  const char* pcQueueGetName_FinalReturn;
  char pcQueueGetName_CallbackBool;
  CMOCK_pcQueueGetName_CALLBACK pcQueueGetName_CallbackFunctionPointer;
  int pcQueueGetName_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pcQueueGetName_CallInstance;
  char xQueueGenericCreate_IgnoreBool;
  QueueHandle_t xQueueGenericCreate_FinalReturn;
  char xQueueGenericCreate_CallbackBool;
  CMOCK_xQueueGenericCreate_CALLBACK xQueueGenericCreate_CallbackFunctionPointer;
  int xQueueGenericCreate_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGenericCreate_CallInstance;
  char xQueueGenericCreateStatic_IgnoreBool;
  QueueHandle_t xQueueGenericCreateStatic_FinalReturn;
  char xQueueGenericCreateStatic_CallbackBool;
  CMOCK_xQueueGenericCreateStatic_CALLBACK xQueueGenericCreateStatic_CallbackFunctionPointer;
  int xQueueGenericCreateStatic_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGenericCreateStatic_CallInstance;
  char xQueueCreateSet_IgnoreBool;
  QueueSetHandle_t xQueueCreateSet_FinalReturn;
  char xQueueCreateSet_CallbackBool;
  CMOCK_xQueueCreateSet_CALLBACK xQueueCreateSet_CallbackFunctionPointer;
  int xQueueCreateSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCreateSet_CallInstance;
  char xQueueAddToSet_IgnoreBool;
  BaseType_t xQueueAddToSet_FinalReturn;
  char xQueueAddToSet_CallbackBool;
  CMOCK_xQueueAddToSet_CALLBACK xQueueAddToSet_CallbackFunctionPointer;
  int xQueueAddToSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueAddToSet_CallInstance;
  char xQueueRemoveFromSet_IgnoreBool;
  BaseType_t xQueueRemoveFromSet_FinalReturn;
  char xQueueRemoveFromSet_CallbackBool;
  CMOCK_xQueueRemoveFromSet_CALLBACK xQueueRemoveFromSet_CallbackFunctionPointer;
  int xQueueRemoveFromSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueRemoveFromSet_CallInstance;
  char xQueueSelectFromSet_IgnoreBool;
  QueueSetMemberHandle_t xQueueSelectFromSet_FinalReturn;
  char xQueueSelectFromSet_CallbackBool;
  CMOCK_xQueueSelectFromSet_CALLBACK xQueueSelectFromSet_CallbackFunctionPointer;
  int xQueueSelectFromSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueSelectFromSet_CallInstance;
  char xQueueSelectFromSetFromISR_IgnoreBool;
  QueueSetMemberHandle_t xQueueSelectFromSetFromISR_FinalReturn;
  char xQueueSelectFromSetFromISR_CallbackBool;
  CMOCK_xQueueSelectFromSetFromISR_CALLBACK xQueueSelectFromSetFromISR_CallbackFunctionPointer;
  int xQueueSelectFromSetFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueSelectFromSetFromISR_CallInstance;
  char vQueueWaitForMessageRestricted_IgnoreBool;
  char vQueueWaitForMessageRestricted_CallbackBool;
  CMOCK_vQueueWaitForMessageRestricted_CALLBACK vQueueWaitForMessageRestricted_CallbackFunctionPointer;
  int vQueueWaitForMessageRestricted_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vQueueWaitForMessageRestricted_CallInstance;
  char xQueueGenericReset_IgnoreBool;
  BaseType_t xQueueGenericReset_FinalReturn;
  char xQueueGenericReset_CallbackBool;
  CMOCK_xQueueGenericReset_CALLBACK xQueueGenericReset_CallbackFunctionPointer;
  int xQueueGenericReset_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueGenericReset_CallInstance;
  char vQueueSetQueueNumber_IgnoreBool;
  char vQueueSetQueueNumber_CallbackBool;
  CMOCK_vQueueSetQueueNumber_CALLBACK vQueueSetQueueNumber_CallbackFunctionPointer;
  int vQueueSetQueueNumber_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vQueueSetQueueNumber_CallInstance;
  char uxQueueGetQueueNumber_IgnoreBool;
  UBaseType_t uxQueueGetQueueNumber_FinalReturn;
  char uxQueueGetQueueNumber_CallbackBool;
  CMOCK_uxQueueGetQueueNumber_CALLBACK uxQueueGetQueueNumber_CallbackFunctionPointer;
  int uxQueueGetQueueNumber_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxQueueGetQueueNumber_CallInstance;
  char ucQueueGetQueueType_IgnoreBool;
  uint8_t ucQueueGetQueueType_FinalReturn;
  char ucQueueGetQueueType_CallbackBool;
  CMOCK_ucQueueGetQueueType_CALLBACK ucQueueGetQueueType_CallbackFunctionPointer;
  int ucQueueGetQueueType_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ucQueueGetQueueType_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_queue_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xQueueGenericSend_CallInstance;
  if (Mock.xQueueGenericSend_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericSend);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGenericSend_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueuePeek_CallInstance;
  if (Mock.xQueuePeek_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueuePeek);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueuePeek_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueuePeekFromISR_CallInstance;
  if (Mock.xQueuePeekFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueuePeekFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueuePeekFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueReceive_CallInstance;
  if (Mock.xQueueReceive_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueReceive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueReceive_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxQueueMessagesWaiting_CallInstance;
  if (Mock.uxQueueMessagesWaiting_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxQueueMessagesWaiting);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxQueueMessagesWaiting_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxQueueSpacesAvailable_CallInstance;
  if (Mock.uxQueueSpacesAvailable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxQueueSpacesAvailable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxQueueSpacesAvailable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vQueueDelete_CallInstance;
  if (Mock.vQueueDelete_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueDelete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vQueueDelete_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueGenericSendFromISR_CallInstance;
  if (Mock.xQueueGenericSendFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericSendFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGenericSendFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueGiveFromISR_CallInstance;
  if (Mock.xQueueGiveFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGiveFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueReceiveFromISR_CallInstance;
  if (Mock.xQueueReceiveFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueReceiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueReceiveFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueIsQueueEmptyFromISR_CallInstance;
  if (Mock.xQueueIsQueueEmptyFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueIsQueueEmptyFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueIsQueueFullFromISR_CallInstance;
  if (Mock.xQueueIsQueueFullFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueIsQueueFullFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueIsQueueFullFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxQueueMessagesWaitingFromISR_CallInstance;
  if (Mock.uxQueueMessagesWaitingFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxQueueMessagesWaitingFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxQueueMessagesWaitingFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCRSendFromISR_CallInstance;
  if (Mock.xQueueCRSendFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCRSendFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCRSendFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCRReceiveFromISR_CallInstance;
  if (Mock.xQueueCRReceiveFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCRReceiveFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCRReceiveFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCRSend_CallInstance;
  if (Mock.xQueueCRSend_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCRSend);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCRSend_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCRReceive_CallInstance;
  if (Mock.xQueueCRReceive_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCRReceive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCRReceive_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCreateMutex_CallInstance;
  if (Mock.xQueueCreateMutex_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateMutex);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCreateMutex_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCreateMutexStatic_CallInstance;
  if (Mock.xQueueCreateMutexStatic_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateMutexStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCreateMutexStatic_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCreateCountingSemaphore_CallInstance;
  if (Mock.xQueueCreateCountingSemaphore_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateCountingSemaphore);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCreateCountingSemaphore_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCreateCountingSemaphoreStatic_CallInstance;
  if (Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateCountingSemaphoreStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCreateCountingSemaphoreStatic_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueSemaphoreTake_CallInstance;
  if (Mock.xQueueSemaphoreTake_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueSemaphoreTake);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueSemaphoreTake_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueGetMutexHolder_CallInstance;
  if (Mock.xQueueGetMutexHolder_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGetMutexHolder);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGetMutexHolder_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueGetMutexHolderFromISR_CallInstance;
  if (Mock.xQueueGetMutexHolderFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGetMutexHolderFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGetMutexHolderFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueTakeMutexRecursive_CallInstance;
  if (Mock.xQueueTakeMutexRecursive_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueTakeMutexRecursive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueTakeMutexRecursive_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueGiveMutexRecursive_CallInstance;
  if (Mock.xQueueGiveMutexRecursive_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGiveMutexRecursive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGiveMutexRecursive_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vQueueAddToRegistry_CallInstance;
  if (Mock.vQueueAddToRegistry_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueAddToRegistry);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vQueueAddToRegistry_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vQueueUnregisterQueue_CallInstance;
  if (Mock.vQueueUnregisterQueue_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueUnregisterQueue);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vQueueUnregisterQueue_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.pcQueueGetName_CallInstance;
  if (Mock.pcQueueGetName_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pcQueueGetName);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.pcQueueGetName_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueGenericCreate_CallInstance;
  if (Mock.xQueueGenericCreate_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGenericCreate_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueGenericCreateStatic_CallInstance;
  if (Mock.xQueueGenericCreateStatic_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGenericCreateStatic_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueCreateSet_CallInstance;
  if (Mock.xQueueCreateSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueCreateSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueCreateSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueAddToSet_CallInstance;
  if (Mock.xQueueAddToSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueAddToSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueAddToSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueRemoveFromSet_CallInstance;
  if (Mock.xQueueRemoveFromSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueRemoveFromSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueRemoveFromSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueSelectFromSet_CallInstance;
  if (Mock.xQueueSelectFromSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueSelectFromSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueSelectFromSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueSelectFromSetFromISR_CallInstance;
  if (Mock.xQueueSelectFromSetFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueSelectFromSetFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueSelectFromSetFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vQueueWaitForMessageRestricted_CallInstance;
  if (Mock.vQueueWaitForMessageRestricted_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueWaitForMessageRestricted);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vQueueWaitForMessageRestricted_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xQueueGenericReset_CallInstance;
  if (Mock.xQueueGenericReset_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xQueueGenericReset);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xQueueGenericReset_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vQueueSetQueueNumber_CallInstance;
  if (Mock.vQueueSetQueueNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vQueueSetQueueNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vQueueSetQueueNumber_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxQueueGetQueueNumber_CallInstance;
  if (Mock.uxQueueGetQueueNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxQueueGetQueueNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxQueueGetQueueNumber_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ucQueueGetQueueType_CallInstance;
  if (Mock.ucQueueGetQueueType_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ucQueueGetQueueType);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ucQueueGetQueueType_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_queue_Init(void)
{
  mock_queue_Destroy();
}

void mock_queue_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGenericSend
#else
BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition) __attribute__((weak));
#endif

BaseType_t xQueueGenericSend(QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericSend);
  cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericSend_CallInstance);
  Mock.xQueueGenericSend_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericSend_CallInstance);
  if (Mock.xQueueGenericSend_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGenericSend_FinalReturn;
    memcpy((void*)(&Mock.xQueueGenericSend_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGenericSend_CallbackBool &&
      Mock.xQueueGenericSend_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueGenericSend_CallbackFunctionPointer(xQueue, pvItemToQueue, xTicksToWait, xCopyPosition, Mock.xQueueGenericSend_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSend,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvItemToQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSend,CMockString_pvItemToQueue);
    if (cmock_call_instance->Expected_pvItemToQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvItemToQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, cmock_call_instance->Expected_pvItemToQueue_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSend,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xCopyPosition)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSend,CMockString_xCopyPosition);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCopyPosition), (void*)(&xCopyPosition), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueGenericSend_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGenericSend_CallbackFunctionPointer(xQueue, pvItemToQueue, xTicksToWait, xCopyPosition, Mock.xQueueGenericSend_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericSend(CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* const pvItemToQueue, int pvItemToQueue_Depth, TickType_t xTicksToWait, const BaseType_t xCopyPosition)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvItemToQueue = pvItemToQueue;
  cmock_call_instance->Expected_pvItemToQueue_Depth = pvItemToQueue_Depth;
  cmock_call_instance->IgnoreArg_pvItemToQueue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xCopyPosition), (void*)(&xCopyPosition),
         sizeof(BaseType_t[sizeof(xCopyPosition) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xCopyPosition = 0;
}

void xQueueGenericSend_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSend_CALL_INSTANCE));
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSend_CallInstance, cmock_guts_index);
  Mock.xQueueGenericSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGenericSend_IgnoreBool = (char)1;
}

void xQueueGenericSend_CMockStopIgnore(void)
{
  if(Mock.xQueueGenericSend_IgnoreBool)
    Mock.xQueueGenericSend_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericSend_CallInstance);
  Mock.xQueueGenericSend_IgnoreBool = (char)0;
}

void xQueueGenericSend_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSend_CALL_INSTANCE));
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSend_CallInstance, cmock_guts_index);
  Mock.xQueueGenericSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGenericSend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSend_CALL_INSTANCE));
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSend_CallInstance, cmock_guts_index);
  Mock.xQueueGenericSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGenericSend(cmock_call_instance, xQueue, pvItemToQueue, 1, xTicksToWait, xCopyPosition);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueGenericSend_AddCallback(CMOCK_xQueueGenericSend_CALLBACK Callback)
{
  Mock.xQueueGenericSend_IgnoreBool = (char)0;
  Mock.xQueueGenericSend_CallbackBool = (char)1;
  Mock.xQueueGenericSend_CallbackFunctionPointer = Callback;
}

void xQueueGenericSend_Stub(CMOCK_xQueueGenericSend_CALLBACK Callback)
{
  Mock.xQueueGenericSend_IgnoreBool = (char)0;
  Mock.xQueueGenericSend_CallbackBool = (char)0;
  Mock.xQueueGenericSend_CallbackFunctionPointer = Callback;
}

void xQueueGenericSend_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* const pvItemToQueue, int pvItemToQueue_Depth, TickType_t xTicksToWait, const BaseType_t xCopyPosition, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSend_CALL_INSTANCE));
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSend_CallInstance, cmock_guts_index);
  Mock.xQueueGenericSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGenericSend(cmock_call_instance, xQueue, pvItemToQueue, pvItemToQueue_Depth, xTicksToWait, xCopyPosition);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueGenericSend_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueGenericSend_CMockIgnoreArg_pvItemToQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvItemToQueue = 1;
}

void xQueueGenericSend_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

void xQueueGenericSend_CMockIgnoreArg_xCopyPosition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xCopyPosition = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueuePeek
#else
BaseType_t xQueuePeek(QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait) __attribute__((weak));
#endif

BaseType_t xQueuePeek(QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueuePeek);
  cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueuePeek_CallInstance);
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemNext(Mock.xQueuePeek_CallInstance);
  if (Mock.xQueuePeek_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueuePeek_FinalReturn;
    memcpy((void*)(&Mock.xQueuePeek_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueuePeek_CallbackBool &&
      Mock.xQueuePeek_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueuePeek_CallbackFunctionPointer(xQueue, pvBuffer, xTicksToWait, Mock.xQueuePeek_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeek,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeek,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_call_instance->Expected_pvBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeek,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueuePeek_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueuePeek_CallbackFunctionPointer(xQueue, pvBuffer, xTicksToWait, Mock.xQueuePeek_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvBuffer, (void*)cmock_call_instance->ReturnThruPtr_pvBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pvBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueuePeek(CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, int pvBuffer_Depth, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  cmock_call_instance->Expected_pvBuffer_Depth = pvBuffer_Depth;
  cmock_call_instance->IgnoreArg_pvBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xQueuePeek_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeek_CALL_INSTANCE));
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeek_CallInstance, cmock_guts_index);
  Mock.xQueuePeek_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueuePeek_IgnoreBool = (char)1;
}

void xQueuePeek_CMockStopIgnore(void)
{
  if(Mock.xQueuePeek_IgnoreBool)
    Mock.xQueuePeek_CallInstance = CMock_Guts_MemNext(Mock.xQueuePeek_CallInstance);
  Mock.xQueuePeek_IgnoreBool = (char)0;
}

void xQueuePeek_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeek_CALL_INSTANCE));
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeek_CallInstance, cmock_guts_index);
  Mock.xQueuePeek_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueuePeek_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeek_CALL_INSTANCE));
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeek_CallInstance, cmock_guts_index);
  Mock.xQueuePeek_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueuePeek(cmock_call_instance, xQueue, pvBuffer, 1, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueuePeek_AddCallback(CMOCK_xQueuePeek_CALLBACK Callback)
{
  Mock.xQueuePeek_IgnoreBool = (char)0;
  Mock.xQueuePeek_CallbackBool = (char)1;
  Mock.xQueuePeek_CallbackFunctionPointer = Callback;
}

void xQueuePeek_Stub(CMOCK_xQueuePeek_CALLBACK Callback)
{
  Mock.xQueuePeek_IgnoreBool = (char)0;
  Mock.xQueuePeek_CallbackBool = (char)0;
  Mock.xQueuePeek_CallbackFunctionPointer = Callback;
}

void xQueuePeek_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, int pvBuffer_Depth, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeek_CALL_INSTANCE));
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeek_CallInstance, cmock_guts_index);
  Mock.xQueuePeek_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueuePeek(cmock_call_instance, xQueue, pvBuffer, pvBuffer_Depth, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueuePeek_CMockReturnMemThruPtr_pvBuffer(UNITY_LINE_TYPE cmock_line, void* pvBuffer, int cmock_size)
{
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueuePeek_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Val = pvBuffer;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Size = cmock_size;
}

void xQueuePeek_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueuePeek_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueuePeek_CMockIgnoreArg_pvBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueuePeek_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvBuffer = 1;
}

void xQueuePeek_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueuePeek_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueuePeekFromISR
#else
BaseType_t xQueuePeekFromISR(QueueHandle_t xQueue, void* const pvBuffer) __attribute__((weak));
#endif

BaseType_t xQueuePeekFromISR(QueueHandle_t xQueue, void* const pvBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueuePeekFromISR);
  cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueuePeekFromISR_CallInstance);
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueuePeekFromISR_CallInstance);
  if (Mock.xQueuePeekFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueuePeekFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueuePeekFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueuePeekFromISR_CallbackBool &&
      Mock.xQueuePeekFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueuePeekFromISR_CallbackFunctionPointer(xQueue, pvBuffer, Mock.xQueuePeekFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeekFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xQueuePeekFromISR,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_call_instance->Expected_pvBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xQueuePeekFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueuePeekFromISR_CallbackFunctionPointer(xQueue, pvBuffer, Mock.xQueuePeekFromISR_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvBuffer, (void*)cmock_call_instance->ReturnThruPtr_pvBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pvBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueuePeekFromISR(CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, int pvBuffer_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  cmock_call_instance->Expected_pvBuffer_Depth = pvBuffer_Depth;
  cmock_call_instance->IgnoreArg_pvBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 0;
}

void xQueuePeekFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeekFromISR_CALL_INSTANCE));
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeekFromISR_CallInstance, cmock_guts_index);
  Mock.xQueuePeekFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueuePeekFromISR_IgnoreBool = (char)1;
}

void xQueuePeekFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueuePeekFromISR_IgnoreBool)
    Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueuePeekFromISR_CallInstance);
  Mock.xQueuePeekFromISR_IgnoreBool = (char)0;
}

void xQueuePeekFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeekFromISR_CALL_INSTANCE));
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeekFromISR_CallInstance, cmock_guts_index);
  Mock.xQueuePeekFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueuePeekFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeekFromISR_CALL_INSTANCE));
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeekFromISR_CallInstance, cmock_guts_index);
  Mock.xQueuePeekFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueuePeekFromISR(cmock_call_instance, xQueue, pvBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueuePeekFromISR_AddCallback(CMOCK_xQueuePeekFromISR_CALLBACK Callback)
{
  Mock.xQueuePeekFromISR_IgnoreBool = (char)0;
  Mock.xQueuePeekFromISR_CallbackBool = (char)1;
  Mock.xQueuePeekFromISR_CallbackFunctionPointer = Callback;
}

void xQueuePeekFromISR_Stub(CMOCK_xQueuePeekFromISR_CALLBACK Callback)
{
  Mock.xQueuePeekFromISR_IgnoreBool = (char)0;
  Mock.xQueuePeekFromISR_CallbackBool = (char)0;
  Mock.xQueuePeekFromISR_CallbackFunctionPointer = Callback;
}

void xQueuePeekFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, int pvBuffer_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeekFromISR_CALL_INSTANCE));
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeekFromISR_CallInstance, cmock_guts_index);
  Mock.xQueuePeekFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueuePeekFromISR(cmock_call_instance, xQueue, pvBuffer, pvBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueuePeekFromISR_CMockReturnMemThruPtr_pvBuffer(UNITY_LINE_TYPE cmock_line, void* pvBuffer, int cmock_size)
{
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueuePeekFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Val = pvBuffer;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Size = cmock_size;
}

void xQueuePeekFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueuePeekFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueuePeekFromISR_CMockIgnoreArg_pvBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueuePeekFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueReceive
#else
BaseType_t xQueueReceive(QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait) __attribute__((weak));
#endif

BaseType_t xQueueReceive(QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueReceive);
  cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueReceive_CallInstance);
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemNext(Mock.xQueueReceive_CallInstance);
  if (Mock.xQueueReceive_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueReceive_FinalReturn;
    memcpy((void*)(&Mock.xQueueReceive_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueReceive_CallbackBool &&
      Mock.xQueueReceive_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueReceive_CallbackFunctionPointer(xQueue, pvBuffer, xTicksToWait, Mock.xQueueReceive_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceive,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceive,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_call_instance->Expected_pvBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceive,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueReceive_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueReceive_CallbackFunctionPointer(xQueue, pvBuffer, xTicksToWait, Mock.xQueueReceive_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvBuffer, (void*)cmock_call_instance->ReturnThruPtr_pvBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pvBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueReceive(CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, int pvBuffer_Depth, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  cmock_call_instance->Expected_pvBuffer_Depth = pvBuffer_Depth;
  cmock_call_instance->IgnoreArg_pvBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xQueueReceive_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceive_CALL_INSTANCE));
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceive_CallInstance, cmock_guts_index);
  Mock.xQueueReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueReceive_IgnoreBool = (char)1;
}

void xQueueReceive_CMockStopIgnore(void)
{
  if(Mock.xQueueReceive_IgnoreBool)
    Mock.xQueueReceive_CallInstance = CMock_Guts_MemNext(Mock.xQueueReceive_CallInstance);
  Mock.xQueueReceive_IgnoreBool = (char)0;
}

void xQueueReceive_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceive_CALL_INSTANCE));
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceive_CallInstance, cmock_guts_index);
  Mock.xQueueReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueReceive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceive_CALL_INSTANCE));
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceive_CallInstance, cmock_guts_index);
  Mock.xQueueReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueReceive(cmock_call_instance, xQueue, pvBuffer, 1, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueReceive_AddCallback(CMOCK_xQueueReceive_CALLBACK Callback)
{
  Mock.xQueueReceive_IgnoreBool = (char)0;
  Mock.xQueueReceive_CallbackBool = (char)1;
  Mock.xQueueReceive_CallbackFunctionPointer = Callback;
}

void xQueueReceive_Stub(CMOCK_xQueueReceive_CALLBACK Callback)
{
  Mock.xQueueReceive_IgnoreBool = (char)0;
  Mock.xQueueReceive_CallbackBool = (char)0;
  Mock.xQueueReceive_CallbackFunctionPointer = Callback;
}

void xQueueReceive_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, int pvBuffer_Depth, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceive_CALL_INSTANCE));
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceive_CallInstance, cmock_guts_index);
  Mock.xQueueReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueReceive(cmock_call_instance, xQueue, pvBuffer, pvBuffer_Depth, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueReceive_CMockReturnMemThruPtr_pvBuffer(UNITY_LINE_TYPE cmock_line, void* pvBuffer, int cmock_size)
{
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Val = pvBuffer;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Size = cmock_size;
}

void xQueueReceive_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueReceive_CMockIgnoreArg_pvBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvBuffer = 1;
}

void xQueueReceive_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxQueueMessagesWaiting
#else
UBaseType_t uxQueueMessagesWaiting(const QueueHandle_t xQueue) __attribute__((weak));
#endif

UBaseType_t uxQueueMessagesWaiting(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxQueueMessagesWaiting);
  cmock_call_instance = (CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxQueueMessagesWaiting_CallInstance);
  Mock.uxQueueMessagesWaiting_CallInstance = CMock_Guts_MemNext(Mock.uxQueueMessagesWaiting_CallInstance);
  if (Mock.uxQueueMessagesWaiting_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxQueueMessagesWaiting_FinalReturn;
    memcpy((void*)(&Mock.uxQueueMessagesWaiting_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxQueueMessagesWaiting_CallbackBool &&
      Mock.uxQueueMessagesWaiting_CallbackFunctionPointer != NULL)
  {
    UBaseType_t cmock_cb_ret = Mock.uxQueueMessagesWaiting_CallbackFunctionPointer(xQueue, Mock.uxQueueMessagesWaiting_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_uxQueueMessagesWaiting,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxQueueMessagesWaiting_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxQueueMessagesWaiting_CallbackFunctionPointer(xQueue, Mock.uxQueueMessagesWaiting_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxQueueMessagesWaiting(CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void uxQueueMessagesWaiting_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE));
  CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueMessagesWaiting_CallInstance = CMock_Guts_MemChain(Mock.uxQueueMessagesWaiting_CallInstance, cmock_guts_index);
  Mock.uxQueueMessagesWaiting_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxQueueMessagesWaiting_IgnoreBool = (char)1;
}

void uxQueueMessagesWaiting_CMockStopIgnore(void)
{
  if(Mock.uxQueueMessagesWaiting_IgnoreBool)
    Mock.uxQueueMessagesWaiting_CallInstance = CMock_Guts_MemNext(Mock.uxQueueMessagesWaiting_CallInstance);
  Mock.uxQueueMessagesWaiting_IgnoreBool = (char)0;
}

void uxQueueMessagesWaiting_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE));
  CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueMessagesWaiting_CallInstance = CMock_Guts_MemChain(Mock.uxQueueMessagesWaiting_CallInstance, cmock_guts_index);
  Mock.uxQueueMessagesWaiting_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxQueueMessagesWaiting_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE));
  CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueMessagesWaiting_CallInstance = CMock_Guts_MemChain(Mock.uxQueueMessagesWaiting_CallInstance, cmock_guts_index);
  Mock.uxQueueMessagesWaiting_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxQueueMessagesWaiting(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxQueueMessagesWaiting_AddCallback(CMOCK_uxQueueMessagesWaiting_CALLBACK Callback)
{
  Mock.uxQueueMessagesWaiting_IgnoreBool = (char)0;
  Mock.uxQueueMessagesWaiting_CallbackBool = (char)1;
  Mock.uxQueueMessagesWaiting_CallbackFunctionPointer = Callback;
}

void uxQueueMessagesWaiting_Stub(CMOCK_uxQueueMessagesWaiting_CALLBACK Callback)
{
  Mock.uxQueueMessagesWaiting_IgnoreBool = (char)0;
  Mock.uxQueueMessagesWaiting_CallbackBool = (char)0;
  Mock.uxQueueMessagesWaiting_CallbackFunctionPointer = Callback;
}

void uxQueueMessagesWaiting_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaiting_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxQueueMessagesWaiting_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxQueueSpacesAvailable
#else
UBaseType_t uxQueueSpacesAvailable(const QueueHandle_t xQueue) __attribute__((weak));
#endif

UBaseType_t uxQueueSpacesAvailable(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxQueueSpacesAvailable);
  cmock_call_instance = (CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxQueueSpacesAvailable_CallInstance);
  Mock.uxQueueSpacesAvailable_CallInstance = CMock_Guts_MemNext(Mock.uxQueueSpacesAvailable_CallInstance);
  if (Mock.uxQueueSpacesAvailable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxQueueSpacesAvailable_FinalReturn;
    memcpy((void*)(&Mock.uxQueueSpacesAvailable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxQueueSpacesAvailable_CallbackBool &&
      Mock.uxQueueSpacesAvailable_CallbackFunctionPointer != NULL)
  {
    UBaseType_t cmock_cb_ret = Mock.uxQueueSpacesAvailable_CallbackFunctionPointer(xQueue, Mock.uxQueueSpacesAvailable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_uxQueueSpacesAvailable,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxQueueSpacesAvailable_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxQueueSpacesAvailable_CallbackFunctionPointer(xQueue, Mock.uxQueueSpacesAvailable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxQueueSpacesAvailable(CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void uxQueueSpacesAvailable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE));
  CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueSpacesAvailable_CallInstance = CMock_Guts_MemChain(Mock.uxQueueSpacesAvailable_CallInstance, cmock_guts_index);
  Mock.uxQueueSpacesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxQueueSpacesAvailable_IgnoreBool = (char)1;
}

void uxQueueSpacesAvailable_CMockStopIgnore(void)
{
  if(Mock.uxQueueSpacesAvailable_IgnoreBool)
    Mock.uxQueueSpacesAvailable_CallInstance = CMock_Guts_MemNext(Mock.uxQueueSpacesAvailable_CallInstance);
  Mock.uxQueueSpacesAvailable_IgnoreBool = (char)0;
}

void uxQueueSpacesAvailable_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE));
  CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueSpacesAvailable_CallInstance = CMock_Guts_MemChain(Mock.uxQueueSpacesAvailable_CallInstance, cmock_guts_index);
  Mock.uxQueueSpacesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxQueueSpacesAvailable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE));
  CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueSpacesAvailable_CallInstance = CMock_Guts_MemChain(Mock.uxQueueSpacesAvailable_CallInstance, cmock_guts_index);
  Mock.uxQueueSpacesAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxQueueSpacesAvailable(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxQueueSpacesAvailable_AddCallback(CMOCK_uxQueueSpacesAvailable_CALLBACK Callback)
{
  Mock.uxQueueSpacesAvailable_IgnoreBool = (char)0;
  Mock.uxQueueSpacesAvailable_CallbackBool = (char)1;
  Mock.uxQueueSpacesAvailable_CallbackFunctionPointer = Callback;
}

void uxQueueSpacesAvailable_Stub(CMOCK_uxQueueSpacesAvailable_CALLBACK Callback)
{
  Mock.uxQueueSpacesAvailable_IgnoreBool = (char)0;
  Mock.uxQueueSpacesAvailable_CallbackBool = (char)0;
  Mock.uxQueueSpacesAvailable_CallbackFunctionPointer = Callback;
}

void uxQueueSpacesAvailable_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueSpacesAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxQueueSpacesAvailable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vQueueDelete
#else
void vQueueDelete(QueueHandle_t xQueue) __attribute__((weak));
#endif

void vQueueDelete(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueDelete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueDelete);
  cmock_call_instance = (CMOCK_vQueueDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueDelete_CallInstance);
  Mock.vQueueDelete_CallInstance = CMock_Guts_MemNext(Mock.vQueueDelete_CallInstance);
  if (Mock.vQueueDelete_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vQueueDelete_CallbackBool &&
      Mock.vQueueDelete_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueDelete_CallbackFunctionPointer(xQueue, Mock.vQueueDelete_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_vQueueDelete,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vQueueDelete_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueDelete_CallbackFunctionPointer(xQueue, Mock.vQueueDelete_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueDelete(CMOCK_vQueueDelete_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void vQueueDelete_CMockIgnore(void)
{
  Mock.vQueueDelete_IgnoreBool = (char)1;
}

void vQueueDelete_CMockStopIgnore(void)
{
  Mock.vQueueDelete_IgnoreBool = (char)0;
}

void vQueueDelete_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueDelete_CALL_INSTANCE));
  CMOCK_vQueueDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueDelete_CallInstance = CMock_Guts_MemChain(Mock.vQueueDelete_CallInstance, cmock_guts_index);
  Mock.vQueueDelete_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vQueueDelete_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueDelete_CALL_INSTANCE));
  CMOCK_vQueueDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueDelete_CallInstance = CMock_Guts_MemChain(Mock.vQueueDelete_CallInstance, cmock_guts_index);
  Mock.vQueueDelete_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vQueueDelete(cmock_call_instance, xQueue);
}

void vQueueDelete_AddCallback(CMOCK_vQueueDelete_CALLBACK Callback)
{
  Mock.vQueueDelete_IgnoreBool = (char)0;
  Mock.vQueueDelete_CallbackBool = (char)1;
  Mock.vQueueDelete_CallbackFunctionPointer = Callback;
}

void vQueueDelete_Stub(CMOCK_vQueueDelete_CALLBACK Callback)
{
  Mock.vQueueDelete_IgnoreBool = (char)0;
  Mock.vQueueDelete_CallbackBool = (char)0;
  Mock.vQueueDelete_CallbackFunctionPointer = Callback;
}

void vQueueDelete_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueDelete_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGenericSendFromISR
#else
BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition) __attribute__((weak));
#endif

BaseType_t xQueueGenericSendFromISR(QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericSendFromISR);
  cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericSendFromISR_CallInstance);
  Mock.xQueueGenericSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericSendFromISR_CallInstance);
  if (Mock.xQueueGenericSendFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGenericSendFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueGenericSendFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGenericSendFromISR_CallbackBool &&
      Mock.xQueueGenericSendFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueGenericSendFromISR_CallbackFunctionPointer(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, xCopyPosition, Mock.xQueueGenericSendFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSendFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvItemToQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSendFromISR,CMockString_pvItemToQueue);
    if (cmock_call_instance->Expected_pvItemToQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvItemToQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, cmock_call_instance->Expected_pvItemToQueue_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSendFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xCopyPosition)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericSendFromISR,CMockString_xCopyPosition);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCopyPosition), (void*)(&xCopyPosition), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueGenericSendFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGenericSendFromISR_CallbackFunctionPointer(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, xCopyPosition, Mock.xQueueGenericSendFromISR_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxHigherPriorityTaskWoken, (void*)cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericSendFromISR(CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* const pvItemToQueue, int pvItemToQueue_Depth, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, const BaseType_t xCopyPosition)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvItemToQueue = pvItemToQueue;
  cmock_call_instance->Expected_pvItemToQueue_Depth = pvItemToQueue_Depth;
  cmock_call_instance->IgnoreArg_pvItemToQueue = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xCopyPosition), (void*)(&xCopyPosition),
         sizeof(BaseType_t[sizeof(xCopyPosition) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xCopyPosition = 0;
}

void xQueueGenericSendFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGenericSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGenericSendFromISR_IgnoreBool = (char)1;
}

void xQueueGenericSendFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueGenericSendFromISR_IgnoreBool)
    Mock.xQueueGenericSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericSendFromISR_CallInstance);
  Mock.xQueueGenericSendFromISR_IgnoreBool = (char)0;
}

void xQueueGenericSendFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGenericSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGenericSendFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGenericSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGenericSendFromISR(cmock_call_instance, xQueue, pvItemToQueue, 1, pxHigherPriorityTaskWoken, 1, xCopyPosition);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueGenericSendFromISR_AddCallback(CMOCK_xQueueGenericSendFromISR_CALLBACK Callback)
{
  Mock.xQueueGenericSendFromISR_IgnoreBool = (char)0;
  Mock.xQueueGenericSendFromISR_CallbackBool = (char)1;
  Mock.xQueueGenericSendFromISR_CallbackFunctionPointer = Callback;
}

void xQueueGenericSendFromISR_Stub(CMOCK_xQueueGenericSendFromISR_CALLBACK Callback)
{
  Mock.xQueueGenericSendFromISR_IgnoreBool = (char)0;
  Mock.xQueueGenericSendFromISR_CallbackBool = (char)0;
  Mock.xQueueGenericSendFromISR_CallbackFunctionPointer = Callback;
}

void xQueueGenericSendFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* const pvItemToQueue, int pvItemToQueue_Depth, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, const BaseType_t xCopyPosition, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGenericSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGenericSendFromISR(cmock_call_instance, xQueue, pvItemToQueue, pvItemToQueue_Depth, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth, xCopyPosition);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueGenericSendFromISR_CMockReturnMemThruPtr_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t* pxHigherPriorityTaskWoken, int cmock_size)
{
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val = pxHigherPriorityTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size = cmock_size;
}

void xQueueGenericSendFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueGenericSendFromISR_CMockIgnoreArg_pvItemToQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvItemToQueue = 1;
}

void xQueueGenericSendFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

void xQueueGenericSendFromISR_CMockIgnoreArg_xCopyPosition(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xCopyPosition = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGiveFromISR
#else
BaseType_t xQueueGiveFromISR(QueueHandle_t xQueue, BaseType_t* const pxHigherPriorityTaskWoken) __attribute__((weak));
#endif

BaseType_t xQueueGiveFromISR(QueueHandle_t xQueue, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGiveFromISR);
  cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGiveFromISR_CallInstance);
  Mock.xQueueGiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGiveFromISR_CallInstance);
  if (Mock.xQueueGiveFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGiveFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueGiveFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGiveFromISR_CallbackBool &&
      Mock.xQueueGiveFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueGiveFromISR_CallbackFunctionPointer(xQueue, pxHigherPriorityTaskWoken, Mock.xQueueGiveFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGiveFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGiveFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xQueueGiveFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGiveFromISR_CallbackFunctionPointer(xQueue, pxHigherPriorityTaskWoken, Mock.xQueueGiveFromISR_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxHigherPriorityTaskWoken, (void*)cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGiveFromISR(CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 0;
}

void xQueueGiveFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGiveFromISR_IgnoreBool = (char)1;
}

void xQueueGiveFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueGiveFromISR_IgnoreBool)
    Mock.xQueueGiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGiveFromISR_CallInstance);
  Mock.xQueueGiveFromISR_IgnoreBool = (char)0;
}

void xQueueGiveFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, BaseType_t* const pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGiveFromISR(cmock_call_instance, xQueue, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueGiveFromISR_AddCallback(CMOCK_xQueueGiveFromISR_CALLBACK Callback)
{
  Mock.xQueueGiveFromISR_IgnoreBool = (char)0;
  Mock.xQueueGiveFromISR_CallbackBool = (char)1;
  Mock.xQueueGiveFromISR_CallbackFunctionPointer = Callback;
}

void xQueueGiveFromISR_Stub(CMOCK_xQueueGiveFromISR_CALLBACK Callback)
{
  Mock.xQueueGiveFromISR_IgnoreBool = (char)0;
  Mock.xQueueGiveFromISR_CallbackBool = (char)0;
  Mock.xQueueGiveFromISR_CallbackFunctionPointer = Callback;
}

void xQueueGiveFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGiveFromISR(cmock_call_instance, xQueue, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueGiveFromISR_CMockReturnMemThruPtr_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t* pxHigherPriorityTaskWoken, int cmock_size)
{
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val = pxHigherPriorityTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size = cmock_size;
}

void xQueueGiveFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueGiveFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueReceiveFromISR
#else
BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken) __attribute__((weak));
#endif

BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueReceiveFromISR);
  cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueReceiveFromISR_CallInstance);
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueReceiveFromISR_CallInstance);
  if (Mock.xQueueReceiveFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueReceiveFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueReceiveFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueReceiveFromISR_CallbackBool &&
      Mock.xQueueReceiveFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueReceiveFromISR_CallbackFunctionPointer(xQueue, pvBuffer, pxHigherPriorityTaskWoken, Mock.xQueueReceiveFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceiveFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceiveFromISR,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_call_instance->Expected_pvBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xQueueReceiveFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xQueueReceiveFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueReceiveFromISR_CallbackFunctionPointer(xQueue, pvBuffer, pxHigherPriorityTaskWoken, Mock.xQueueReceiveFromISR_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvBuffer, (void*)cmock_call_instance->ReturnThruPtr_pvBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pvBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxHigherPriorityTaskWoken, (void*)cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueReceiveFromISR(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, int pvBuffer_Depth, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  cmock_call_instance->Expected_pvBuffer_Depth = pvBuffer_Depth;
  cmock_call_instance->IgnoreArg_pvBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 0;
}

void xQueueReceiveFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueReceiveFromISR_IgnoreBool = (char)1;
}

void xQueueReceiveFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueReceiveFromISR_IgnoreBool)
    Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueReceiveFromISR_CallInstance);
  Mock.xQueueReceiveFromISR_IgnoreBool = (char)0;
}

void xQueueReceiveFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueReceiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueReceiveFromISR(cmock_call_instance, xQueue, pvBuffer, 1, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueReceiveFromISR_AddCallback(CMOCK_xQueueReceiveFromISR_CALLBACK Callback)
{
  Mock.xQueueReceiveFromISR_IgnoreBool = (char)0;
  Mock.xQueueReceiveFromISR_CallbackBool = (char)1;
  Mock.xQueueReceiveFromISR_CallbackFunctionPointer = Callback;
}

void xQueueReceiveFromISR_Stub(CMOCK_xQueueReceiveFromISR_CALLBACK Callback)
{
  Mock.xQueueReceiveFromISR_IgnoreBool = (char)0;
  Mock.xQueueReceiveFromISR_CallbackBool = (char)0;
  Mock.xQueueReceiveFromISR_CallbackFunctionPointer = Callback;
}

void xQueueReceiveFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, int pvBuffer_Depth, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueReceiveFromISR(cmock_call_instance, xQueue, pvBuffer, pvBuffer_Depth, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueReceiveFromISR_CMockReturnMemThruPtr_pvBuffer(UNITY_LINE_TYPE cmock_line, void* pvBuffer, int cmock_size)
{
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Val = pvBuffer;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Size = cmock_size;
}

void xQueueReceiveFromISR_CMockReturnMemThruPtr_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t* pxHigherPriorityTaskWoken, int cmock_size)
{
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val = pxHigherPriorityTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size = cmock_size;
}

void xQueueReceiveFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueReceiveFromISR_CMockIgnoreArg_pvBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvBuffer = 1;
}

void xQueueReceiveFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueIsQueueEmptyFromISR
#else
BaseType_t xQueueIsQueueEmptyFromISR(const QueueHandle_t xQueue) __attribute__((weak));
#endif

BaseType_t xQueueIsQueueEmptyFromISR(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueIsQueueEmptyFromISR);
  cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueIsQueueEmptyFromISR_CallInstance);
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueIsQueueEmptyFromISR_CallInstance);
  if (Mock.xQueueIsQueueEmptyFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueIsQueueEmptyFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueIsQueueEmptyFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueIsQueueEmptyFromISR_CallbackBool &&
      Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer(xQueue, Mock.xQueueIsQueueEmptyFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueIsQueueEmptyFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer(xQueue, Mock.xQueueIsQueueEmptyFromISR_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueIsQueueEmptyFromISR(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void xQueueIsQueueEmptyFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueEmptyFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (char)1;
}

void xQueueIsQueueEmptyFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueIsQueueEmptyFromISR_IgnoreBool)
    Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueIsQueueEmptyFromISR_CallInstance);
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (char)0;
}

void xQueueIsQueueEmptyFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueEmptyFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueIsQueueEmptyFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueEmptyFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueIsQueueEmptyFromISR(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueIsQueueEmptyFromISR_AddCallback(CMOCK_xQueueIsQueueEmptyFromISR_CALLBACK Callback)
{
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (char)0;
  Mock.xQueueIsQueueEmptyFromISR_CallbackBool = (char)1;
  Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer = Callback;
}

void xQueueIsQueueEmptyFromISR_Stub(CMOCK_xQueueIsQueueEmptyFromISR_CALLBACK Callback)
{
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (char)0;
  Mock.xQueueIsQueueEmptyFromISR_CallbackBool = (char)0;
  Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer = Callback;
}

void xQueueIsQueueEmptyFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueIsQueueEmptyFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueIsQueueFullFromISR
#else
BaseType_t xQueueIsQueueFullFromISR(const QueueHandle_t xQueue) __attribute__((weak));
#endif

BaseType_t xQueueIsQueueFullFromISR(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueIsQueueFullFromISR);
  cmock_call_instance = (CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueIsQueueFullFromISR_CallInstance);
  Mock.xQueueIsQueueFullFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueIsQueueFullFromISR_CallInstance);
  if (Mock.xQueueIsQueueFullFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueIsQueueFullFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueIsQueueFullFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueIsQueueFullFromISR_CallbackBool &&
      Mock.xQueueIsQueueFullFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueIsQueueFullFromISR_CallbackFunctionPointer(xQueue, Mock.xQueueIsQueueFullFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueIsQueueFullFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueIsQueueFullFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueIsQueueFullFromISR_CallbackFunctionPointer(xQueue, Mock.xQueueIsQueueFullFromISR_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueIsQueueFullFromISR(CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void xQueueIsQueueFullFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueFullFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueFullFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueIsQueueFullFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueIsQueueFullFromISR_IgnoreBool = (char)1;
}

void xQueueIsQueueFullFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueIsQueueFullFromISR_IgnoreBool)
    Mock.xQueueIsQueueFullFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueIsQueueFullFromISR_CallInstance);
  Mock.xQueueIsQueueFullFromISR_IgnoreBool = (char)0;
}

void xQueueIsQueueFullFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueFullFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueFullFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueIsQueueFullFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueIsQueueFullFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueFullFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueFullFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueIsQueueFullFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueIsQueueFullFromISR(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueIsQueueFullFromISR_AddCallback(CMOCK_xQueueIsQueueFullFromISR_CALLBACK Callback)
{
  Mock.xQueueIsQueueFullFromISR_IgnoreBool = (char)0;
  Mock.xQueueIsQueueFullFromISR_CallbackBool = (char)1;
  Mock.xQueueIsQueueFullFromISR_CallbackFunctionPointer = Callback;
}

void xQueueIsQueueFullFromISR_Stub(CMOCK_xQueueIsQueueFullFromISR_CALLBACK Callback)
{
  Mock.xQueueIsQueueFullFromISR_IgnoreBool = (char)0;
  Mock.xQueueIsQueueFullFromISR_CallbackBool = (char)0;
  Mock.xQueueIsQueueFullFromISR_CallbackFunctionPointer = Callback;
}

void xQueueIsQueueFullFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueFullFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueIsQueueFullFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxQueueMessagesWaitingFromISR
#else
UBaseType_t uxQueueMessagesWaitingFromISR(const QueueHandle_t xQueue) __attribute__((weak));
#endif

UBaseType_t uxQueueMessagesWaitingFromISR(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxQueueMessagesWaitingFromISR);
  cmock_call_instance = (CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxQueueMessagesWaitingFromISR_CallInstance);
  Mock.uxQueueMessagesWaitingFromISR_CallInstance = CMock_Guts_MemNext(Mock.uxQueueMessagesWaitingFromISR_CallInstance);
  if (Mock.uxQueueMessagesWaitingFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxQueueMessagesWaitingFromISR_FinalReturn;
    memcpy((void*)(&Mock.uxQueueMessagesWaitingFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxQueueMessagesWaitingFromISR_CallbackBool &&
      Mock.uxQueueMessagesWaitingFromISR_CallbackFunctionPointer != NULL)
  {
    UBaseType_t cmock_cb_ret = Mock.uxQueueMessagesWaitingFromISR_CallbackFunctionPointer(xQueue, Mock.uxQueueMessagesWaitingFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_uxQueueMessagesWaitingFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxQueueMessagesWaitingFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxQueueMessagesWaitingFromISR_CallbackFunctionPointer(xQueue, Mock.uxQueueMessagesWaitingFromISR_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxQueueMessagesWaitingFromISR(CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void uxQueueMessagesWaitingFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE));
  CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueMessagesWaitingFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxQueueMessagesWaitingFromISR_CallInstance, cmock_guts_index);
  Mock.uxQueueMessagesWaitingFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxQueueMessagesWaitingFromISR_IgnoreBool = (char)1;
}

void uxQueueMessagesWaitingFromISR_CMockStopIgnore(void)
{
  if(Mock.uxQueueMessagesWaitingFromISR_IgnoreBool)
    Mock.uxQueueMessagesWaitingFromISR_CallInstance = CMock_Guts_MemNext(Mock.uxQueueMessagesWaitingFromISR_CallInstance);
  Mock.uxQueueMessagesWaitingFromISR_IgnoreBool = (char)0;
}

void uxQueueMessagesWaitingFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE));
  CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueMessagesWaitingFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxQueueMessagesWaitingFromISR_CallInstance, cmock_guts_index);
  Mock.uxQueueMessagesWaitingFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxQueueMessagesWaitingFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE));
  CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueMessagesWaitingFromISR_CallInstance = CMock_Guts_MemChain(Mock.uxQueueMessagesWaitingFromISR_CallInstance, cmock_guts_index);
  Mock.uxQueueMessagesWaitingFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxQueueMessagesWaitingFromISR(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxQueueMessagesWaitingFromISR_AddCallback(CMOCK_uxQueueMessagesWaitingFromISR_CALLBACK Callback)
{
  Mock.uxQueueMessagesWaitingFromISR_IgnoreBool = (char)0;
  Mock.uxQueueMessagesWaitingFromISR_CallbackBool = (char)1;
  Mock.uxQueueMessagesWaitingFromISR_CallbackFunctionPointer = Callback;
}

void uxQueueMessagesWaitingFromISR_Stub(CMOCK_uxQueueMessagesWaitingFromISR_CALLBACK Callback)
{
  Mock.uxQueueMessagesWaitingFromISR_IgnoreBool = (char)0;
  Mock.uxQueueMessagesWaitingFromISR_CallbackBool = (char)0;
  Mock.uxQueueMessagesWaitingFromISR_CallbackFunctionPointer = Callback;
}

void uxQueueMessagesWaitingFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueMessagesWaitingFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxQueueMessagesWaitingFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCRSendFromISR
#else
BaseType_t xQueueCRSendFromISR(QueueHandle_t xQueue, const void* pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken) __attribute__((weak));
#endif

BaseType_t xQueueCRSendFromISR(QueueHandle_t xQueue, const void* pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCRSendFromISR);
  cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCRSendFromISR_CallInstance);
  Mock.xQueueCRSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRSendFromISR_CallInstance);
  if (Mock.xQueueCRSendFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCRSendFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueCRSendFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCRSendFromISR_CallbackBool &&
      Mock.xQueueCRSendFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueCRSendFromISR_CallbackFunctionPointer(xQueue, pvItemToQueue, xCoRoutinePreviouslyWoken, Mock.xQueueCRSendFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSendFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvItemToQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSendFromISR,CMockString_pvItemToQueue);
    if (cmock_call_instance->Expected_pvItemToQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvItemToQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, cmock_call_instance->Expected_pvItemToQueue_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xCoRoutinePreviouslyWoken)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSendFromISR,CMockString_xCoRoutinePreviouslyWoken);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCoRoutinePreviouslyWoken), (void*)(&xCoRoutinePreviouslyWoken), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueCRSendFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCRSendFromISR_CallbackFunctionPointer(xQueue, pvItemToQueue, xCoRoutinePreviouslyWoken, Mock.xQueueCRSendFromISR_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCRSendFromISR(CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* pvItemToQueue, int pvItemToQueue_Depth, BaseType_t xCoRoutinePreviouslyWoken)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvItemToQueue = pvItemToQueue;
  cmock_call_instance->Expected_pvItemToQueue_Depth = pvItemToQueue_Depth;
  cmock_call_instance->IgnoreArg_pvItemToQueue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xCoRoutinePreviouslyWoken), (void*)(&xCoRoutinePreviouslyWoken),
         sizeof(BaseType_t[sizeof(xCoRoutinePreviouslyWoken) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xCoRoutinePreviouslyWoken = 0;
}

void xQueueCRSendFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueCRSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCRSendFromISR_IgnoreBool = (char)1;
}

void xQueueCRSendFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueCRSendFromISR_IgnoreBool)
    Mock.xQueueCRSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRSendFromISR_CallInstance);
  Mock.xQueueCRSendFromISR_IgnoreBool = (char)0;
}

void xQueueCRSendFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueCRSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCRSendFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueCRSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCRSendFromISR(cmock_call_instance, xQueue, pvItemToQueue, 1, xCoRoutinePreviouslyWoken);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueCRSendFromISR_AddCallback(CMOCK_xQueueCRSendFromISR_CALLBACK Callback)
{
  Mock.xQueueCRSendFromISR_IgnoreBool = (char)0;
  Mock.xQueueCRSendFromISR_CallbackBool = (char)1;
  Mock.xQueueCRSendFromISR_CallbackFunctionPointer = Callback;
}

void xQueueCRSendFromISR_Stub(CMOCK_xQueueCRSendFromISR_CALLBACK Callback)
{
  Mock.xQueueCRSendFromISR_IgnoreBool = (char)0;
  Mock.xQueueCRSendFromISR_CallbackBool = (char)0;
  Mock.xQueueCRSendFromISR_CallbackFunctionPointer = Callback;
}

void xQueueCRSendFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* pvItemToQueue, int pvItemToQueue_Depth, BaseType_t xCoRoutinePreviouslyWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueCRSendFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCRSendFromISR(cmock_call_instance, xQueue, pvItemToQueue, pvItemToQueue_Depth, xCoRoutinePreviouslyWoken);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueCRSendFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueCRSendFromISR_CMockIgnoreArg_pvItemToQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvItemToQueue = 1;
}

void xQueueCRSendFromISR_CMockIgnoreArg_xCoRoutinePreviouslyWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRSendFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xCoRoutinePreviouslyWoken = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCRReceiveFromISR
#else
BaseType_t xQueueCRReceiveFromISR(QueueHandle_t xQueue, void* pvBuffer, BaseType_t* pxTaskWoken) __attribute__((weak));
#endif

BaseType_t xQueueCRReceiveFromISR(QueueHandle_t xQueue, void* pvBuffer, BaseType_t* pxTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCRReceiveFromISR);
  cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCRReceiveFromISR_CallInstance);
  Mock.xQueueCRReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRReceiveFromISR_CallInstance);
  if (Mock.xQueueCRReceiveFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCRReceiveFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueCRReceiveFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCRReceiveFromISR_CallbackBool &&
      Mock.xQueueCRReceiveFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueCRReceiveFromISR_CallbackFunctionPointer(xQueue, pvBuffer, pxTaskWoken, Mock.xQueueCRReceiveFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceiveFromISR,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceiveFromISR,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_call_instance->Expected_pvBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceiveFromISR,CMockString_pxTaskWoken);
    if (cmock_call_instance->Expected_pxTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTaskWoken), (void*)(pxTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xQueueCRReceiveFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCRReceiveFromISR_CallbackFunctionPointer(xQueue, pvBuffer, pxTaskWoken, Mock.xQueueCRReceiveFromISR_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvBuffer, (void*)cmock_call_instance->ReturnThruPtr_pvBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pvBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTaskWoken, (void*)cmock_call_instance->ReturnThruPtr_pxTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCRReceiveFromISR(CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* pvBuffer, int pvBuffer_Depth, BaseType_t* pxTaskWoken, int pxTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  cmock_call_instance->Expected_pvBuffer_Depth = pvBuffer_Depth;
  cmock_call_instance->IgnoreArg_pvBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 0;
  cmock_call_instance->Expected_pxTaskWoken = pxTaskWoken;
  cmock_call_instance->Expected_pxTaskWoken_Depth = pxTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxTaskWoken_Used = 0;
}

void xQueueCRReceiveFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueCRReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCRReceiveFromISR_IgnoreBool = (char)1;
}

void xQueueCRReceiveFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueCRReceiveFromISR_IgnoreBool)
    Mock.xQueueCRReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRReceiveFromISR_CallInstance);
  Mock.xQueueCRReceiveFromISR_IgnoreBool = (char)0;
}

void xQueueCRReceiveFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueCRReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCRReceiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* pvBuffer, BaseType_t* pxTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueCRReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCRReceiveFromISR(cmock_call_instance, xQueue, pvBuffer, 1, pxTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueCRReceiveFromISR_AddCallback(CMOCK_xQueueCRReceiveFromISR_CALLBACK Callback)
{
  Mock.xQueueCRReceiveFromISR_IgnoreBool = (char)0;
  Mock.xQueueCRReceiveFromISR_CallbackBool = (char)1;
  Mock.xQueueCRReceiveFromISR_CallbackFunctionPointer = Callback;
}

void xQueueCRReceiveFromISR_Stub(CMOCK_xQueueCRReceiveFromISR_CALLBACK Callback)
{
  Mock.xQueueCRReceiveFromISR_IgnoreBool = (char)0;
  Mock.xQueueCRReceiveFromISR_CallbackBool = (char)0;
  Mock.xQueueCRReceiveFromISR_CallbackFunctionPointer = Callback;
}

void xQueueCRReceiveFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* pvBuffer, int pvBuffer_Depth, BaseType_t* pxTaskWoken, int pxTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueCRReceiveFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCRReceiveFromISR(cmock_call_instance, xQueue, pvBuffer, pvBuffer_Depth, pxTaskWoken, pxTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueCRReceiveFromISR_CMockReturnMemThruPtr_pvBuffer(UNITY_LINE_TYPE cmock_line, void* pvBuffer, int cmock_size)
{
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Val = pvBuffer;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Size = cmock_size;
}

void xQueueCRReceiveFromISR_CMockReturnMemThruPtr_pxTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t* pxTaskWoken, int cmock_size)
{
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTaskWoken_Val = pxTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxTaskWoken_Size = cmock_size;
}

void xQueueCRReceiveFromISR_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueCRReceiveFromISR_CMockIgnoreArg_pvBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvBuffer = 1;
}

void xQueueCRReceiveFromISR_CMockIgnoreArg_pxTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceiveFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTaskWoken = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCRSend
#else
BaseType_t xQueueCRSend(QueueHandle_t xQueue, const void* pvItemToQueue, TickType_t xTicksToWait) __attribute__((weak));
#endif

BaseType_t xQueueCRSend(QueueHandle_t xQueue, const void* pvItemToQueue, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCRSend);
  cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCRSend_CallInstance);
  Mock.xQueueCRSend_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRSend_CallInstance);
  if (Mock.xQueueCRSend_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCRSend_FinalReturn;
    memcpy((void*)(&Mock.xQueueCRSend_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCRSend_CallbackBool &&
      Mock.xQueueCRSend_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueCRSend_CallbackFunctionPointer(xQueue, pvItemToQueue, xTicksToWait, Mock.xQueueCRSend_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSend,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvItemToQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSend,CMockString_pvItemToQueue);
    if (cmock_call_instance->Expected_pvItemToQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pvItemToQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, cmock_call_instance->Expected_pvItemToQueue_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRSend,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueCRSend_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCRSend_CallbackFunctionPointer(xQueue, pvItemToQueue, xTicksToWait, Mock.xQueueCRSend_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCRSend(CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* pvItemToQueue, int pvItemToQueue_Depth, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvItemToQueue = pvItemToQueue;
  cmock_call_instance->Expected_pvItemToQueue_Depth = pvItemToQueue_Depth;
  cmock_call_instance->IgnoreArg_pvItemToQueue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xQueueCRSend_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSend_CALL_INSTANCE));
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSend_CallInstance, cmock_guts_index);
  Mock.xQueueCRSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCRSend_IgnoreBool = (char)1;
}

void xQueueCRSend_CMockStopIgnore(void)
{
  if(Mock.xQueueCRSend_IgnoreBool)
    Mock.xQueueCRSend_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRSend_CallInstance);
  Mock.xQueueCRSend_IgnoreBool = (char)0;
}

void xQueueCRSend_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSend_CALL_INSTANCE));
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSend_CallInstance, cmock_guts_index);
  Mock.xQueueCRSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCRSend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* pvItemToQueue, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSend_CALL_INSTANCE));
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSend_CallInstance, cmock_guts_index);
  Mock.xQueueCRSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCRSend(cmock_call_instance, xQueue, pvItemToQueue, 1, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueCRSend_AddCallback(CMOCK_xQueueCRSend_CALLBACK Callback)
{
  Mock.xQueueCRSend_IgnoreBool = (char)0;
  Mock.xQueueCRSend_CallbackBool = (char)1;
  Mock.xQueueCRSend_CallbackFunctionPointer = Callback;
}

void xQueueCRSend_Stub(CMOCK_xQueueCRSend_CALLBACK Callback)
{
  Mock.xQueueCRSend_IgnoreBool = (char)0;
  Mock.xQueueCRSend_CallbackBool = (char)0;
  Mock.xQueueCRSend_CallbackFunctionPointer = Callback;
}

void xQueueCRSend_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* pvItemToQueue, int pvItemToQueue_Depth, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRSend_CALL_INSTANCE));
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRSend_CallInstance, cmock_guts_index);
  Mock.xQueueCRSend_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCRSend(cmock_call_instance, xQueue, pvItemToQueue, pvItemToQueue_Depth, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueCRSend_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueCRSend_CMockIgnoreArg_pvItemToQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvItemToQueue = 1;
}

void xQueueCRSend_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRSend_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCRReceive
#else
BaseType_t xQueueCRReceive(QueueHandle_t xQueue, void* pvBuffer, TickType_t xTicksToWait) __attribute__((weak));
#endif

BaseType_t xQueueCRReceive(QueueHandle_t xQueue, void* pvBuffer, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCRReceive);
  cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCRReceive_CallInstance);
  Mock.xQueueCRReceive_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRReceive_CallInstance);
  if (Mock.xQueueCRReceive_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCRReceive_FinalReturn;
    memcpy((void*)(&Mock.xQueueCRReceive_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCRReceive_CallbackBool &&
      Mock.xQueueCRReceive_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueCRReceive_CallbackFunctionPointer(xQueue, pvBuffer, xTicksToWait, Mock.xQueueCRReceive_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceive,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceive,CMockString_pvBuffer);
    if (cmock_call_instance->Expected_pvBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pvBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_call_instance->Expected_pvBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCRReceive,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueCRReceive_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCRReceive_CallbackFunctionPointer(xQueue, pvBuffer, xTicksToWait, Mock.xQueueCRReceive_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvBuffer, (void*)cmock_call_instance->ReturnThruPtr_pvBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pvBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCRReceive(CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* pvBuffer, int pvBuffer_Depth, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pvBuffer = pvBuffer;
  cmock_call_instance->Expected_pvBuffer_Depth = pvBuffer_Depth;
  cmock_call_instance->IgnoreArg_pvBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xQueueCRReceive_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceive_CALL_INSTANCE));
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceive_CallInstance, cmock_guts_index);
  Mock.xQueueCRReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCRReceive_IgnoreBool = (char)1;
}

void xQueueCRReceive_CMockStopIgnore(void)
{
  if(Mock.xQueueCRReceive_IgnoreBool)
    Mock.xQueueCRReceive_CallInstance = CMock_Guts_MemNext(Mock.xQueueCRReceive_CallInstance);
  Mock.xQueueCRReceive_IgnoreBool = (char)0;
}

void xQueueCRReceive_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceive_CALL_INSTANCE));
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceive_CallInstance, cmock_guts_index);
  Mock.xQueueCRReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCRReceive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* pvBuffer, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceive_CALL_INSTANCE));
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceive_CallInstance, cmock_guts_index);
  Mock.xQueueCRReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCRReceive(cmock_call_instance, xQueue, pvBuffer, 1, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueCRReceive_AddCallback(CMOCK_xQueueCRReceive_CALLBACK Callback)
{
  Mock.xQueueCRReceive_IgnoreBool = (char)0;
  Mock.xQueueCRReceive_CallbackBool = (char)1;
  Mock.xQueueCRReceive_CallbackFunctionPointer = Callback;
}

void xQueueCRReceive_Stub(CMOCK_xQueueCRReceive_CALLBACK Callback)
{
  Mock.xQueueCRReceive_IgnoreBool = (char)0;
  Mock.xQueueCRReceive_CallbackBool = (char)0;
  Mock.xQueueCRReceive_CallbackFunctionPointer = Callback;
}

void xQueueCRReceive_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* pvBuffer, int pvBuffer_Depth, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCRReceive_CALL_INSTANCE));
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCRReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueCRReceive_CallInstance, cmock_guts_index);
  Mock.xQueueCRReceive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCRReceive(cmock_call_instance, xQueue, pvBuffer, pvBuffer_Depth, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueCRReceive_CMockReturnMemThruPtr_pvBuffer(UNITY_LINE_TYPE cmock_line, void* pvBuffer, int cmock_size)
{
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Val = pvBuffer;
  cmock_call_instance->ReturnThruPtr_pvBuffer_Size = cmock_size;
}

void xQueueCRReceive_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueCRReceive_CMockIgnoreArg_pvBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvBuffer = 1;
}

void xQueueCRReceive_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCRReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCRReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCRReceive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCreateMutex
#else
QueueHandle_t xQueueCreateMutex(const uint8_t ucQueueType) __attribute__((weak));
#endif

QueueHandle_t xQueueCreateMutex(const uint8_t ucQueueType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateMutex);
  cmock_call_instance = (CMOCK_xQueueCreateMutex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateMutex_CallInstance);
  Mock.xQueueCreateMutex_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateMutex_CallInstance);
  if (Mock.xQueueCreateMutex_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCreateMutex_FinalReturn;
    memcpy((void*)(&Mock.xQueueCreateMutex_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCreateMutex_CallbackBool &&
      Mock.xQueueCreateMutex_CallbackFunctionPointer != NULL)
  {
    QueueHandle_t cmock_cb_ret = Mock.xQueueCreateMutex_CallbackFunctionPointer(ucQueueType, Mock.xQueueCreateMutex_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ucQueueType)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateMutex,CMockString_ucQueueType);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucQueueType, ucQueueType, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueCreateMutex_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCreateMutex_CallbackFunctionPointer(ucQueueType, Mock.xQueueCreateMutex_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateMutex(CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance, const uint8_t ucQueueType)
{
  cmock_call_instance->Expected_ucQueueType = ucQueueType;
  cmock_call_instance->IgnoreArg_ucQueueType = 0;
}

void xQueueCreateMutex_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutex_CALL_INSTANCE));
  CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutex_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutex_CallInstance, cmock_guts_index);
  Mock.xQueueCreateMutex_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCreateMutex_IgnoreBool = (char)1;
}

void xQueueCreateMutex_CMockStopIgnore(void)
{
  if(Mock.xQueueCreateMutex_IgnoreBool)
    Mock.xQueueCreateMutex_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateMutex_CallInstance);
  Mock.xQueueCreateMutex_IgnoreBool = (char)0;
}

void xQueueCreateMutex_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutex_CALL_INSTANCE));
  CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutex_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutex_CallInstance, cmock_guts_index);
  Mock.xQueueCreateMutex_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCreateMutex_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const uint8_t ucQueueType, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutex_CALL_INSTANCE));
  CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutex_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutex_CallInstance, cmock_guts_index);
  Mock.xQueueCreateMutex_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCreateMutex(cmock_call_instance, ucQueueType);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueCreateMutex_AddCallback(CMOCK_xQueueCreateMutex_CALLBACK Callback)
{
  Mock.xQueueCreateMutex_IgnoreBool = (char)0;
  Mock.xQueueCreateMutex_CallbackBool = (char)1;
  Mock.xQueueCreateMutex_CallbackFunctionPointer = Callback;
}

void xQueueCreateMutex_Stub(CMOCK_xQueueCreateMutex_CALLBACK Callback)
{
  Mock.xQueueCreateMutex_IgnoreBool = (char)0;
  Mock.xQueueCreateMutex_CallbackBool = (char)0;
  Mock.xQueueCreateMutex_CallbackFunctionPointer = Callback;
}

void xQueueCreateMutex_CMockIgnoreArg_ucQueueType(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateMutex_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutex_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateMutex_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ucQueueType = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCreateMutexStatic
#else
QueueHandle_t xQueueCreateMutexStatic(const uint8_t ucQueueType, StaticQueue_t* pxStaticQueue) __attribute__((weak));
#endif

QueueHandle_t xQueueCreateMutexStatic(const uint8_t ucQueueType, StaticQueue_t* pxStaticQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateMutexStatic);
  cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateMutexStatic_CallInstance);
  Mock.xQueueCreateMutexStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateMutexStatic_CallInstance);
  if (Mock.xQueueCreateMutexStatic_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCreateMutexStatic_FinalReturn;
    memcpy((void*)(&Mock.xQueueCreateMutexStatic_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCreateMutexStatic_CallbackBool &&
      Mock.xQueueCreateMutexStatic_CallbackFunctionPointer != NULL)
  {
    QueueHandle_t cmock_cb_ret = Mock.xQueueCreateMutexStatic_CallbackFunctionPointer(ucQueueType, pxStaticQueue, Mock.xQueueCreateMutexStatic_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ucQueueType)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateMutexStatic,CMockString_ucQueueType);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucQueueType, ucQueueType, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxStaticQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateMutexStatic,CMockString_pxStaticQueue);
    if (cmock_call_instance->Expected_pxStaticQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pxStaticQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxStaticQueue), (void*)(pxStaticQueue), sizeof(StaticQueue_t), cmock_call_instance->Expected_pxStaticQueue_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xQueueCreateMutexStatic_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCreateMutexStatic_CallbackFunctionPointer(ucQueueType, pxStaticQueue, Mock.xQueueCreateMutexStatic_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxStaticQueue, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxStaticQueue, (void*)cmock_call_instance->ReturnThruPtr_pxStaticQueue_Val,
      cmock_call_instance->ReturnThruPtr_pxStaticQueue_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateMutexStatic(CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance, const uint8_t ucQueueType, StaticQueue_t* pxStaticQueue, int pxStaticQueue_Depth)
{
  cmock_call_instance->Expected_ucQueueType = ucQueueType;
  cmock_call_instance->IgnoreArg_ucQueueType = 0;
  cmock_call_instance->Expected_pxStaticQueue = pxStaticQueue;
  cmock_call_instance->Expected_pxStaticQueue_Depth = pxStaticQueue_Depth;
  cmock_call_instance->IgnoreArg_pxStaticQueue = 0;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used = 0;
}

void xQueueCreateMutexStatic_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutexStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutexStatic_CallInstance, cmock_guts_index);
  Mock.xQueueCreateMutexStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCreateMutexStatic_IgnoreBool = (char)1;
}

void xQueueCreateMutexStatic_CMockStopIgnore(void)
{
  if(Mock.xQueueCreateMutexStatic_IgnoreBool)
    Mock.xQueueCreateMutexStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateMutexStatic_CallInstance);
  Mock.xQueueCreateMutexStatic_IgnoreBool = (char)0;
}

void xQueueCreateMutexStatic_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutexStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutexStatic_CallInstance, cmock_guts_index);
  Mock.xQueueCreateMutexStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCreateMutexStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const uint8_t ucQueueType, StaticQueue_t* pxStaticQueue, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutexStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutexStatic_CallInstance, cmock_guts_index);
  Mock.xQueueCreateMutexStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCreateMutexStatic(cmock_call_instance, ucQueueType, pxStaticQueue, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueCreateMutexStatic_AddCallback(CMOCK_xQueueCreateMutexStatic_CALLBACK Callback)
{
  Mock.xQueueCreateMutexStatic_IgnoreBool = (char)0;
  Mock.xQueueCreateMutexStatic_CallbackBool = (char)1;
  Mock.xQueueCreateMutexStatic_CallbackFunctionPointer = Callback;
}

void xQueueCreateMutexStatic_Stub(CMOCK_xQueueCreateMutexStatic_CALLBACK Callback)
{
  Mock.xQueueCreateMutexStatic_IgnoreBool = (char)0;
  Mock.xQueueCreateMutexStatic_CallbackBool = (char)0;
  Mock.xQueueCreateMutexStatic_CallbackFunctionPointer = Callback;
}

void xQueueCreateMutexStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const uint8_t ucQueueType, StaticQueue_t* pxStaticQueue, int pxStaticQueue_Depth, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateMutexStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateMutexStatic_CallInstance, cmock_guts_index);
  Mock.xQueueCreateMutexStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCreateMutexStatic(cmock_call_instance, ucQueueType, pxStaticQueue, pxStaticQueue_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueCreateMutexStatic_CMockReturnMemThruPtr_pxStaticQueue(UNITY_LINE_TYPE cmock_line, StaticQueue_t* pxStaticQueue, int cmock_size)
{
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateMutexStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Val = pxStaticQueue;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Size = cmock_size;
}

void xQueueCreateMutexStatic_CMockIgnoreArg_ucQueueType(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateMutexStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ucQueueType = 1;
}

void xQueueCreateMutexStatic_CMockIgnoreArg_pxStaticQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateMutexStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateMutexStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxStaticQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCreateCountingSemaphore
#else
QueueHandle_t xQueueCreateCountingSemaphore(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount) __attribute__((weak));
#endif

QueueHandle_t xQueueCreateCountingSemaphore(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateCountingSemaphore);
  cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateCountingSemaphore_CallInstance);
  Mock.xQueueCreateCountingSemaphore_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateCountingSemaphore_CallInstance);
  if (Mock.xQueueCreateCountingSemaphore_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCreateCountingSemaphore_FinalReturn;
    memcpy((void*)(&Mock.xQueueCreateCountingSemaphore_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCreateCountingSemaphore_CallbackBool &&
      Mock.xQueueCreateCountingSemaphore_CallbackFunctionPointer != NULL)
  {
    QueueHandle_t cmock_cb_ret = Mock.xQueueCreateCountingSemaphore_CallbackFunctionPointer(uxMaxCount, uxInitialCount, Mock.xQueueCreateCountingSemaphore_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uxMaxCount)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphore,CMockString_uxMaxCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxInitialCount)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphore,CMockString_uxInitialCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxInitialCount), (void*)(&uxInitialCount), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueCreateCountingSemaphore_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCreateCountingSemaphore_CallbackFunctionPointer(uxMaxCount, uxInitialCount, Mock.xQueueCreateCountingSemaphore_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateCountingSemaphore(CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount),
         sizeof(UBaseType_t[sizeof(uxMaxCount) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxMaxCount = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxInitialCount), (void*)(&uxInitialCount),
         sizeof(UBaseType_t[sizeof(uxInitialCount) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxInitialCount = 0;
}

void xQueueCreateCountingSemaphore_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphore_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphore_CallInstance, cmock_guts_index);
  Mock.xQueueCreateCountingSemaphore_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCreateCountingSemaphore_IgnoreBool = (char)1;
}

void xQueueCreateCountingSemaphore_CMockStopIgnore(void)
{
  if(Mock.xQueueCreateCountingSemaphore_IgnoreBool)
    Mock.xQueueCreateCountingSemaphore_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateCountingSemaphore_CallInstance);
  Mock.xQueueCreateCountingSemaphore_IgnoreBool = (char)0;
}

void xQueueCreateCountingSemaphore_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphore_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphore_CallInstance, cmock_guts_index);
  Mock.xQueueCreateCountingSemaphore_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCreateCountingSemaphore_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphore_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphore_CallInstance, cmock_guts_index);
  Mock.xQueueCreateCountingSemaphore_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCreateCountingSemaphore(cmock_call_instance, uxMaxCount, uxInitialCount);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueCreateCountingSemaphore_AddCallback(CMOCK_xQueueCreateCountingSemaphore_CALLBACK Callback)
{
  Mock.xQueueCreateCountingSemaphore_IgnoreBool = (char)0;
  Mock.xQueueCreateCountingSemaphore_CallbackBool = (char)1;
  Mock.xQueueCreateCountingSemaphore_CallbackFunctionPointer = Callback;
}

void xQueueCreateCountingSemaphore_Stub(CMOCK_xQueueCreateCountingSemaphore_CALLBACK Callback)
{
  Mock.xQueueCreateCountingSemaphore_IgnoreBool = (char)0;
  Mock.xQueueCreateCountingSemaphore_CallbackBool = (char)0;
  Mock.xQueueCreateCountingSemaphore_CallbackFunctionPointer = Callback;
}

void xQueueCreateCountingSemaphore_CMockIgnoreArg_uxMaxCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateCountingSemaphore_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxMaxCount = 1;
}

void xQueueCreateCountingSemaphore_CMockIgnoreArg_uxInitialCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphore_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateCountingSemaphore_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxInitialCount = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCreateCountingSemaphoreStatic
#else
QueueHandle_t xQueueCreateCountingSemaphoreStatic(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t* pxStaticQueue) __attribute__((weak));
#endif

QueueHandle_t xQueueCreateCountingSemaphoreStatic(const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t* pxStaticQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateCountingSemaphoreStatic);
  cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance);
  Mock.xQueueCreateCountingSemaphoreStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance);
  if (Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCreateCountingSemaphoreStatic_FinalReturn;
    memcpy((void*)(&Mock.xQueueCreateCountingSemaphoreStatic_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCreateCountingSemaphoreStatic_CallbackBool &&
      Mock.xQueueCreateCountingSemaphoreStatic_CallbackFunctionPointer != NULL)
  {
    QueueHandle_t cmock_cb_ret = Mock.xQueueCreateCountingSemaphoreStatic_CallbackFunctionPointer(uxMaxCount, uxInitialCount, pxStaticQueue, Mock.xQueueCreateCountingSemaphoreStatic_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uxMaxCount)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphoreStatic,CMockString_uxMaxCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxInitialCount)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphoreStatic,CMockString_uxInitialCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxInitialCount), (void*)(&uxInitialCount), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxStaticQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateCountingSemaphoreStatic,CMockString_pxStaticQueue);
    if (cmock_call_instance->Expected_pxStaticQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pxStaticQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxStaticQueue), (void*)(pxStaticQueue), sizeof(StaticQueue_t), cmock_call_instance->Expected_pxStaticQueue_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xQueueCreateCountingSemaphoreStatic_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCreateCountingSemaphoreStatic_CallbackFunctionPointer(uxMaxCount, uxInitialCount, pxStaticQueue, Mock.xQueueCreateCountingSemaphoreStatic_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxStaticQueue, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxStaticQueue, (void*)cmock_call_instance->ReturnThruPtr_pxStaticQueue_Val,
      cmock_call_instance->ReturnThruPtr_pxStaticQueue_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateCountingSemaphoreStatic(CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t* pxStaticQueue, int pxStaticQueue_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount),
         sizeof(UBaseType_t[sizeof(uxMaxCount) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxMaxCount = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxInitialCount), (void*)(&uxInitialCount),
         sizeof(UBaseType_t[sizeof(uxInitialCount) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxInitialCount = 0;
  cmock_call_instance->Expected_pxStaticQueue = pxStaticQueue;
  cmock_call_instance->Expected_pxStaticQueue_Depth = pxStaticQueue_Depth;
  cmock_call_instance->IgnoreArg_pxStaticQueue = 0;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used = 0;
}

void xQueueCreateCountingSemaphoreStatic_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphoreStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance, cmock_guts_index);
  Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool = (char)1;
}

void xQueueCreateCountingSemaphoreStatic_CMockStopIgnore(void)
{
  if(Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool)
    Mock.xQueueCreateCountingSemaphoreStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance);
  Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool = (char)0;
}

void xQueueCreateCountingSemaphoreStatic_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphoreStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance, cmock_guts_index);
  Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCreateCountingSemaphoreStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t* pxStaticQueue, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphoreStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance, cmock_guts_index);
  Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCreateCountingSemaphoreStatic(cmock_call_instance, uxMaxCount, uxInitialCount, pxStaticQueue, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueCreateCountingSemaphoreStatic_AddCallback(CMOCK_xQueueCreateCountingSemaphoreStatic_CALLBACK Callback)
{
  Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool = (char)0;
  Mock.xQueueCreateCountingSemaphoreStatic_CallbackBool = (char)1;
  Mock.xQueueCreateCountingSemaphoreStatic_CallbackFunctionPointer = Callback;
}

void xQueueCreateCountingSemaphoreStatic_Stub(CMOCK_xQueueCreateCountingSemaphoreStatic_CALLBACK Callback)
{
  Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool = (char)0;
  Mock.xQueueCreateCountingSemaphoreStatic_CallbackBool = (char)0;
  Mock.xQueueCreateCountingSemaphoreStatic_CallbackFunctionPointer = Callback;
}

void xQueueCreateCountingSemaphoreStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t* pxStaticQueue, int pxStaticQueue_Depth, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE));
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateCountingSemaphoreStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance, cmock_guts_index);
  Mock.xQueueCreateCountingSemaphoreStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCreateCountingSemaphoreStatic(cmock_call_instance, uxMaxCount, uxInitialCount, pxStaticQueue, pxStaticQueue_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueCreateCountingSemaphoreStatic_CMockReturnMemThruPtr_pxStaticQueue(UNITY_LINE_TYPE cmock_line, StaticQueue_t* pxStaticQueue, int cmock_size)
{
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Val = pxStaticQueue;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Size = cmock_size;
}

void xQueueCreateCountingSemaphoreStatic_CMockIgnoreArg_uxMaxCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxMaxCount = 1;
}

void xQueueCreateCountingSemaphoreStatic_CMockIgnoreArg_uxInitialCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxInitialCount = 1;
}

void xQueueCreateCountingSemaphoreStatic_CMockIgnoreArg_pxStaticQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateCountingSemaphoreStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateCountingSemaphoreStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxStaticQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueSemaphoreTake
#else
BaseType_t xQueueSemaphoreTake(QueueHandle_t xQueue, TickType_t xTicksToWait) __attribute__((weak));
#endif

BaseType_t xQueueSemaphoreTake(QueueHandle_t xQueue, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueSemaphoreTake);
  cmock_call_instance = (CMOCK_xQueueSemaphoreTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueSemaphoreTake_CallInstance);
  Mock.xQueueSemaphoreTake_CallInstance = CMock_Guts_MemNext(Mock.xQueueSemaphoreTake_CallInstance);
  if (Mock.xQueueSemaphoreTake_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueSemaphoreTake_FinalReturn;
    memcpy((void*)(&Mock.xQueueSemaphoreTake_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueSemaphoreTake_CallbackBool &&
      Mock.xQueueSemaphoreTake_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueSemaphoreTake_CallbackFunctionPointer(xQueue, xTicksToWait, Mock.xQueueSemaphoreTake_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueSemaphoreTake,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xQueueSemaphoreTake,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueSemaphoreTake_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueSemaphoreTake_CallbackFunctionPointer(xQueue, xTicksToWait, Mock.xQueueSemaphoreTake_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueSemaphoreTake(CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xQueueSemaphoreTake_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSemaphoreTake_CALL_INSTANCE));
  CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSemaphoreTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSemaphoreTake_CallInstance = CMock_Guts_MemChain(Mock.xQueueSemaphoreTake_CallInstance, cmock_guts_index);
  Mock.xQueueSemaphoreTake_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueSemaphoreTake_IgnoreBool = (char)1;
}

void xQueueSemaphoreTake_CMockStopIgnore(void)
{
  if(Mock.xQueueSemaphoreTake_IgnoreBool)
    Mock.xQueueSemaphoreTake_CallInstance = CMock_Guts_MemNext(Mock.xQueueSemaphoreTake_CallInstance);
  Mock.xQueueSemaphoreTake_IgnoreBool = (char)0;
}

void xQueueSemaphoreTake_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSemaphoreTake_CALL_INSTANCE));
  CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSemaphoreTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSemaphoreTake_CallInstance = CMock_Guts_MemChain(Mock.xQueueSemaphoreTake_CallInstance, cmock_guts_index);
  Mock.xQueueSemaphoreTake_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueSemaphoreTake_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSemaphoreTake_CALL_INSTANCE));
  CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSemaphoreTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSemaphoreTake_CallInstance = CMock_Guts_MemChain(Mock.xQueueSemaphoreTake_CallInstance, cmock_guts_index);
  Mock.xQueueSemaphoreTake_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueSemaphoreTake(cmock_call_instance, xQueue, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueSemaphoreTake_AddCallback(CMOCK_xQueueSemaphoreTake_CALLBACK Callback)
{
  Mock.xQueueSemaphoreTake_IgnoreBool = (char)0;
  Mock.xQueueSemaphoreTake_CallbackBool = (char)1;
  Mock.xQueueSemaphoreTake_CallbackFunctionPointer = Callback;
}

void xQueueSemaphoreTake_Stub(CMOCK_xQueueSemaphoreTake_CALLBACK Callback)
{
  Mock.xQueueSemaphoreTake_IgnoreBool = (char)0;
  Mock.xQueueSemaphoreTake_CallbackBool = (char)0;
  Mock.xQueueSemaphoreTake_CallbackFunctionPointer = Callback;
}

void xQueueSemaphoreTake_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSemaphoreTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueSemaphoreTake_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueSemaphoreTake_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueSemaphoreTake_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSemaphoreTake_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueSemaphoreTake_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGetMutexHolder
#else
TaskHandle_t xQueueGetMutexHolder(QueueHandle_t xSemaphore) __attribute__((weak));
#endif

TaskHandle_t xQueueGetMutexHolder(QueueHandle_t xSemaphore)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGetMutexHolder);
  cmock_call_instance = (CMOCK_xQueueGetMutexHolder_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGetMutexHolder_CallInstance);
  Mock.xQueueGetMutexHolder_CallInstance = CMock_Guts_MemNext(Mock.xQueueGetMutexHolder_CallInstance);
  if (Mock.xQueueGetMutexHolder_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGetMutexHolder_FinalReturn;
    memcpy((void*)(&Mock.xQueueGetMutexHolder_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TaskHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGetMutexHolder_CallbackBool &&
      Mock.xQueueGetMutexHolder_CallbackFunctionPointer != NULL)
  {
    TaskHandle_t cmock_cb_ret = Mock.xQueueGetMutexHolder_CallbackFunctionPointer(xSemaphore, Mock.xQueueGetMutexHolder_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xSemaphore)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGetMutexHolder,CMockString_xSemaphore);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xSemaphore), (void*)(&xSemaphore), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueGetMutexHolder_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGetMutexHolder_CallbackFunctionPointer(xSemaphore, Mock.xQueueGetMutexHolder_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGetMutexHolder(CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xSemaphore)
{
  memcpy((void*)(&cmock_call_instance->Expected_xSemaphore), (void*)(&xSemaphore),
         sizeof(QueueHandle_t[sizeof(xSemaphore) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xSemaphore = 0;
}

void xQueueGetMutexHolder_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGetMutexHolder_CALL_INSTANCE));
  CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolder_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGetMutexHolder_CallInstance = CMock_Guts_MemChain(Mock.xQueueGetMutexHolder_CallInstance, cmock_guts_index);
  Mock.xQueueGetMutexHolder_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGetMutexHolder_IgnoreBool = (char)1;
}

void xQueueGetMutexHolder_CMockStopIgnore(void)
{
  if(Mock.xQueueGetMutexHolder_IgnoreBool)
    Mock.xQueueGetMutexHolder_CallInstance = CMock_Guts_MemNext(Mock.xQueueGetMutexHolder_CallInstance);
  Mock.xQueueGetMutexHolder_IgnoreBool = (char)0;
}

void xQueueGetMutexHolder_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGetMutexHolder_CALL_INSTANCE));
  CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolder_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGetMutexHolder_CallInstance = CMock_Guts_MemChain(Mock.xQueueGetMutexHolder_CallInstance, cmock_guts_index);
  Mock.xQueueGetMutexHolder_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGetMutexHolder_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xSemaphore, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGetMutexHolder_CALL_INSTANCE));
  CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolder_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGetMutexHolder_CallInstance = CMock_Guts_MemChain(Mock.xQueueGetMutexHolder_CallInstance, cmock_guts_index);
  Mock.xQueueGetMutexHolder_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGetMutexHolder(cmock_call_instance, xSemaphore);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xQueueGetMutexHolder_AddCallback(CMOCK_xQueueGetMutexHolder_CALLBACK Callback)
{
  Mock.xQueueGetMutexHolder_IgnoreBool = (char)0;
  Mock.xQueueGetMutexHolder_CallbackBool = (char)1;
  Mock.xQueueGetMutexHolder_CallbackFunctionPointer = Callback;
}

void xQueueGetMutexHolder_Stub(CMOCK_xQueueGetMutexHolder_CALLBACK Callback)
{
  Mock.xQueueGetMutexHolder_IgnoreBool = (char)0;
  Mock.xQueueGetMutexHolder_CallbackBool = (char)0;
  Mock.xQueueGetMutexHolder_CallbackFunctionPointer = Callback;
}

void xQueueGetMutexHolder_CMockIgnoreArg_xSemaphore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGetMutexHolder_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolder_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGetMutexHolder_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xSemaphore = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGetMutexHolderFromISR
#else
TaskHandle_t xQueueGetMutexHolderFromISR(QueueHandle_t xSemaphore) __attribute__((weak));
#endif

TaskHandle_t xQueueGetMutexHolderFromISR(QueueHandle_t xSemaphore)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGetMutexHolderFromISR);
  cmock_call_instance = (CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGetMutexHolderFromISR_CallInstance);
  Mock.xQueueGetMutexHolderFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGetMutexHolderFromISR_CallInstance);
  if (Mock.xQueueGetMutexHolderFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGetMutexHolderFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueGetMutexHolderFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TaskHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGetMutexHolderFromISR_CallbackBool &&
      Mock.xQueueGetMutexHolderFromISR_CallbackFunctionPointer != NULL)
  {
    TaskHandle_t cmock_cb_ret = Mock.xQueueGetMutexHolderFromISR_CallbackFunctionPointer(xSemaphore, Mock.xQueueGetMutexHolderFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xSemaphore)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGetMutexHolderFromISR,CMockString_xSemaphore);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xSemaphore), (void*)(&xSemaphore), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueGetMutexHolderFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGetMutexHolderFromISR_CallbackFunctionPointer(xSemaphore, Mock.xQueueGetMutexHolderFromISR_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGetMutexHolderFromISR(CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xSemaphore)
{
  memcpy((void*)(&cmock_call_instance->Expected_xSemaphore), (void*)(&xSemaphore),
         sizeof(QueueHandle_t[sizeof(xSemaphore) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xSemaphore = 0;
}

void xQueueGetMutexHolderFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE));
  CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGetMutexHolderFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGetMutexHolderFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGetMutexHolderFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGetMutexHolderFromISR_IgnoreBool = (char)1;
}

void xQueueGetMutexHolderFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueGetMutexHolderFromISR_IgnoreBool)
    Mock.xQueueGetMutexHolderFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueGetMutexHolderFromISR_CallInstance);
  Mock.xQueueGetMutexHolderFromISR_IgnoreBool = (char)0;
}

void xQueueGetMutexHolderFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE));
  CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGetMutexHolderFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGetMutexHolderFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGetMutexHolderFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGetMutexHolderFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xSemaphore, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE));
  CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGetMutexHolderFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueGetMutexHolderFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueGetMutexHolderFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGetMutexHolderFromISR(cmock_call_instance, xSemaphore);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xQueueGetMutexHolderFromISR_AddCallback(CMOCK_xQueueGetMutexHolderFromISR_CALLBACK Callback)
{
  Mock.xQueueGetMutexHolderFromISR_IgnoreBool = (char)0;
  Mock.xQueueGetMutexHolderFromISR_CallbackBool = (char)1;
  Mock.xQueueGetMutexHolderFromISR_CallbackFunctionPointer = Callback;
}

void xQueueGetMutexHolderFromISR_Stub(CMOCK_xQueueGetMutexHolderFromISR_CALLBACK Callback)
{
  Mock.xQueueGetMutexHolderFromISR_IgnoreBool = (char)0;
  Mock.xQueueGetMutexHolderFromISR_CallbackBool = (char)0;
  Mock.xQueueGetMutexHolderFromISR_CallbackFunctionPointer = Callback;
}

void xQueueGetMutexHolderFromISR_CMockIgnoreArg_xSemaphore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGetMutexHolderFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGetMutexHolderFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xSemaphore = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueTakeMutexRecursive
#else
BaseType_t xQueueTakeMutexRecursive(QueueHandle_t xMutex, TickType_t xTicksToWait) __attribute__((weak));
#endif

BaseType_t xQueueTakeMutexRecursive(QueueHandle_t xMutex, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueTakeMutexRecursive);
  cmock_call_instance = (CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueTakeMutexRecursive_CallInstance);
  Mock.xQueueTakeMutexRecursive_CallInstance = CMock_Guts_MemNext(Mock.xQueueTakeMutexRecursive_CallInstance);
  if (Mock.xQueueTakeMutexRecursive_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueTakeMutexRecursive_FinalReturn;
    memcpy((void*)(&Mock.xQueueTakeMutexRecursive_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueTakeMutexRecursive_CallbackBool &&
      Mock.xQueueTakeMutexRecursive_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueTakeMutexRecursive_CallbackFunctionPointer(xMutex, xTicksToWait, Mock.xQueueTakeMutexRecursive_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xMutex)
  {
    UNITY_SET_DETAILS(CMockString_xQueueTakeMutexRecursive,CMockString_xMutex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xMutex), (void*)(&xMutex), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xQueueTakeMutexRecursive,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueTakeMutexRecursive_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueTakeMutexRecursive_CallbackFunctionPointer(xMutex, xTicksToWait, Mock.xQueueTakeMutexRecursive_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueTakeMutexRecursive(CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xMutex, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xMutex), (void*)(&xMutex),
         sizeof(QueueHandle_t[sizeof(xMutex) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xMutex = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xQueueTakeMutexRecursive_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE));
  CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueTakeMutexRecursive_CallInstance = CMock_Guts_MemChain(Mock.xQueueTakeMutexRecursive_CallInstance, cmock_guts_index);
  Mock.xQueueTakeMutexRecursive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueTakeMutexRecursive_IgnoreBool = (char)1;
}

void xQueueTakeMutexRecursive_CMockStopIgnore(void)
{
  if(Mock.xQueueTakeMutexRecursive_IgnoreBool)
    Mock.xQueueTakeMutexRecursive_CallInstance = CMock_Guts_MemNext(Mock.xQueueTakeMutexRecursive_CallInstance);
  Mock.xQueueTakeMutexRecursive_IgnoreBool = (char)0;
}

void xQueueTakeMutexRecursive_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE));
  CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueTakeMutexRecursive_CallInstance = CMock_Guts_MemChain(Mock.xQueueTakeMutexRecursive_CallInstance, cmock_guts_index);
  Mock.xQueueTakeMutexRecursive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueTakeMutexRecursive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xMutex, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE));
  CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueTakeMutexRecursive_CallInstance = CMock_Guts_MemChain(Mock.xQueueTakeMutexRecursive_CallInstance, cmock_guts_index);
  Mock.xQueueTakeMutexRecursive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueTakeMutexRecursive(cmock_call_instance, xMutex, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueTakeMutexRecursive_AddCallback(CMOCK_xQueueTakeMutexRecursive_CALLBACK Callback)
{
  Mock.xQueueTakeMutexRecursive_IgnoreBool = (char)0;
  Mock.xQueueTakeMutexRecursive_CallbackBool = (char)1;
  Mock.xQueueTakeMutexRecursive_CallbackFunctionPointer = Callback;
}

void xQueueTakeMutexRecursive_Stub(CMOCK_xQueueTakeMutexRecursive_CALLBACK Callback)
{
  Mock.xQueueTakeMutexRecursive_IgnoreBool = (char)0;
  Mock.xQueueTakeMutexRecursive_CallbackBool = (char)0;
  Mock.xQueueTakeMutexRecursive_CallbackFunctionPointer = Callback;
}

void xQueueTakeMutexRecursive_CMockIgnoreArg_xMutex(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueTakeMutexRecursive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xMutex = 1;
}

void xQueueTakeMutexRecursive_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueTakeMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueTakeMutexRecursive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGiveMutexRecursive
#else
BaseType_t xQueueGiveMutexRecursive(QueueHandle_t xMutex) __attribute__((weak));
#endif

BaseType_t xQueueGiveMutexRecursive(QueueHandle_t xMutex)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGiveMutexRecursive);
  cmock_call_instance = (CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGiveMutexRecursive_CallInstance);
  Mock.xQueueGiveMutexRecursive_CallInstance = CMock_Guts_MemNext(Mock.xQueueGiveMutexRecursive_CallInstance);
  if (Mock.xQueueGiveMutexRecursive_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGiveMutexRecursive_FinalReturn;
    memcpy((void*)(&Mock.xQueueGiveMutexRecursive_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGiveMutexRecursive_CallbackBool &&
      Mock.xQueueGiveMutexRecursive_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueGiveMutexRecursive_CallbackFunctionPointer(xMutex, Mock.xQueueGiveMutexRecursive_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xMutex)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGiveMutexRecursive,CMockString_xMutex);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xMutex), (void*)(&xMutex), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueGiveMutexRecursive_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGiveMutexRecursive_CallbackFunctionPointer(xMutex, Mock.xQueueGiveMutexRecursive_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGiveMutexRecursive(CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xMutex)
{
  memcpy((void*)(&cmock_call_instance->Expected_xMutex), (void*)(&xMutex),
         sizeof(QueueHandle_t[sizeof(xMutex) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xMutex = 0;
}

void xQueueGiveMutexRecursive_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE));
  CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveMutexRecursive_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveMutexRecursive_CallInstance, cmock_guts_index);
  Mock.xQueueGiveMutexRecursive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGiveMutexRecursive_IgnoreBool = (char)1;
}

void xQueueGiveMutexRecursive_CMockStopIgnore(void)
{
  if(Mock.xQueueGiveMutexRecursive_IgnoreBool)
    Mock.xQueueGiveMutexRecursive_CallInstance = CMock_Guts_MemNext(Mock.xQueueGiveMutexRecursive_CallInstance);
  Mock.xQueueGiveMutexRecursive_IgnoreBool = (char)0;
}

void xQueueGiveMutexRecursive_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE));
  CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveMutexRecursive_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveMutexRecursive_CallInstance, cmock_guts_index);
  Mock.xQueueGiveMutexRecursive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGiveMutexRecursive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xMutex, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE));
  CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGiveMutexRecursive_CallInstance = CMock_Guts_MemChain(Mock.xQueueGiveMutexRecursive_CallInstance, cmock_guts_index);
  Mock.xQueueGiveMutexRecursive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGiveMutexRecursive(cmock_call_instance, xMutex);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueGiveMutexRecursive_AddCallback(CMOCK_xQueueGiveMutexRecursive_CALLBACK Callback)
{
  Mock.xQueueGiveMutexRecursive_IgnoreBool = (char)0;
  Mock.xQueueGiveMutexRecursive_CallbackBool = (char)1;
  Mock.xQueueGiveMutexRecursive_CallbackFunctionPointer = Callback;
}

void xQueueGiveMutexRecursive_Stub(CMOCK_xQueueGiveMutexRecursive_CALLBACK Callback)
{
  Mock.xQueueGiveMutexRecursive_IgnoreBool = (char)0;
  Mock.xQueueGiveMutexRecursive_CallbackBool = (char)0;
  Mock.xQueueGiveMutexRecursive_CallbackFunctionPointer = Callback;
}

void xQueueGiveMutexRecursive_CMockIgnoreArg_xMutex(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGiveMutexRecursive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGiveMutexRecursive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xMutex = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vQueueAddToRegistry
#else
void vQueueAddToRegistry(QueueHandle_t xQueue, const char* pcQueueName) __attribute__((weak));
#endif

void vQueueAddToRegistry(QueueHandle_t xQueue, const char* pcQueueName)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueAddToRegistry);
  cmock_call_instance = (CMOCK_vQueueAddToRegistry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueAddToRegistry_CallInstance);
  Mock.vQueueAddToRegistry_CallInstance = CMock_Guts_MemNext(Mock.vQueueAddToRegistry_CallInstance);
  if (Mock.vQueueAddToRegistry_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vQueueAddToRegistry_CallbackBool &&
      Mock.vQueueAddToRegistry_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueAddToRegistry_CallbackFunctionPointer(xQueue, pcQueueName, Mock.vQueueAddToRegistry_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_vQueueAddToRegistry,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pcQueueName)
  {
    UNITY_SET_DETAILS(CMockString_vQueueAddToRegistry,CMockString_pcQueueName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcQueueName, pcQueueName, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vQueueAddToRegistry_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueAddToRegistry_CallbackFunctionPointer(xQueue, pcQueueName, Mock.vQueueAddToRegistry_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueAddToRegistry(CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const char* pcQueueName)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  cmock_call_instance->Expected_pcQueueName = pcQueueName;
  cmock_call_instance->IgnoreArg_pcQueueName = 0;
}

void vQueueAddToRegistry_CMockIgnore(void)
{
  Mock.vQueueAddToRegistry_IgnoreBool = (char)1;
}

void vQueueAddToRegistry_CMockStopIgnore(void)
{
  Mock.vQueueAddToRegistry_IgnoreBool = (char)0;
}

void vQueueAddToRegistry_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueAddToRegistry_CALL_INSTANCE));
  CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueAddToRegistry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueAddToRegistry_CallInstance = CMock_Guts_MemChain(Mock.vQueueAddToRegistry_CallInstance, cmock_guts_index);
  Mock.vQueueAddToRegistry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vQueueAddToRegistry_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const char* pcQueueName)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueAddToRegistry_CALL_INSTANCE));
  CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueAddToRegistry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueAddToRegistry_CallInstance = CMock_Guts_MemChain(Mock.vQueueAddToRegistry_CallInstance, cmock_guts_index);
  Mock.vQueueAddToRegistry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vQueueAddToRegistry(cmock_call_instance, xQueue, pcQueueName);
}

void vQueueAddToRegistry_AddCallback(CMOCK_vQueueAddToRegistry_CALLBACK Callback)
{
  Mock.vQueueAddToRegistry_IgnoreBool = (char)0;
  Mock.vQueueAddToRegistry_CallbackBool = (char)1;
  Mock.vQueueAddToRegistry_CallbackFunctionPointer = Callback;
}

void vQueueAddToRegistry_Stub(CMOCK_vQueueAddToRegistry_CALLBACK Callback)
{
  Mock.vQueueAddToRegistry_IgnoreBool = (char)0;
  Mock.vQueueAddToRegistry_CallbackBool = (char)0;
  Mock.vQueueAddToRegistry_CallbackFunctionPointer = Callback;
}

void vQueueAddToRegistry_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueAddToRegistry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueAddToRegistry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void vQueueAddToRegistry_CMockIgnoreArg_pcQueueName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueAddToRegistry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueAddToRegistry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueAddToRegistry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcQueueName = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vQueueUnregisterQueue
#else
void vQueueUnregisterQueue(QueueHandle_t xQueue) __attribute__((weak));
#endif

void vQueueUnregisterQueue(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueUnregisterQueue_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueUnregisterQueue);
  cmock_call_instance = (CMOCK_vQueueUnregisterQueue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueUnregisterQueue_CallInstance);
  Mock.vQueueUnregisterQueue_CallInstance = CMock_Guts_MemNext(Mock.vQueueUnregisterQueue_CallInstance);
  if (Mock.vQueueUnregisterQueue_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vQueueUnregisterQueue_CallbackBool &&
      Mock.vQueueUnregisterQueue_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueUnregisterQueue_CallbackFunctionPointer(xQueue, Mock.vQueueUnregisterQueue_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_vQueueUnregisterQueue,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vQueueUnregisterQueue_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueUnregisterQueue_CallbackFunctionPointer(xQueue, Mock.vQueueUnregisterQueue_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueUnregisterQueue(CMOCK_vQueueUnregisterQueue_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void vQueueUnregisterQueue_CMockIgnore(void)
{
  Mock.vQueueUnregisterQueue_IgnoreBool = (char)1;
}

void vQueueUnregisterQueue_CMockStopIgnore(void)
{
  Mock.vQueueUnregisterQueue_IgnoreBool = (char)0;
}

void vQueueUnregisterQueue_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueUnregisterQueue_CALL_INSTANCE));
  CMOCK_vQueueUnregisterQueue_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueUnregisterQueue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueUnregisterQueue_CallInstance = CMock_Guts_MemChain(Mock.vQueueUnregisterQueue_CallInstance, cmock_guts_index);
  Mock.vQueueUnregisterQueue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vQueueUnregisterQueue_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueUnregisterQueue_CALL_INSTANCE));
  CMOCK_vQueueUnregisterQueue_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueUnregisterQueue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueUnregisterQueue_CallInstance = CMock_Guts_MemChain(Mock.vQueueUnregisterQueue_CallInstance, cmock_guts_index);
  Mock.vQueueUnregisterQueue_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vQueueUnregisterQueue(cmock_call_instance, xQueue);
}

void vQueueUnregisterQueue_AddCallback(CMOCK_vQueueUnregisterQueue_CALLBACK Callback)
{
  Mock.vQueueUnregisterQueue_IgnoreBool = (char)0;
  Mock.vQueueUnregisterQueue_CallbackBool = (char)1;
  Mock.vQueueUnregisterQueue_CallbackFunctionPointer = Callback;
}

void vQueueUnregisterQueue_Stub(CMOCK_vQueueUnregisterQueue_CALLBACK Callback)
{
  Mock.vQueueUnregisterQueue_IgnoreBool = (char)0;
  Mock.vQueueUnregisterQueue_CallbackBool = (char)0;
  Mock.vQueueUnregisterQueue_CallbackFunctionPointer = Callback;
}

void vQueueUnregisterQueue_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueUnregisterQueue_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueUnregisterQueue_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueUnregisterQueue_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak pcQueueGetName
#else
const char* pcQueueGetName(QueueHandle_t xQueue) __attribute__((weak));
#endif

const char* pcQueueGetName(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pcQueueGetName);
  cmock_call_instance = (CMOCK_pcQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pcQueueGetName_CallInstance);
  Mock.pcQueueGetName_CallInstance = CMock_Guts_MemNext(Mock.pcQueueGetName_CallInstance);
  if (Mock.pcQueueGetName_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pcQueueGetName_FinalReturn;
    Mock.pcQueueGetName_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.pcQueueGetName_CallbackBool &&
      Mock.pcQueueGetName_CallbackFunctionPointer != NULL)
  {
    const char* cmock_cb_ret = Mock.pcQueueGetName_CallbackFunctionPointer(xQueue, Mock.pcQueueGetName_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_pcQueueGetName,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.pcQueueGetName_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.pcQueueGetName_CallbackFunctionPointer(xQueue, Mock.pcQueueGetName_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pcQueueGetName(CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void pcQueueGetName_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcQueueGetName_CALL_INSTANCE));
  CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcQueueGetName_CallInstance = CMock_Guts_MemChain(Mock.pcQueueGetName_CallInstance, cmock_guts_index);
  Mock.pcQueueGetName_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pcQueueGetName_IgnoreBool = (char)1;
}

void pcQueueGetName_CMockStopIgnore(void)
{
  if(Mock.pcQueueGetName_IgnoreBool)
    Mock.pcQueueGetName_CallInstance = CMock_Guts_MemNext(Mock.pcQueueGetName_CallInstance);
  Mock.pcQueueGetName_IgnoreBool = (char)0;
}

void pcQueueGetName_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcQueueGetName_CALL_INSTANCE));
  CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcQueueGetName_CallInstance = CMock_Guts_MemChain(Mock.pcQueueGetName_CallInstance, cmock_guts_index);
  Mock.pcQueueGetName_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void pcQueueGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcQueueGetName_CALL_INSTANCE));
  CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcQueueGetName_CallInstance = CMock_Guts_MemChain(Mock.pcQueueGetName_CallInstance, cmock_guts_index);
  Mock.pcQueueGetName_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_pcQueueGetName(cmock_call_instance, xQueue);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pcQueueGetName_AddCallback(CMOCK_pcQueueGetName_CALLBACK Callback)
{
  Mock.pcQueueGetName_IgnoreBool = (char)0;
  Mock.pcQueueGetName_CallbackBool = (char)1;
  Mock.pcQueueGetName_CallbackFunctionPointer = Callback;
}

void pcQueueGetName_Stub(CMOCK_pcQueueGetName_CALLBACK Callback)
{
  Mock.pcQueueGetName_IgnoreBool = (char)0;
  Mock.pcQueueGetName_CallbackBool = (char)0;
  Mock.pcQueueGetName_CallbackFunctionPointer = Callback;
}

void pcQueueGetName_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_pcQueueGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcQueueGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.pcQueueGetName_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGenericCreate
#else
QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType) __attribute__((weak));
#endif

QueueHandle_t xQueueGenericCreate(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericCreate);
  cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericCreate_CallInstance);
  Mock.xQueueGenericCreate_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericCreate_CallInstance);
  if (Mock.xQueueGenericCreate_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGenericCreate_FinalReturn;
    memcpy((void*)(&Mock.xQueueGenericCreate_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGenericCreate_CallbackBool &&
      Mock.xQueueGenericCreate_CallbackFunctionPointer != NULL)
  {
    QueueHandle_t cmock_cb_ret = Mock.xQueueGenericCreate_CallbackFunctionPointer(uxQueueLength, uxItemSize, ucQueueType, Mock.xQueueGenericCreate_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uxQueueLength)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreate,CMockString_uxQueueLength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxQueueLength), (void*)(&uxQueueLength), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxItemSize)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreate,CMockString_uxItemSize);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxItemSize), (void*)(&uxItemSize), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ucQueueType)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreate,CMockString_ucQueueType);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucQueueType, ucQueueType, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueGenericCreate_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGenericCreate_CallbackFunctionPointer(uxQueueLength, uxItemSize, ucQueueType, Mock.xQueueGenericCreate_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericCreate(CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxQueueLength), (void*)(&uxQueueLength),
         sizeof(UBaseType_t[sizeof(uxQueueLength) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxQueueLength = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxItemSize), (void*)(&uxItemSize),
         sizeof(UBaseType_t[sizeof(uxItemSize) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxItemSize = 0;
  cmock_call_instance->Expected_ucQueueType = ucQueueType;
  cmock_call_instance->IgnoreArg_ucQueueType = 0;
}

void xQueueGenericCreate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreate_CALL_INSTANCE));
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreate_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreate_CallInstance, cmock_guts_index);
  Mock.xQueueGenericCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGenericCreate_IgnoreBool = (char)1;
}

void xQueueGenericCreate_CMockStopIgnore(void)
{
  if(Mock.xQueueGenericCreate_IgnoreBool)
    Mock.xQueueGenericCreate_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericCreate_CallInstance);
  Mock.xQueueGenericCreate_IgnoreBool = (char)0;
}

void xQueueGenericCreate_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreate_CALL_INSTANCE));
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreate_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreate_CallInstance, cmock_guts_index);
  Mock.xQueueGenericCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGenericCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreate_CALL_INSTANCE));
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreate_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreate_CallInstance, cmock_guts_index);
  Mock.xQueueGenericCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGenericCreate(cmock_call_instance, uxQueueLength, uxItemSize, ucQueueType);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueGenericCreate_AddCallback(CMOCK_xQueueGenericCreate_CALLBACK Callback)
{
  Mock.xQueueGenericCreate_IgnoreBool = (char)0;
  Mock.xQueueGenericCreate_CallbackBool = (char)1;
  Mock.xQueueGenericCreate_CallbackFunctionPointer = Callback;
}

void xQueueGenericCreate_Stub(CMOCK_xQueueGenericCreate_CALLBACK Callback)
{
  Mock.xQueueGenericCreate_IgnoreBool = (char)0;
  Mock.xQueueGenericCreate_CallbackBool = (char)0;
  Mock.xQueueGenericCreate_CallbackFunctionPointer = Callback;
}

void xQueueGenericCreate_CMockIgnoreArg_uxQueueLength(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxQueueLength = 1;
}

void xQueueGenericCreate_CMockIgnoreArg_uxItemSize(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxItemSize = 1;
}

void xQueueGenericCreate_CMockIgnoreArg_ucQueueType(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ucQueueType = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGenericCreateStatic
#else
QueueHandle_t xQueueGenericCreateStatic(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t* pucQueueStorage, StaticQueue_t* pxStaticQueue, const uint8_t ucQueueType) __attribute__((weak));
#endif

QueueHandle_t xQueueGenericCreateStatic(const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t* pucQueueStorage, StaticQueue_t* pxStaticQueue, const uint8_t ucQueueType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericCreateStatic);
  cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericCreateStatic_CallInstance);
  Mock.xQueueGenericCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericCreateStatic_CallInstance);
  if (Mock.xQueueGenericCreateStatic_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGenericCreateStatic_FinalReturn;
    memcpy((void*)(&Mock.xQueueGenericCreateStatic_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGenericCreateStatic_CallbackBool &&
      Mock.xQueueGenericCreateStatic_CallbackFunctionPointer != NULL)
  {
    QueueHandle_t cmock_cb_ret = Mock.xQueueGenericCreateStatic_CallbackFunctionPointer(uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType, Mock.xQueueGenericCreateStatic_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uxQueueLength)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_uxQueueLength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxQueueLength), (void*)(&uxQueueLength), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxItemSize)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_uxItemSize);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxItemSize), (void*)(&uxItemSize), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pucQueueStorage)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_pucQueueStorage);
    if (cmock_call_instance->Expected_pucQueueStorage == NULL)
      { UNITY_TEST_ASSERT_NULL(pucQueueStorage, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pucQueueStorage, pucQueueStorage, cmock_call_instance->Expected_pucQueueStorage_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxStaticQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_pxStaticQueue);
    if (cmock_call_instance->Expected_pxStaticQueue == NULL)
      { UNITY_TEST_ASSERT_NULL(pxStaticQueue, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxStaticQueue), (void*)(pxStaticQueue), sizeof(StaticQueue_t), cmock_call_instance->Expected_pxStaticQueue_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ucQueueType)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericCreateStatic,CMockString_ucQueueType);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ucQueueType, ucQueueType, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueGenericCreateStatic_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGenericCreateStatic_CallbackFunctionPointer(uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType, Mock.xQueueGenericCreateStatic_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pucQueueStorage_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pucQueueStorage, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pucQueueStorage, (void*)cmock_call_instance->ReturnThruPtr_pucQueueStorage_Val,
      cmock_call_instance->ReturnThruPtr_pucQueueStorage_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxStaticQueue, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxStaticQueue, (void*)cmock_call_instance->ReturnThruPtr_pxStaticQueue_Val,
      cmock_call_instance->ReturnThruPtr_pxStaticQueue_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericCreateStatic(CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t* pucQueueStorage, int pucQueueStorage_Depth, StaticQueue_t* pxStaticQueue, int pxStaticQueue_Depth, const uint8_t ucQueueType)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxQueueLength), (void*)(&uxQueueLength),
         sizeof(UBaseType_t[sizeof(uxQueueLength) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxQueueLength = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxItemSize), (void*)(&uxItemSize),
         sizeof(UBaseType_t[sizeof(uxItemSize) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxItemSize = 0;
  cmock_call_instance->Expected_pucQueueStorage = pucQueueStorage;
  cmock_call_instance->Expected_pucQueueStorage_Depth = pucQueueStorage_Depth;
  cmock_call_instance->IgnoreArg_pucQueueStorage = 0;
  cmock_call_instance->ReturnThruPtr_pucQueueStorage_Used = 0;
  cmock_call_instance->Expected_pxStaticQueue = pxStaticQueue;
  cmock_call_instance->Expected_pxStaticQueue_Depth = pxStaticQueue_Depth;
  cmock_call_instance->IgnoreArg_pxStaticQueue = 0;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used = 0;
  cmock_call_instance->Expected_ucQueueType = ucQueueType;
  cmock_call_instance->IgnoreArg_ucQueueType = 0;
}

void xQueueGenericCreateStatic_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreateStatic_CallInstance, cmock_guts_index);
  Mock.xQueueGenericCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGenericCreateStatic_IgnoreBool = (char)1;
}

void xQueueGenericCreateStatic_CMockStopIgnore(void)
{
  if(Mock.xQueueGenericCreateStatic_IgnoreBool)
    Mock.xQueueGenericCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericCreateStatic_CallInstance);
  Mock.xQueueGenericCreateStatic_IgnoreBool = (char)0;
}

void xQueueGenericCreateStatic_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreateStatic_CallInstance, cmock_guts_index);
  Mock.xQueueGenericCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGenericCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t* pucQueueStorage, StaticQueue_t* pxStaticQueue, const uint8_t ucQueueType, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreateStatic_CallInstance, cmock_guts_index);
  Mock.xQueueGenericCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGenericCreateStatic(cmock_call_instance, uxQueueLength, uxItemSize, pucQueueStorage, 1, pxStaticQueue, 1, ucQueueType);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueHandle_t[sizeof(cmock_to_return) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
}

void xQueueGenericCreateStatic_AddCallback(CMOCK_xQueueGenericCreateStatic_CALLBACK Callback)
{
  Mock.xQueueGenericCreateStatic_IgnoreBool = (char)0;
  Mock.xQueueGenericCreateStatic_CallbackBool = (char)1;
  Mock.xQueueGenericCreateStatic_CallbackFunctionPointer = Callback;
}

void xQueueGenericCreateStatic_Stub(CMOCK_xQueueGenericCreateStatic_CALLBACK Callback)
{
  Mock.xQueueGenericCreateStatic_IgnoreBool = (char)0;
  Mock.xQueueGenericCreateStatic_CallbackBool = (char)0;
  Mock.xQueueGenericCreateStatic_CallbackFunctionPointer = Callback;
}

void xQueueGenericCreateStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t* pucQueueStorage, int pucQueueStorage_Depth, StaticQueue_t* pxStaticQueue, int pxStaticQueue_Depth, const uint8_t ucQueueType, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE));
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericCreateStatic_CallInstance, cmock_guts_index);
  Mock.xQueueGenericCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGenericCreateStatic(cmock_call_instance, uxQueueLength, uxItemSize, pucQueueStorage, pucQueueStorage_Depth, pxStaticQueue, pxStaticQueue_Depth, ucQueueType);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xQueueGenericCreateStatic_CMockReturnMemThruPtr_pucQueueStorage(UNITY_LINE_TYPE cmock_line, uint8_t* pucQueueStorage, int cmock_size)
{
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pucQueueStorage_Used = 1;
  cmock_call_instance->ReturnThruPtr_pucQueueStorage_Val = pucQueueStorage;
  cmock_call_instance->ReturnThruPtr_pucQueueStorage_Size = cmock_size;
}

void xQueueGenericCreateStatic_CMockReturnMemThruPtr_pxStaticQueue(UNITY_LINE_TYPE cmock_line, StaticQueue_t* pxStaticQueue, int cmock_size)
{
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Val = pxStaticQueue;
  cmock_call_instance->ReturnThruPtr_pxStaticQueue_Size = cmock_size;
}

void xQueueGenericCreateStatic_CMockIgnoreArg_uxQueueLength(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxQueueLength = 1;
}

void xQueueGenericCreateStatic_CMockIgnoreArg_uxItemSize(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxItemSize = 1;
}

void xQueueGenericCreateStatic_CMockIgnoreArg_pucQueueStorage(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pucQueueStorage = 1;
}

void xQueueGenericCreateStatic_CMockIgnoreArg_pxStaticQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxStaticQueue = 1;
}

void xQueueGenericCreateStatic_CMockIgnoreArg_ucQueueType(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ucQueueType = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueCreateSet
#else
QueueSetHandle_t xQueueCreateSet(const UBaseType_t uxEventQueueLength) __attribute__((weak));
#endif

QueueSetHandle_t xQueueCreateSet(const UBaseType_t uxEventQueueLength)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueCreateSet);
  cmock_call_instance = (CMOCK_xQueueCreateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreateSet_CallInstance);
  Mock.xQueueCreateSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateSet_CallInstance);
  if (Mock.xQueueCreateSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueCreateSet_FinalReturn;
    memcpy((void*)(&Mock.xQueueCreateSet_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueSetHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueCreateSet_CallbackBool &&
      Mock.xQueueCreateSet_CallbackFunctionPointer != NULL)
  {
    QueueSetHandle_t cmock_cb_ret = Mock.xQueueCreateSet_CallbackFunctionPointer(uxEventQueueLength, Mock.xQueueCreateSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_uxEventQueueLength)
  {
    UNITY_SET_DETAILS(CMockString_xQueueCreateSet,CMockString_uxEventQueueLength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxEventQueueLength), (void*)(&uxEventQueueLength), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueCreateSet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueCreateSet_CallbackFunctionPointer(uxEventQueueLength, Mock.xQueueCreateSet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreateSet(CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance, const UBaseType_t uxEventQueueLength)
{
  memcpy((void*)(&cmock_call_instance->Expected_uxEventQueueLength), (void*)(&uxEventQueueLength),
         sizeof(UBaseType_t[sizeof(uxEventQueueLength) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxEventQueueLength = 0;
}

void xQueueCreateSet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateSet_CALL_INSTANCE));
  CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateSet_CallInstance, cmock_guts_index);
  Mock.xQueueCreateSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCreateSet_IgnoreBool = (char)1;
}

void xQueueCreateSet_CMockStopIgnore(void)
{
  if(Mock.xQueueCreateSet_IgnoreBool)
    Mock.xQueueCreateSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreateSet_CallInstance);
  Mock.xQueueCreateSet_IgnoreBool = (char)0;
}

void xQueueCreateSet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateSet_CALL_INSTANCE));
  CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateSet_CallInstance, cmock_guts_index);
  Mock.xQueueCreateSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueCreateSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const UBaseType_t uxEventQueueLength, QueueSetHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreateSet_CALL_INSTANCE));
  CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreateSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreateSet_CallInstance, cmock_guts_index);
  Mock.xQueueCreateSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueCreateSet(cmock_call_instance, uxEventQueueLength);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueSetHandle_t[sizeof(cmock_to_return) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
}

void xQueueCreateSet_AddCallback(CMOCK_xQueueCreateSet_CALLBACK Callback)
{
  Mock.xQueueCreateSet_IgnoreBool = (char)0;
  Mock.xQueueCreateSet_CallbackBool = (char)1;
  Mock.xQueueCreateSet_CallbackFunctionPointer = Callback;
}

void xQueueCreateSet_Stub(CMOCK_xQueueCreateSet_CALLBACK Callback)
{
  Mock.xQueueCreateSet_IgnoreBool = (char)0;
  Mock.xQueueCreateSet_CallbackBool = (char)0;
  Mock.xQueueCreateSet_CallbackFunctionPointer = Callback;
}

void xQueueCreateSet_CMockIgnoreArg_uxEventQueueLength(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueCreateSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreateSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueCreateSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxEventQueueLength = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueAddToSet
#else
BaseType_t xQueueAddToSet(QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet) __attribute__((weak));
#endif

BaseType_t xQueueAddToSet(QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueAddToSet);
  cmock_call_instance = (CMOCK_xQueueAddToSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueAddToSet_CallInstance);
  Mock.xQueueAddToSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueAddToSet_CallInstance);
  if (Mock.xQueueAddToSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueAddToSet_FinalReturn;
    memcpy((void*)(&Mock.xQueueAddToSet_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueAddToSet_CallbackBool &&
      Mock.xQueueAddToSet_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueAddToSet_CallbackFunctionPointer(xQueueOrSemaphore, xQueueSet, Mock.xQueueAddToSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueueOrSemaphore)
  {
    UNITY_SET_DETAILS(CMockString_xQueueAddToSet,CMockString_xQueueOrSemaphore);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueOrSemaphore), (void*)(&xQueueOrSemaphore), sizeof(QueueSetMemberHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xQueueSet)
  {
    UNITY_SET_DETAILS(CMockString_xQueueAddToSet,CMockString_xQueueSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet), sizeof(QueueSetHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueAddToSet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueAddToSet_CallbackFunctionPointer(xQueueOrSemaphore, xQueueSet, Mock.xQueueAddToSet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueAddToSet(CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance, QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueueOrSemaphore), (void*)(&xQueueOrSemaphore),
         sizeof(QueueSetMemberHandle_t[sizeof(xQueueOrSemaphore) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueueOrSemaphore = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet),
         sizeof(QueueSetHandle_t[sizeof(xQueueSet) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueueSet = 0;
}

void xQueueAddToSet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueAddToSet_CALL_INSTANCE));
  CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueAddToSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueAddToSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueAddToSet_CallInstance, cmock_guts_index);
  Mock.xQueueAddToSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueAddToSet_IgnoreBool = (char)1;
}

void xQueueAddToSet_CMockStopIgnore(void)
{
  if(Mock.xQueueAddToSet_IgnoreBool)
    Mock.xQueueAddToSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueAddToSet_CallInstance);
  Mock.xQueueAddToSet_IgnoreBool = (char)0;
}

void xQueueAddToSet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueAddToSet_CALL_INSTANCE));
  CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueAddToSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueAddToSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueAddToSet_CallInstance, cmock_guts_index);
  Mock.xQueueAddToSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueAddToSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueAddToSet_CALL_INSTANCE));
  CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueAddToSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueAddToSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueAddToSet_CallInstance, cmock_guts_index);
  Mock.xQueueAddToSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueAddToSet(cmock_call_instance, xQueueOrSemaphore, xQueueSet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueAddToSet_AddCallback(CMOCK_xQueueAddToSet_CALLBACK Callback)
{
  Mock.xQueueAddToSet_IgnoreBool = (char)0;
  Mock.xQueueAddToSet_CallbackBool = (char)1;
  Mock.xQueueAddToSet_CallbackFunctionPointer = Callback;
}

void xQueueAddToSet_Stub(CMOCK_xQueueAddToSet_CALLBACK Callback)
{
  Mock.xQueueAddToSet_IgnoreBool = (char)0;
  Mock.xQueueAddToSet_CallbackBool = (char)0;
  Mock.xQueueAddToSet_CallbackFunctionPointer = Callback;
}

void xQueueAddToSet_CMockIgnoreArg_xQueueOrSemaphore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueAddToSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueAddToSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueueOrSemaphore = 1;
}

void xQueueAddToSet_CMockIgnoreArg_xQueueSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueAddToSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueAddToSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueAddToSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueueSet = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueRemoveFromSet
#else
BaseType_t xQueueRemoveFromSet(QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet) __attribute__((weak));
#endif

BaseType_t xQueueRemoveFromSet(QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueRemoveFromSet);
  cmock_call_instance = (CMOCK_xQueueRemoveFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueRemoveFromSet_CallInstance);
  Mock.xQueueRemoveFromSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueRemoveFromSet_CallInstance);
  if (Mock.xQueueRemoveFromSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueRemoveFromSet_FinalReturn;
    memcpy((void*)(&Mock.xQueueRemoveFromSet_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueRemoveFromSet_CallbackBool &&
      Mock.xQueueRemoveFromSet_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueRemoveFromSet_CallbackFunctionPointer(xQueueOrSemaphore, xQueueSet, Mock.xQueueRemoveFromSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueueOrSemaphore)
  {
    UNITY_SET_DETAILS(CMockString_xQueueRemoveFromSet,CMockString_xQueueOrSemaphore);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueOrSemaphore), (void*)(&xQueueOrSemaphore), sizeof(QueueSetMemberHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xQueueSet)
  {
    UNITY_SET_DETAILS(CMockString_xQueueRemoveFromSet,CMockString_xQueueSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet), sizeof(QueueSetHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueRemoveFromSet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueRemoveFromSet_CallbackFunctionPointer(xQueueOrSemaphore, xQueueSet, Mock.xQueueRemoveFromSet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueRemoveFromSet(CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance, QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueueOrSemaphore), (void*)(&xQueueOrSemaphore),
         sizeof(QueueSetMemberHandle_t[sizeof(xQueueOrSemaphore) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueueOrSemaphore = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet),
         sizeof(QueueSetHandle_t[sizeof(xQueueSet) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueueSet = 0;
}

void xQueueRemoveFromSet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueRemoveFromSet_CALL_INSTANCE));
  CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueRemoveFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueRemoveFromSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueRemoveFromSet_CallInstance, cmock_guts_index);
  Mock.xQueueRemoveFromSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueRemoveFromSet_IgnoreBool = (char)1;
}

void xQueueRemoveFromSet_CMockStopIgnore(void)
{
  if(Mock.xQueueRemoveFromSet_IgnoreBool)
    Mock.xQueueRemoveFromSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueRemoveFromSet_CallInstance);
  Mock.xQueueRemoveFromSet_IgnoreBool = (char)0;
}

void xQueueRemoveFromSet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueRemoveFromSet_CALL_INSTANCE));
  CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueRemoveFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueRemoveFromSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueRemoveFromSet_CallInstance, cmock_guts_index);
  Mock.xQueueRemoveFromSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueRemoveFromSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueRemoveFromSet_CALL_INSTANCE));
  CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueRemoveFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueRemoveFromSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueRemoveFromSet_CallInstance, cmock_guts_index);
  Mock.xQueueRemoveFromSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueRemoveFromSet(cmock_call_instance, xQueueOrSemaphore, xQueueSet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueRemoveFromSet_AddCallback(CMOCK_xQueueRemoveFromSet_CALLBACK Callback)
{
  Mock.xQueueRemoveFromSet_IgnoreBool = (char)0;
  Mock.xQueueRemoveFromSet_CallbackBool = (char)1;
  Mock.xQueueRemoveFromSet_CallbackFunctionPointer = Callback;
}

void xQueueRemoveFromSet_Stub(CMOCK_xQueueRemoveFromSet_CALLBACK Callback)
{
  Mock.xQueueRemoveFromSet_IgnoreBool = (char)0;
  Mock.xQueueRemoveFromSet_CallbackBool = (char)0;
  Mock.xQueueRemoveFromSet_CallbackFunctionPointer = Callback;
}

void xQueueRemoveFromSet_CMockIgnoreArg_xQueueOrSemaphore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueRemoveFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueRemoveFromSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueueOrSemaphore = 1;
}

void xQueueRemoveFromSet_CMockIgnoreArg_xQueueSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueRemoveFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueRemoveFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueRemoveFromSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueueSet = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueSelectFromSet
#else
QueueSetMemberHandle_t xQueueSelectFromSet(QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait) __attribute__((weak));
#endif

QueueSetMemberHandle_t xQueueSelectFromSet(QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueSelectFromSet);
  cmock_call_instance = (CMOCK_xQueueSelectFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueSelectFromSet_CallInstance);
  Mock.xQueueSelectFromSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueSelectFromSet_CallInstance);
  if (Mock.xQueueSelectFromSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueSelectFromSet_FinalReturn;
    memcpy((void*)(&Mock.xQueueSelectFromSet_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueSetMemberHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueSelectFromSet_CallbackBool &&
      Mock.xQueueSelectFromSet_CallbackFunctionPointer != NULL)
  {
    QueueSetMemberHandle_t cmock_cb_ret = Mock.xQueueSelectFromSet_CallbackFunctionPointer(xQueueSet, xTicksToWait, Mock.xQueueSelectFromSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueueSet)
  {
    UNITY_SET_DETAILS(CMockString_xQueueSelectFromSet,CMockString_xQueueSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet), sizeof(QueueSetHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xQueueSelectFromSet,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueSelectFromSet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueSelectFromSet_CallbackFunctionPointer(xQueueSet, xTicksToWait, Mock.xQueueSelectFromSet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueSelectFromSet(CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance, QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet),
         sizeof(QueueSetHandle_t[sizeof(xQueueSet) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueueSet = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xQueueSelectFromSet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetMemberHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSelectFromSet_CALL_INSTANCE));
  CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSelectFromSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueSelectFromSet_CallInstance, cmock_guts_index);
  Mock.xQueueSelectFromSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueSelectFromSet_IgnoreBool = (char)1;
}

void xQueueSelectFromSet_CMockStopIgnore(void)
{
  if(Mock.xQueueSelectFromSet_IgnoreBool)
    Mock.xQueueSelectFromSet_CallInstance = CMock_Guts_MemNext(Mock.xQueueSelectFromSet_CallInstance);
  Mock.xQueueSelectFromSet_IgnoreBool = (char)0;
}

void xQueueSelectFromSet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetMemberHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSelectFromSet_CALL_INSTANCE));
  CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSelectFromSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueSelectFromSet_CallInstance, cmock_guts_index);
  Mock.xQueueSelectFromSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueSelectFromSet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait, QueueSetMemberHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSelectFromSet_CALL_INSTANCE));
  CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSelectFromSet_CallInstance = CMock_Guts_MemChain(Mock.xQueueSelectFromSet_CallInstance, cmock_guts_index);
  Mock.xQueueSelectFromSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueSelectFromSet(cmock_call_instance, xQueueSet, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueSetMemberHandle_t[sizeof(cmock_to_return) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
}

void xQueueSelectFromSet_AddCallback(CMOCK_xQueueSelectFromSet_CALLBACK Callback)
{
  Mock.xQueueSelectFromSet_IgnoreBool = (char)0;
  Mock.xQueueSelectFromSet_CallbackBool = (char)1;
  Mock.xQueueSelectFromSet_CallbackFunctionPointer = Callback;
}

void xQueueSelectFromSet_Stub(CMOCK_xQueueSelectFromSet_CALLBACK Callback)
{
  Mock.xQueueSelectFromSet_IgnoreBool = (char)0;
  Mock.xQueueSelectFromSet_CallbackBool = (char)0;
  Mock.xQueueSelectFromSet_CallbackFunctionPointer = Callback;
}

void xQueueSelectFromSet_CMockIgnoreArg_xQueueSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueSelectFromSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueueSet = 1;
}

void xQueueSelectFromSet_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueSelectFromSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueSelectFromSet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueSelectFromSetFromISR
#else
QueueSetMemberHandle_t xQueueSelectFromSetFromISR(QueueSetHandle_t xQueueSet) __attribute__((weak));
#endif

QueueSetMemberHandle_t xQueueSelectFromSetFromISR(QueueSetHandle_t xQueueSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueSelectFromSetFromISR);
  cmock_call_instance = (CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueSelectFromSetFromISR_CallInstance);
  Mock.xQueueSelectFromSetFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueSelectFromSetFromISR_CallInstance);
  if (Mock.xQueueSelectFromSetFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueSelectFromSetFromISR_FinalReturn;
    memcpy((void*)(&Mock.xQueueSelectFromSetFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(QueueSetMemberHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueSelectFromSetFromISR_CallbackBool &&
      Mock.xQueueSelectFromSetFromISR_CallbackFunctionPointer != NULL)
  {
    QueueSetMemberHandle_t cmock_cb_ret = Mock.xQueueSelectFromSetFromISR_CallbackFunctionPointer(xQueueSet, Mock.xQueueSelectFromSetFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueueSet)
  {
    UNITY_SET_DETAILS(CMockString_xQueueSelectFromSetFromISR,CMockString_xQueueSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet), sizeof(QueueSetHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueSelectFromSetFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueSelectFromSetFromISR_CallbackFunctionPointer(xQueueSet, Mock.xQueueSelectFromSetFromISR_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueSelectFromSetFromISR(CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance, QueueSetHandle_t xQueueSet)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueueSet), (void*)(&xQueueSet),
         sizeof(QueueSetHandle_t[sizeof(xQueueSet) == sizeof(QueueSetHandle_t) ? 1 : -1])); /* add QueueSetHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueueSet = 0;
}

void xQueueSelectFromSetFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetMemberHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE));
  CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSelectFromSetFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueSelectFromSetFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueSelectFromSetFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueSelectFromSetFromISR_IgnoreBool = (char)1;
}

void xQueueSelectFromSetFromISR_CMockStopIgnore(void)
{
  if(Mock.xQueueSelectFromSetFromISR_IgnoreBool)
    Mock.xQueueSelectFromSetFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueSelectFromSetFromISR_CallInstance);
  Mock.xQueueSelectFromSetFromISR_IgnoreBool = (char)0;
}

void xQueueSelectFromSetFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetMemberHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE));
  CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSelectFromSetFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueSelectFromSetFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueSelectFromSetFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueSelectFromSetFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueSetHandle_t xQueueSet, QueueSetMemberHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE));
  CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSelectFromSetFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueSelectFromSetFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueSelectFromSetFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueSelectFromSetFromISR(cmock_call_instance, xQueueSet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(QueueSetMemberHandle_t[sizeof(cmock_to_return) == sizeof(QueueSetMemberHandle_t) ? 1 : -1])); /* add QueueSetMemberHandle_t to :treat_as_array if this causes an error */
}

void xQueueSelectFromSetFromISR_AddCallback(CMOCK_xQueueSelectFromSetFromISR_CALLBACK Callback)
{
  Mock.xQueueSelectFromSetFromISR_IgnoreBool = (char)0;
  Mock.xQueueSelectFromSetFromISR_CallbackBool = (char)1;
  Mock.xQueueSelectFromSetFromISR_CallbackFunctionPointer = Callback;
}

void xQueueSelectFromSetFromISR_Stub(CMOCK_xQueueSelectFromSetFromISR_CALLBACK Callback)
{
  Mock.xQueueSelectFromSetFromISR_IgnoreBool = (char)0;
  Mock.xQueueSelectFromSetFromISR_CallbackBool = (char)0;
  Mock.xQueueSelectFromSetFromISR_CallbackFunctionPointer = Callback;
}

void xQueueSelectFromSetFromISR_CMockIgnoreArg_xQueueSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSelectFromSetFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueSelectFromSetFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueueSet = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vQueueWaitForMessageRestricted
#else
void vQueueWaitForMessageRestricted(QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely) __attribute__((weak));
#endif

void vQueueWaitForMessageRestricted(QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueWaitForMessageRestricted);
  cmock_call_instance = (CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueWaitForMessageRestricted_CallInstance);
  Mock.vQueueWaitForMessageRestricted_CallInstance = CMock_Guts_MemNext(Mock.vQueueWaitForMessageRestricted_CallInstance);
  if (Mock.vQueueWaitForMessageRestricted_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vQueueWaitForMessageRestricted_CallbackBool &&
      Mock.vQueueWaitForMessageRestricted_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueWaitForMessageRestricted_CallbackFunctionPointer(xQueue, xTicksToWait, xWaitIndefinitely, Mock.vQueueWaitForMessageRestricted_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_vQueueWaitForMessageRestricted,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_vQueueWaitForMessageRestricted,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xWaitIndefinitely)
  {
    UNITY_SET_DETAILS(CMockString_vQueueWaitForMessageRestricted,CMockString_xWaitIndefinitely);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xWaitIndefinitely), (void*)(&xWaitIndefinitely), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vQueueWaitForMessageRestricted_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueWaitForMessageRestricted_CallbackFunctionPointer(xQueue, xTicksToWait, xWaitIndefinitely, Mock.vQueueWaitForMessageRestricted_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueWaitForMessageRestricted(CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xWaitIndefinitely), (void*)(&xWaitIndefinitely),
         sizeof(BaseType_t[sizeof(xWaitIndefinitely) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xWaitIndefinitely = 0;
}

void vQueueWaitForMessageRestricted_CMockIgnore(void)
{
  Mock.vQueueWaitForMessageRestricted_IgnoreBool = (char)1;
}

void vQueueWaitForMessageRestricted_CMockStopIgnore(void)
{
  Mock.vQueueWaitForMessageRestricted_IgnoreBool = (char)0;
}

void vQueueWaitForMessageRestricted_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE));
  CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueWaitForMessageRestricted_CallInstance = CMock_Guts_MemChain(Mock.vQueueWaitForMessageRestricted_CallInstance, cmock_guts_index);
  Mock.vQueueWaitForMessageRestricted_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vQueueWaitForMessageRestricted_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE));
  CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueWaitForMessageRestricted_CallInstance = CMock_Guts_MemChain(Mock.vQueueWaitForMessageRestricted_CallInstance, cmock_guts_index);
  Mock.vQueueWaitForMessageRestricted_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vQueueWaitForMessageRestricted(cmock_call_instance, xQueue, xTicksToWait, xWaitIndefinitely);
}

void vQueueWaitForMessageRestricted_AddCallback(CMOCK_vQueueWaitForMessageRestricted_CALLBACK Callback)
{
  Mock.vQueueWaitForMessageRestricted_IgnoreBool = (char)0;
  Mock.vQueueWaitForMessageRestricted_CallbackBool = (char)1;
  Mock.vQueueWaitForMessageRestricted_CallbackFunctionPointer = Callback;
}

void vQueueWaitForMessageRestricted_Stub(CMOCK_vQueueWaitForMessageRestricted_CALLBACK Callback)
{
  Mock.vQueueWaitForMessageRestricted_IgnoreBool = (char)0;
  Mock.vQueueWaitForMessageRestricted_CallbackBool = (char)0;
  Mock.vQueueWaitForMessageRestricted_CallbackFunctionPointer = Callback;
}

void vQueueWaitForMessageRestricted_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueWaitForMessageRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void vQueueWaitForMessageRestricted_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueWaitForMessageRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

void vQueueWaitForMessageRestricted_CMockIgnoreArg_xWaitIndefinitely(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueWaitForMessageRestricted_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueWaitForMessageRestricted_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xWaitIndefinitely = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xQueueGenericReset
#else
BaseType_t xQueueGenericReset(QueueHandle_t xQueue, BaseType_t xNewQueue) __attribute__((weak));
#endif

BaseType_t xQueueGenericReset(QueueHandle_t xQueue, BaseType_t xNewQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xQueueGenericReset);
  cmock_call_instance = (CMOCK_xQueueGenericReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueGenericReset_CallInstance);
  Mock.xQueueGenericReset_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericReset_CallInstance);
  if (Mock.xQueueGenericReset_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xQueueGenericReset_FinalReturn;
    memcpy((void*)(&Mock.xQueueGenericReset_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xQueueGenericReset_CallbackBool &&
      Mock.xQueueGenericReset_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xQueueGenericReset_CallbackFunctionPointer(xQueue, xNewQueue, Mock.xQueueGenericReset_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericReset,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xNewQueue)
  {
    UNITY_SET_DETAILS(CMockString_xQueueGenericReset,CMockString_xNewQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xNewQueue), (void*)(&xNewQueue), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xQueueGenericReset_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xQueueGenericReset_CallbackFunctionPointer(xQueue, xNewQueue, Mock.xQueueGenericReset_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueGenericReset(CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, BaseType_t xNewQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xNewQueue), (void*)(&xNewQueue),
         sizeof(BaseType_t[sizeof(xNewQueue) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xNewQueue = 0;
}

void xQueueGenericReset_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericReset_CALL_INSTANCE));
  CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericReset_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericReset_CallInstance, cmock_guts_index);
  Mock.xQueueGenericReset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueGenericReset_IgnoreBool = (char)1;
}

void xQueueGenericReset_CMockStopIgnore(void)
{
  if(Mock.xQueueGenericReset_IgnoreBool)
    Mock.xQueueGenericReset_CallInstance = CMock_Guts_MemNext(Mock.xQueueGenericReset_CallInstance);
  Mock.xQueueGenericReset_IgnoreBool = (char)0;
}

void xQueueGenericReset_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericReset_CALL_INSTANCE));
  CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericReset_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericReset_CallInstance, cmock_guts_index);
  Mock.xQueueGenericReset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xQueueGenericReset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, BaseType_t xNewQueue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueGenericReset_CALL_INSTANCE));
  CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueGenericReset_CallInstance = CMock_Guts_MemChain(Mock.xQueueGenericReset_CallInstance, cmock_guts_index);
  Mock.xQueueGenericReset_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xQueueGenericReset(cmock_call_instance, xQueue, xNewQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xQueueGenericReset_AddCallback(CMOCK_xQueueGenericReset_CALLBACK Callback)
{
  Mock.xQueueGenericReset_IgnoreBool = (char)0;
  Mock.xQueueGenericReset_CallbackBool = (char)1;
  Mock.xQueueGenericReset_CallbackFunctionPointer = Callback;
}

void xQueueGenericReset_Stub(CMOCK_xQueueGenericReset_CALLBACK Callback)
{
  Mock.xQueueGenericReset_IgnoreBool = (char)0;
  Mock.xQueueGenericReset_CallbackBool = (char)0;
  Mock.xQueueGenericReset_CallbackFunctionPointer = Callback;
}

void xQueueGenericReset_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericReset_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void xQueueGenericReset_CMockIgnoreArg_xNewQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xQueueGenericReset_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueGenericReset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xQueueGenericReset_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xNewQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vQueueSetQueueNumber
#else
void vQueueSetQueueNumber(QueueHandle_t xQueue, UBaseType_t uxQueueNumber) __attribute__((weak));
#endif

void vQueueSetQueueNumber(QueueHandle_t xQueue, UBaseType_t uxQueueNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vQueueSetQueueNumber);
  cmock_call_instance = (CMOCK_vQueueSetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vQueueSetQueueNumber_CallInstance);
  Mock.vQueueSetQueueNumber_CallInstance = CMock_Guts_MemNext(Mock.vQueueSetQueueNumber_CallInstance);
  if (Mock.vQueueSetQueueNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vQueueSetQueueNumber_CallbackBool &&
      Mock.vQueueSetQueueNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueSetQueueNumber_CallbackFunctionPointer(xQueue, uxQueueNumber, Mock.vQueueSetQueueNumber_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_vQueueSetQueueNumber,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxQueueNumber)
  {
    UNITY_SET_DETAILS(CMockString_vQueueSetQueueNumber,CMockString_uxQueueNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxQueueNumber), (void*)(&uxQueueNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vQueueSetQueueNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vQueueSetQueueNumber_CallbackFunctionPointer(xQueue, uxQueueNumber, Mock.vQueueSetQueueNumber_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vQueueSetQueueNumber(CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, UBaseType_t uxQueueNumber)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxQueueNumber), (void*)(&uxQueueNumber),
         sizeof(UBaseType_t[sizeof(uxQueueNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxQueueNumber = 0;
}

void vQueueSetQueueNumber_CMockIgnore(void)
{
  Mock.vQueueSetQueueNumber_IgnoreBool = (char)1;
}

void vQueueSetQueueNumber_CMockStopIgnore(void)
{
  Mock.vQueueSetQueueNumber_IgnoreBool = (char)0;
}

void vQueueSetQueueNumber_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueSetQueueNumber_CALL_INSTANCE));
  CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueSetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueSetQueueNumber_CallInstance = CMock_Guts_MemChain(Mock.vQueueSetQueueNumber_CallInstance, cmock_guts_index);
  Mock.vQueueSetQueueNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vQueueSetQueueNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, UBaseType_t uxQueueNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vQueueSetQueueNumber_CALL_INSTANCE));
  CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueSetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vQueueSetQueueNumber_CallInstance = CMock_Guts_MemChain(Mock.vQueueSetQueueNumber_CallInstance, cmock_guts_index);
  Mock.vQueueSetQueueNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vQueueSetQueueNumber(cmock_call_instance, xQueue, uxQueueNumber);
}

void vQueueSetQueueNumber_AddCallback(CMOCK_vQueueSetQueueNumber_CALLBACK Callback)
{
  Mock.vQueueSetQueueNumber_IgnoreBool = (char)0;
  Mock.vQueueSetQueueNumber_CallbackBool = (char)1;
  Mock.vQueueSetQueueNumber_CallbackFunctionPointer = Callback;
}

void vQueueSetQueueNumber_Stub(CMOCK_vQueueSetQueueNumber_CALLBACK Callback)
{
  Mock.vQueueSetQueueNumber_IgnoreBool = (char)0;
  Mock.vQueueSetQueueNumber_CallbackBool = (char)0;
  Mock.vQueueSetQueueNumber_CallbackFunctionPointer = Callback;
}

void vQueueSetQueueNumber_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueSetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueSetQueueNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

void vQueueSetQueueNumber_CMockIgnoreArg_uxQueueNumber(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vQueueSetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vQueueSetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vQueueSetQueueNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxQueueNumber = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxQueueGetQueueNumber
#else
UBaseType_t uxQueueGetQueueNumber(QueueHandle_t xQueue) __attribute__((weak));
#endif

UBaseType_t uxQueueGetQueueNumber(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxQueueGetQueueNumber);
  cmock_call_instance = (CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxQueueGetQueueNumber_CallInstance);
  Mock.uxQueueGetQueueNumber_CallInstance = CMock_Guts_MemNext(Mock.uxQueueGetQueueNumber_CallInstance);
  if (Mock.uxQueueGetQueueNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxQueueGetQueueNumber_FinalReturn;
    memcpy((void*)(&Mock.uxQueueGetQueueNumber_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxQueueGetQueueNumber_CallbackBool &&
      Mock.uxQueueGetQueueNumber_CallbackFunctionPointer != NULL)
  {
    UBaseType_t cmock_cb_ret = Mock.uxQueueGetQueueNumber_CallbackFunctionPointer(xQueue, Mock.uxQueueGetQueueNumber_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_uxQueueGetQueueNumber,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxQueueGetQueueNumber_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxQueueGetQueueNumber_CallbackFunctionPointer(xQueue, Mock.uxQueueGetQueueNumber_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxQueueGetQueueNumber(CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void uxQueueGetQueueNumber_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE));
  CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueGetQueueNumber_CallInstance = CMock_Guts_MemChain(Mock.uxQueueGetQueueNumber_CallInstance, cmock_guts_index);
  Mock.uxQueueGetQueueNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxQueueGetQueueNumber_IgnoreBool = (char)1;
}

void uxQueueGetQueueNumber_CMockStopIgnore(void)
{
  if(Mock.uxQueueGetQueueNumber_IgnoreBool)
    Mock.uxQueueGetQueueNumber_CallInstance = CMock_Guts_MemNext(Mock.uxQueueGetQueueNumber_CallInstance);
  Mock.uxQueueGetQueueNumber_IgnoreBool = (char)0;
}

void uxQueueGetQueueNumber_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE));
  CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueGetQueueNumber_CallInstance = CMock_Guts_MemChain(Mock.uxQueueGetQueueNumber_CallInstance, cmock_guts_index);
  Mock.uxQueueGetQueueNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxQueueGetQueueNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE));
  CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxQueueGetQueueNumber_CallInstance = CMock_Guts_MemChain(Mock.uxQueueGetQueueNumber_CallInstance, cmock_guts_index);
  Mock.uxQueueGetQueueNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxQueueGetQueueNumber(cmock_call_instance, xQueue);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxQueueGetQueueNumber_AddCallback(CMOCK_uxQueueGetQueueNumber_CALLBACK Callback)
{
  Mock.uxQueueGetQueueNumber_IgnoreBool = (char)0;
  Mock.uxQueueGetQueueNumber_CallbackBool = (char)1;
  Mock.uxQueueGetQueueNumber_CallbackFunctionPointer = Callback;
}

void uxQueueGetQueueNumber_Stub(CMOCK_uxQueueGetQueueNumber_CALLBACK Callback)
{
  Mock.uxQueueGetQueueNumber_IgnoreBool = (char)0;
  Mock.uxQueueGetQueueNumber_CallbackBool = (char)0;
  Mock.uxQueueGetQueueNumber_CallbackFunctionPointer = Callback;
}

void uxQueueGetQueueNumber_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxQueueGetQueueNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxQueueGetQueueNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak ucQueueGetQueueType
#else
uint8_t ucQueueGetQueueType(QueueHandle_t xQueue) __attribute__((weak));
#endif

uint8_t ucQueueGetQueueType(QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ucQueueGetQueueType);
  cmock_call_instance = (CMOCK_ucQueueGetQueueType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ucQueueGetQueueType_CallInstance);
  Mock.ucQueueGetQueueType_CallInstance = CMock_Guts_MemNext(Mock.ucQueueGetQueueType_CallInstance);
  if (Mock.ucQueueGetQueueType_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ucQueueGetQueueType_FinalReturn;
    Mock.ucQueueGetQueueType_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ucQueueGetQueueType_CallbackBool &&
      Mock.ucQueueGetQueueType_CallbackFunctionPointer != NULL)
  {
    uint8_t cmock_cb_ret = Mock.ucQueueGetQueueType_CallbackFunctionPointer(xQueue, Mock.ucQueueGetQueueType_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xQueue)
  {
    UNITY_SET_DETAILS(CMockString_ucQueueGetQueueType,CMockString_xQueue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.ucQueueGetQueueType_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ucQueueGetQueueType_CallbackFunctionPointer(xQueue, Mock.ucQueueGetQueueType_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ucQueueGetQueueType(CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue)
{
  memcpy((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue),
         sizeof(QueueHandle_t[sizeof(xQueue) == sizeof(QueueHandle_t) ? 1 : -1])); /* add QueueHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xQueue = 0;
}

void ucQueueGetQueueType_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ucQueueGetQueueType_CALL_INSTANCE));
  CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucQueueGetQueueType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ucQueueGetQueueType_CallInstance = CMock_Guts_MemChain(Mock.ucQueueGetQueueType_CallInstance, cmock_guts_index);
  Mock.ucQueueGetQueueType_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ucQueueGetQueueType_IgnoreBool = (char)1;
}

void ucQueueGetQueueType_CMockStopIgnore(void)
{
  if(Mock.ucQueueGetQueueType_IgnoreBool)
    Mock.ucQueueGetQueueType_CallInstance = CMock_Guts_MemNext(Mock.ucQueueGetQueueType_CallInstance);
  Mock.ucQueueGetQueueType_IgnoreBool = (char)0;
}

void ucQueueGetQueueType_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ucQueueGetQueueType_CALL_INSTANCE));
  CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucQueueGetQueueType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ucQueueGetQueueType_CallInstance = CMock_Guts_MemChain(Mock.ucQueueGetQueueType_CallInstance, cmock_guts_index);
  Mock.ucQueueGetQueueType_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void ucQueueGetQueueType_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ucQueueGetQueueType_CALL_INSTANCE));
  CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucQueueGetQueueType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ucQueueGetQueueType_CallInstance = CMock_Guts_MemChain(Mock.ucQueueGetQueueType_CallInstance, cmock_guts_index);
  Mock.ucQueueGetQueueType_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_ucQueueGetQueueType(cmock_call_instance, xQueue);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ucQueueGetQueueType_AddCallback(CMOCK_ucQueueGetQueueType_CALLBACK Callback)
{
  Mock.ucQueueGetQueueType_IgnoreBool = (char)0;
  Mock.ucQueueGetQueueType_CallbackBool = (char)1;
  Mock.ucQueueGetQueueType_CallbackFunctionPointer = Callback;
}

void ucQueueGetQueueType_Stub(CMOCK_ucQueueGetQueueType_CALLBACK Callback)
{
  Mock.ucQueueGetQueueType_IgnoreBool = (char)0;
  Mock.ucQueueGetQueueType_CallbackBool = (char)0;
  Mock.ucQueueGetQueueType_CallbackFunctionPointer = Callback;
}

void ucQueueGetQueueType_CMockIgnoreArg_xQueue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ucQueueGetQueueType_CALL_INSTANCE* cmock_call_instance = (CMOCK_ucQueueGetQueueType_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ucQueueGetQueueType_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xQueue = 1;
}

