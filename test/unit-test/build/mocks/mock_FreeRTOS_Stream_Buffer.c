/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_FreeRTOS_Stream_Buffer.h"

static const char* CMockString_ppucData = "ppucData";
static const char* CMockString_pucData = "pucData";
static const char* CMockString_pxBuffer = "pxBuffer";
static const char* CMockString_uxByteCount = "uxByteCount";
static const char* CMockString_uxCount = "uxCount";
static const char* CMockString_uxLeft = "uxLeft";
static const char* CMockString_uxLower = "uxLower";
static const char* CMockString_uxMaxCount = "uxMaxCount";
static const char* CMockString_uxOffset = "uxOffset";
static const char* CMockString_uxRight = "uxRight";
static const char* CMockString_uxStreamBufferAdd = "uxStreamBufferAdd";
static const char* CMockString_uxStreamBufferDistance = "uxStreamBufferDistance";
static const char* CMockString_uxStreamBufferFrontSpace = "uxStreamBufferFrontSpace";
static const char* CMockString_uxStreamBufferGet = "uxStreamBufferGet";
static const char* CMockString_uxStreamBufferGetPtr = "uxStreamBufferGetPtr";
static const char* CMockString_uxStreamBufferGetSize = "uxStreamBufferGetSize";
static const char* CMockString_uxStreamBufferGetSpace = "uxStreamBufferGetSpace";
static const char* CMockString_uxStreamBufferMidSpace = "uxStreamBufferMidSpace";
static const char* CMockString_uxStreamBufferSpace = "uxStreamBufferSpace";
static const char* CMockString_uxUpper = "uxUpper";
static const char* CMockString_vStreamBufferClear = "vStreamBufferClear";
static const char* CMockString_vStreamBufferMoveMid = "vStreamBufferMoveMid";
static const char* CMockString_xPeek = "xPeek";
static const char* CMockString_xStreamBufferLessThenEqual = "xStreamBufferLessThenEqual";

typedef struct _CMOCK_vStreamBufferClear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  StreamBuffer_t* Expected_pxBuffer;
  int Expected_pxBuffer_Depth;
  char ReturnThruPtr_pxBuffer_Used;
  StreamBuffer_t* ReturnThruPtr_pxBuffer_Val;
  int ReturnThruPtr_pxBuffer_Size;
  char IgnoreArg_pxBuffer;

} CMOCK_vStreamBufferClear_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferSpace_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  const StreamBuffer_t* Expected_pxBuffer;
  size_t Expected_uxLower;
  size_t Expected_uxUpper;
  int Expected_pxBuffer_Depth;
  char IgnoreArg_pxBuffer;
  char IgnoreArg_uxLower;
  char IgnoreArg_uxUpper;

} CMOCK_uxStreamBufferSpace_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferDistance_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  const StreamBuffer_t* Expected_pxBuffer;
  size_t Expected_uxLower;
  size_t Expected_uxUpper;
  int Expected_pxBuffer_Depth;
  char IgnoreArg_pxBuffer;
  char IgnoreArg_uxLower;
  char IgnoreArg_uxUpper;

} CMOCK_uxStreamBufferDistance_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  const StreamBuffer_t* Expected_pxBuffer;
  int Expected_pxBuffer_Depth;
  char IgnoreArg_pxBuffer;

} CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  const StreamBuffer_t* Expected_pxBuffer;
  int Expected_pxBuffer_Depth;
  char IgnoreArg_pxBuffer;

} CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferGetSize_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  const StreamBuffer_t* Expected_pxBuffer;
  int Expected_pxBuffer_Depth;
  char IgnoreArg_pxBuffer;

} CMOCK_uxStreamBufferGetSize_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  const StreamBuffer_t* Expected_pxBuffer;
  int Expected_pxBuffer_Depth;
  char IgnoreArg_pxBuffer;

} CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE;

typedef struct _CMOCK_vStreamBufferMoveMid_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  StreamBuffer_t* Expected_pxBuffer;
  size_t Expected_uxCount;
  int Expected_pxBuffer_Depth;
  char ReturnThruPtr_pxBuffer_Used;
  StreamBuffer_t* ReturnThruPtr_pxBuffer_Val;
  int ReturnThruPtr_pxBuffer_Size;
  char IgnoreArg_pxBuffer;
  char IgnoreArg_uxCount;

} CMOCK_vStreamBufferMoveMid_CALL_INSTANCE;

typedef struct _CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  const StreamBuffer_t* Expected_pxBuffer;
  size_t Expected_uxLeft;
  size_t Expected_uxRight;
  int Expected_pxBuffer_Depth;
  char IgnoreArg_pxBuffer;
  char IgnoreArg_uxLeft;
  char IgnoreArg_uxRight;

} CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  StreamBuffer_t* Expected_pxBuffer;
  uint8_t** Expected_ppucData;
  int Expected_pxBuffer_Depth;
  int Expected_ppucData_Depth;
  char ReturnThruPtr_pxBuffer_Used;
  StreamBuffer_t* ReturnThruPtr_pxBuffer_Val;
  int ReturnThruPtr_pxBuffer_Size;
  char ReturnThruPtr_ppucData_Used;
  uint8_t** ReturnThruPtr_ppucData_Val;
  int ReturnThruPtr_ppucData_Size;
  char IgnoreArg_pxBuffer;
  char IgnoreArg_ppucData;

} CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferAdd_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  StreamBuffer_t* Expected_pxBuffer;
  size_t Expected_uxOffset;
  const uint8_t* Expected_pucData;
  size_t Expected_uxByteCount;
  int Expected_pxBuffer_Depth;
  int Expected_pucData_Depth;
  char ReturnThruPtr_pxBuffer_Used;
  StreamBuffer_t* ReturnThruPtr_pxBuffer_Val;
  int ReturnThruPtr_pxBuffer_Size;
  char IgnoreArg_pxBuffer;
  char IgnoreArg_uxOffset;
  char IgnoreArg_pucData;
  char IgnoreArg_uxByteCount;

} CMOCK_uxStreamBufferAdd_CALL_INSTANCE;

typedef struct _CMOCK_uxStreamBufferGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  size_t ReturnVal;
  int CallOrder;
  StreamBuffer_t* Expected_pxBuffer;
  size_t Expected_uxOffset;
  uint8_t* Expected_pucData;
  size_t Expected_uxMaxCount;
  BaseType_t Expected_xPeek;
  int Expected_pxBuffer_Depth;
  int Expected_pucData_Depth;
  char ReturnThruPtr_pxBuffer_Used;
  StreamBuffer_t* ReturnThruPtr_pxBuffer_Val;
  int ReturnThruPtr_pxBuffer_Size;
  char ReturnThruPtr_pucData_Used;
  uint8_t* ReturnThruPtr_pucData_Val;
  int ReturnThruPtr_pucData_Size;
  char IgnoreArg_pxBuffer;
  char IgnoreArg_uxOffset;
  char IgnoreArg_pucData;
  char IgnoreArg_uxMaxCount;
  char IgnoreArg_xPeek;

} CMOCK_uxStreamBufferGet_CALL_INSTANCE;

static struct mock_FreeRTOS_Stream_BufferInstance
{
  char vStreamBufferClear_IgnoreBool;
  char vStreamBufferClear_CallbackBool;
  CMOCK_vStreamBufferClear_CALLBACK vStreamBufferClear_CallbackFunctionPointer;
  int vStreamBufferClear_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vStreamBufferClear_CallInstance;
  char uxStreamBufferSpace_IgnoreBool;
  size_t uxStreamBufferSpace_FinalReturn;
  char uxStreamBufferSpace_CallbackBool;
  CMOCK_uxStreamBufferSpace_CALLBACK uxStreamBufferSpace_CallbackFunctionPointer;
  int uxStreamBufferSpace_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferSpace_CallInstance;
  char uxStreamBufferDistance_IgnoreBool;
  size_t uxStreamBufferDistance_FinalReturn;
  char uxStreamBufferDistance_CallbackBool;
  CMOCK_uxStreamBufferDistance_CALLBACK uxStreamBufferDistance_CallbackFunctionPointer;
  int uxStreamBufferDistance_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferDistance_CallInstance;
  char uxStreamBufferGetSpace_IgnoreBool;
  size_t uxStreamBufferGetSpace_FinalReturn;
  char uxStreamBufferGetSpace_CallbackBool;
  CMOCK_uxStreamBufferGetSpace_CALLBACK uxStreamBufferGetSpace_CallbackFunctionPointer;
  int uxStreamBufferGetSpace_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferGetSpace_CallInstance;
  char uxStreamBufferFrontSpace_IgnoreBool;
  size_t uxStreamBufferFrontSpace_FinalReturn;
  char uxStreamBufferFrontSpace_CallbackBool;
  CMOCK_uxStreamBufferFrontSpace_CALLBACK uxStreamBufferFrontSpace_CallbackFunctionPointer;
  int uxStreamBufferFrontSpace_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferFrontSpace_CallInstance;
  char uxStreamBufferGetSize_IgnoreBool;
  size_t uxStreamBufferGetSize_FinalReturn;
  char uxStreamBufferGetSize_CallbackBool;
  CMOCK_uxStreamBufferGetSize_CALLBACK uxStreamBufferGetSize_CallbackFunctionPointer;
  int uxStreamBufferGetSize_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferGetSize_CallInstance;
  char uxStreamBufferMidSpace_IgnoreBool;
  size_t uxStreamBufferMidSpace_FinalReturn;
  char uxStreamBufferMidSpace_CallbackBool;
  CMOCK_uxStreamBufferMidSpace_CALLBACK uxStreamBufferMidSpace_CallbackFunctionPointer;
  int uxStreamBufferMidSpace_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferMidSpace_CallInstance;
  char vStreamBufferMoveMid_IgnoreBool;
  char vStreamBufferMoveMid_CallbackBool;
  CMOCK_vStreamBufferMoveMid_CALLBACK vStreamBufferMoveMid_CallbackFunctionPointer;
  int vStreamBufferMoveMid_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vStreamBufferMoveMid_CallInstance;
  char xStreamBufferLessThenEqual_IgnoreBool;
  BaseType_t xStreamBufferLessThenEqual_FinalReturn;
  char xStreamBufferLessThenEqual_CallbackBool;
  CMOCK_xStreamBufferLessThenEqual_CALLBACK xStreamBufferLessThenEqual_CallbackFunctionPointer;
  int xStreamBufferLessThenEqual_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xStreamBufferLessThenEqual_CallInstance;
  char uxStreamBufferGetPtr_IgnoreBool;
  size_t uxStreamBufferGetPtr_FinalReturn;
  char uxStreamBufferGetPtr_CallbackBool;
  CMOCK_uxStreamBufferGetPtr_CALLBACK uxStreamBufferGetPtr_CallbackFunctionPointer;
  int uxStreamBufferGetPtr_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferGetPtr_CallInstance;
  char uxStreamBufferAdd_IgnoreBool;
  size_t uxStreamBufferAdd_FinalReturn;
  char uxStreamBufferAdd_CallbackBool;
  CMOCK_uxStreamBufferAdd_CALLBACK uxStreamBufferAdd_CallbackFunctionPointer;
  int uxStreamBufferAdd_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferAdd_CallInstance;
  char uxStreamBufferGet_IgnoreBool;
  size_t uxStreamBufferGet_FinalReturn;
  char uxStreamBufferGet_CallbackBool;
  CMOCK_uxStreamBufferGet_CALLBACK uxStreamBufferGet_CallbackFunctionPointer;
  int uxStreamBufferGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxStreamBufferGet_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_FreeRTOS_Stream_Buffer_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.vStreamBufferClear_CallInstance;
  if (Mock.vStreamBufferClear_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vStreamBufferClear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vStreamBufferClear_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferSpace_CallInstance;
  if (Mock.uxStreamBufferSpace_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferSpace);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferSpace_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferDistance_CallInstance;
  if (Mock.uxStreamBufferDistance_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferDistance);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferDistance_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferGetSpace_CallInstance;
  if (Mock.uxStreamBufferGetSpace_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferGetSpace);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferGetSpace_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferFrontSpace_CallInstance;
  if (Mock.uxStreamBufferFrontSpace_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferFrontSpace);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferFrontSpace_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferGetSize_CallInstance;
  if (Mock.uxStreamBufferGetSize_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferGetSize);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferGetSize_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferMidSpace_CallInstance;
  if (Mock.uxStreamBufferMidSpace_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferMidSpace);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferMidSpace_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vStreamBufferMoveMid_CallInstance;
  if (Mock.vStreamBufferMoveMid_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vStreamBufferMoveMid);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vStreamBufferMoveMid_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xStreamBufferLessThenEqual_CallInstance;
  if (Mock.xStreamBufferLessThenEqual_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xStreamBufferLessThenEqual);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xStreamBufferLessThenEqual_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferGetPtr_CallInstance;
  if (Mock.uxStreamBufferGetPtr_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferGetPtr);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferGetPtr_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferAdd_CallInstance;
  if (Mock.uxStreamBufferAdd_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferAdd);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferAdd_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxStreamBufferGet_CallInstance;
  if (Mock.uxStreamBufferGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxStreamBufferGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxStreamBufferGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_FreeRTOS_Stream_Buffer_Init(void)
{
  mock_FreeRTOS_Stream_Buffer_Destroy();
}

void mock_FreeRTOS_Stream_Buffer_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vStreamBufferClear
#else
void vStreamBufferClear(StreamBuffer_t* pxBuffer) __attribute__((weak));
#endif

void vStreamBufferClear(StreamBuffer_t* pxBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vStreamBufferClear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vStreamBufferClear);
  cmock_call_instance = (CMOCK_vStreamBufferClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vStreamBufferClear_CallInstance);
  Mock.vStreamBufferClear_CallInstance = CMock_Guts_MemNext(Mock.vStreamBufferClear_CallInstance);
  if (Mock.vStreamBufferClear_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vStreamBufferClear_CallbackBool &&
      Mock.vStreamBufferClear_CallbackFunctionPointer != NULL)
  {
    Mock.vStreamBufferClear_CallbackFunctionPointer(pxBuffer, Mock.vStreamBufferClear_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferClear,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vStreamBufferClear_CallbackFunctionPointer != NULL)
  {
    Mock.vStreamBufferClear_CallbackFunctionPointer(pxBuffer, Mock.vStreamBufferClear_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxBuffer, (void*)cmock_call_instance->ReturnThruPtr_pxBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxBuffer_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vStreamBufferClear(CMOCK_vStreamBufferClear_CALL_INSTANCE* cmock_call_instance, StreamBuffer_t* pxBuffer, int pxBuffer_Depth)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 0;
}

void vStreamBufferClear_CMockIgnore(void)
{
  Mock.vStreamBufferClear_IgnoreBool = (char)1;
}

void vStreamBufferClear_CMockStopIgnore(void)
{
  Mock.vStreamBufferClear_IgnoreBool = (char)0;
}

void vStreamBufferClear_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferClear_CALL_INSTANCE));
  CMOCK_vStreamBufferClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferClear_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferClear_CallInstance, cmock_guts_index);
  Mock.vStreamBufferClear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vStreamBufferClear_CMockExpect(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferClear_CALL_INSTANCE));
  CMOCK_vStreamBufferClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferClear_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferClear_CallInstance, cmock_guts_index);
  Mock.vStreamBufferClear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vStreamBufferClear(cmock_call_instance, pxBuffer, 1);
}

void vStreamBufferClear_AddCallback(CMOCK_vStreamBufferClear_CALLBACK Callback)
{
  Mock.vStreamBufferClear_IgnoreBool = (char)0;
  Mock.vStreamBufferClear_CallbackBool = (char)1;
  Mock.vStreamBufferClear_CallbackFunctionPointer = Callback;
}

void vStreamBufferClear_Stub(CMOCK_vStreamBufferClear_CALLBACK Callback)
{
  Mock.vStreamBufferClear_IgnoreBool = (char)0;
  Mock.vStreamBufferClear_CallbackBool = (char)0;
  Mock.vStreamBufferClear_CallbackFunctionPointer = Callback;
}

void vStreamBufferClear_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int pxBuffer_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferClear_CALL_INSTANCE));
  CMOCK_vStreamBufferClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferClear_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferClear_CallInstance, cmock_guts_index);
  Mock.vStreamBufferClear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vStreamBufferClear(cmock_call_instance, pxBuffer, pxBuffer_Depth);
}

void vStreamBufferClear_CMockReturnMemThruPtr_pxBuffer(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int cmock_size)
{
  CMOCK_vStreamBufferClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vStreamBufferClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Val = pxBuffer;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Size = cmock_size;
}

void vStreamBufferClear_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vStreamBufferClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vStreamBufferClear_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferSpace
#else
size_t uxStreamBufferSpace(const StreamBuffer_t* pxBuffer, const size_t uxLower, const size_t uxUpper) __attribute__((weak));
#endif

size_t uxStreamBufferSpace(const StreamBuffer_t* pxBuffer, const size_t uxLower, const size_t uxUpper)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferSpace);
  cmock_call_instance = (CMOCK_uxStreamBufferSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferSpace_CallInstance);
  Mock.uxStreamBufferSpace_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferSpace_CallInstance);
  if (Mock.uxStreamBufferSpace_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferSpace_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferSpace_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferSpace_CallbackBool &&
      Mock.uxStreamBufferSpace_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferSpace_CallbackFunctionPointer(pxBuffer, uxLower, uxUpper, Mock.uxStreamBufferSpace_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferSpace,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(const StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxLower)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferSpace,CMockString_uxLower);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxLower), (void*)(&uxLower), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxUpper)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferSpace,CMockString_uxUpper);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxUpper), (void*)(&uxUpper), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxStreamBufferSpace_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferSpace_CallbackFunctionPointer(pxBuffer, uxLower, uxUpper, Mock.uxStreamBufferSpace_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferSpace(CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, const size_t uxLower, const size_t uxUpper)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxLower), (void*)(&uxLower),
         sizeof(size_t[sizeof(uxLower) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxLower = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxUpper), (void*)(&uxUpper),
         sizeof(size_t[sizeof(uxUpper) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxUpper = 0;
}

void uxStreamBufferSpace_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferSpace_IgnoreBool = (char)1;
}

void uxStreamBufferSpace_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferSpace_IgnoreBool)
    Mock.uxStreamBufferSpace_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferSpace_CallInstance);
  Mock.uxStreamBufferSpace_IgnoreBool = (char)0;
}

void uxStreamBufferSpace_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferSpace_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, const size_t uxLower, const size_t uxUpper, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferSpace(cmock_call_instance, pxBuffer, 1, uxLower, uxUpper);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferSpace_AddCallback(CMOCK_uxStreamBufferSpace_CALLBACK Callback)
{
  Mock.uxStreamBufferSpace_IgnoreBool = (char)0;
  Mock.uxStreamBufferSpace_CallbackBool = (char)1;
  Mock.uxStreamBufferSpace_CallbackFunctionPointer = Callback;
}

void uxStreamBufferSpace_Stub(CMOCK_uxStreamBufferSpace_CALLBACK Callback)
{
  Mock.uxStreamBufferSpace_IgnoreBool = (char)0;
  Mock.uxStreamBufferSpace_CallbackBool = (char)0;
  Mock.uxStreamBufferSpace_CallbackFunctionPointer = Callback;
}

void uxStreamBufferSpace_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, const size_t uxLower, const size_t uxUpper, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferSpace(cmock_call_instance, pxBuffer, pxBuffer_Depth, uxLower, uxUpper);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferSpace_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferSpace_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

void uxStreamBufferSpace_CMockIgnoreArg_uxLower(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferSpace_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxLower = 1;
}

void uxStreamBufferSpace_CMockIgnoreArg_uxUpper(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferSpace_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxUpper = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferDistance
#else
size_t uxStreamBufferDistance(const StreamBuffer_t* pxBuffer, const size_t uxLower, const size_t uxUpper) __attribute__((weak));
#endif

size_t uxStreamBufferDistance(const StreamBuffer_t* pxBuffer, const size_t uxLower, const size_t uxUpper)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferDistance);
  cmock_call_instance = (CMOCK_uxStreamBufferDistance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferDistance_CallInstance);
  Mock.uxStreamBufferDistance_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferDistance_CallInstance);
  if (Mock.uxStreamBufferDistance_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferDistance_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferDistance_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferDistance_CallbackBool &&
      Mock.uxStreamBufferDistance_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferDistance_CallbackFunctionPointer(pxBuffer, uxLower, uxUpper, Mock.uxStreamBufferDistance_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferDistance,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(const StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxLower)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferDistance,CMockString_uxLower);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxLower), (void*)(&uxLower), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxUpper)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferDistance,CMockString_uxUpper);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxUpper), (void*)(&uxUpper), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxStreamBufferDistance_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferDistance_CallbackFunctionPointer(pxBuffer, uxLower, uxUpper, Mock.uxStreamBufferDistance_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferDistance(CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, const size_t uxLower, const size_t uxUpper)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxLower), (void*)(&uxLower),
         sizeof(size_t[sizeof(uxLower) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxLower = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxUpper), (void*)(&uxUpper),
         sizeof(size_t[sizeof(uxUpper) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxUpper = 0;
}

void uxStreamBufferDistance_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferDistance_CALL_INSTANCE));
  CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferDistance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferDistance_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferDistance_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferDistance_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferDistance_IgnoreBool = (char)1;
}

void uxStreamBufferDistance_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferDistance_IgnoreBool)
    Mock.uxStreamBufferDistance_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferDistance_CallInstance);
  Mock.uxStreamBufferDistance_IgnoreBool = (char)0;
}

void uxStreamBufferDistance_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferDistance_CALL_INSTANCE));
  CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferDistance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferDistance_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferDistance_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferDistance_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferDistance_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, const size_t uxLower, const size_t uxUpper, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferDistance_CALL_INSTANCE));
  CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferDistance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferDistance_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferDistance_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferDistance_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferDistance(cmock_call_instance, pxBuffer, 1, uxLower, uxUpper);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferDistance_AddCallback(CMOCK_uxStreamBufferDistance_CALLBACK Callback)
{
  Mock.uxStreamBufferDistance_IgnoreBool = (char)0;
  Mock.uxStreamBufferDistance_CallbackBool = (char)1;
  Mock.uxStreamBufferDistance_CallbackFunctionPointer = Callback;
}

void uxStreamBufferDistance_Stub(CMOCK_uxStreamBufferDistance_CALLBACK Callback)
{
  Mock.uxStreamBufferDistance_IgnoreBool = (char)0;
  Mock.uxStreamBufferDistance_CallbackBool = (char)0;
  Mock.uxStreamBufferDistance_CallbackFunctionPointer = Callback;
}

void uxStreamBufferDistance_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, const size_t uxLower, const size_t uxUpper, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferDistance_CALL_INSTANCE));
  CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferDistance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferDistance_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferDistance_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferDistance_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferDistance(cmock_call_instance, pxBuffer, pxBuffer_Depth, uxLower, uxUpper);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferDistance_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferDistance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferDistance_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

void uxStreamBufferDistance_CMockIgnoreArg_uxLower(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferDistance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferDistance_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxLower = 1;
}

void uxStreamBufferDistance_CMockIgnoreArg_uxUpper(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferDistance_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferDistance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferDistance_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxUpper = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferGetSpace
#else
size_t uxStreamBufferGetSpace(const StreamBuffer_t* pxBuffer) __attribute__((weak));
#endif

size_t uxStreamBufferGetSpace(const StreamBuffer_t* pxBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferGetSpace);
  cmock_call_instance = (CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferGetSpace_CallInstance);
  Mock.uxStreamBufferGetSpace_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGetSpace_CallInstance);
  if (Mock.uxStreamBufferGetSpace_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferGetSpace_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferGetSpace_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferGetSpace_CallbackBool &&
      Mock.uxStreamBufferGetSpace_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferGetSpace_CallbackFunctionPointer(pxBuffer, Mock.uxStreamBufferGetSpace_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGetSpace,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(const StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.uxStreamBufferGetSpace_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferGetSpace_CallbackFunctionPointer(pxBuffer, Mock.uxStreamBufferGetSpace_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferGetSpace(CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE* cmock_call_instance, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
}

void uxStreamBufferGetSpace_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferGetSpace_IgnoreBool = (char)1;
}

void uxStreamBufferGetSpace_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferGetSpace_IgnoreBool)
    Mock.uxStreamBufferGetSpace_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGetSpace_CallInstance);
  Mock.uxStreamBufferGetSpace_IgnoreBool = (char)0;
}

void uxStreamBufferGetSpace_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferGetSpace_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGetSpace(cmock_call_instance, pxBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferGetSpace_AddCallback(CMOCK_uxStreamBufferGetSpace_CALLBACK Callback)
{
  Mock.uxStreamBufferGetSpace_IgnoreBool = (char)0;
  Mock.uxStreamBufferGetSpace_CallbackBool = (char)1;
  Mock.uxStreamBufferGetSpace_CallbackFunctionPointer = Callback;
}

void uxStreamBufferGetSpace_Stub(CMOCK_uxStreamBufferGetSpace_CALLBACK Callback)
{
  Mock.uxStreamBufferGetSpace_IgnoreBool = (char)0;
  Mock.uxStreamBufferGetSpace_CallbackBool = (char)0;
  Mock.uxStreamBufferGetSpace_CallbackFunctionPointer = Callback;
}

void uxStreamBufferGetSpace_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGetSpace(cmock_call_instance, pxBuffer, pxBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferGetSpace_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGetSpace_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferFrontSpace
#else
size_t uxStreamBufferFrontSpace(const StreamBuffer_t* pxBuffer) __attribute__((weak));
#endif

size_t uxStreamBufferFrontSpace(const StreamBuffer_t* pxBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferFrontSpace);
  cmock_call_instance = (CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferFrontSpace_CallInstance);
  Mock.uxStreamBufferFrontSpace_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferFrontSpace_CallInstance);
  if (Mock.uxStreamBufferFrontSpace_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferFrontSpace_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferFrontSpace_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferFrontSpace_CallbackBool &&
      Mock.uxStreamBufferFrontSpace_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferFrontSpace_CallbackFunctionPointer(pxBuffer, Mock.uxStreamBufferFrontSpace_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferFrontSpace,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(const StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.uxStreamBufferFrontSpace_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferFrontSpace_CallbackFunctionPointer(pxBuffer, Mock.uxStreamBufferFrontSpace_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferFrontSpace(CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE* cmock_call_instance, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
}

void uxStreamBufferFrontSpace_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferFrontSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferFrontSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferFrontSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferFrontSpace_IgnoreBool = (char)1;
}

void uxStreamBufferFrontSpace_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferFrontSpace_IgnoreBool)
    Mock.uxStreamBufferFrontSpace_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferFrontSpace_CallInstance);
  Mock.uxStreamBufferFrontSpace_IgnoreBool = (char)0;
}

void uxStreamBufferFrontSpace_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferFrontSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferFrontSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferFrontSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferFrontSpace_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferFrontSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferFrontSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferFrontSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferFrontSpace(cmock_call_instance, pxBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferFrontSpace_AddCallback(CMOCK_uxStreamBufferFrontSpace_CALLBACK Callback)
{
  Mock.uxStreamBufferFrontSpace_IgnoreBool = (char)0;
  Mock.uxStreamBufferFrontSpace_CallbackBool = (char)1;
  Mock.uxStreamBufferFrontSpace_CallbackFunctionPointer = Callback;
}

void uxStreamBufferFrontSpace_Stub(CMOCK_uxStreamBufferFrontSpace_CALLBACK Callback)
{
  Mock.uxStreamBufferFrontSpace_IgnoreBool = (char)0;
  Mock.uxStreamBufferFrontSpace_CallbackBool = (char)0;
  Mock.uxStreamBufferFrontSpace_CallbackFunctionPointer = Callback;
}

void uxStreamBufferFrontSpace_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferFrontSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferFrontSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferFrontSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferFrontSpace(cmock_call_instance, pxBuffer, pxBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferFrontSpace_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferFrontSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferFrontSpace_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferGetSize
#else
size_t uxStreamBufferGetSize(const StreamBuffer_t* pxBuffer) __attribute__((weak));
#endif

size_t uxStreamBufferGetSize(const StreamBuffer_t* pxBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferGetSize_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferGetSize);
  cmock_call_instance = (CMOCK_uxStreamBufferGetSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferGetSize_CallInstance);
  Mock.uxStreamBufferGetSize_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGetSize_CallInstance);
  if (Mock.uxStreamBufferGetSize_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferGetSize_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferGetSize_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferGetSize_CallbackBool &&
      Mock.uxStreamBufferGetSize_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferGetSize_CallbackFunctionPointer(pxBuffer, Mock.uxStreamBufferGetSize_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGetSize,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(const StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.uxStreamBufferGetSize_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferGetSize_CallbackFunctionPointer(pxBuffer, Mock.uxStreamBufferGetSize_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferGetSize(CMOCK_uxStreamBufferGetSize_CALL_INSTANCE* cmock_call_instance, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
}

void uxStreamBufferGetSize_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetSize_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetSize_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetSize_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetSize_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetSize_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferGetSize_IgnoreBool = (char)1;
}

void uxStreamBufferGetSize_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferGetSize_IgnoreBool)
    Mock.uxStreamBufferGetSize_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGetSize_CallInstance);
  Mock.uxStreamBufferGetSize_IgnoreBool = (char)0;
}

void uxStreamBufferGetSize_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetSize_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetSize_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetSize_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetSize_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetSize_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferGetSize_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetSize_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetSize_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetSize_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetSize_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetSize_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGetSize(cmock_call_instance, pxBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferGetSize_AddCallback(CMOCK_uxStreamBufferGetSize_CALLBACK Callback)
{
  Mock.uxStreamBufferGetSize_IgnoreBool = (char)0;
  Mock.uxStreamBufferGetSize_CallbackBool = (char)1;
  Mock.uxStreamBufferGetSize_CallbackFunctionPointer = Callback;
}

void uxStreamBufferGetSize_Stub(CMOCK_uxStreamBufferGetSize_CALLBACK Callback)
{
  Mock.uxStreamBufferGetSize_IgnoreBool = (char)0;
  Mock.uxStreamBufferGetSize_CallbackBool = (char)0;
  Mock.uxStreamBufferGetSize_CallbackFunctionPointer = Callback;
}

void uxStreamBufferGetSize_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetSize_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetSize_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetSize_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetSize_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetSize_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGetSize(cmock_call_instance, pxBuffer, pxBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferGetSize_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGetSize_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetSize_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGetSize_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferMidSpace
#else
size_t uxStreamBufferMidSpace(const StreamBuffer_t* pxBuffer) __attribute__((weak));
#endif

size_t uxStreamBufferMidSpace(const StreamBuffer_t* pxBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferMidSpace);
  cmock_call_instance = (CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferMidSpace_CallInstance);
  Mock.uxStreamBufferMidSpace_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferMidSpace_CallInstance);
  if (Mock.uxStreamBufferMidSpace_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferMidSpace_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferMidSpace_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferMidSpace_CallbackBool &&
      Mock.uxStreamBufferMidSpace_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferMidSpace_CallbackFunctionPointer(pxBuffer, Mock.uxStreamBufferMidSpace_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferMidSpace,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(const StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.uxStreamBufferMidSpace_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferMidSpace_CallbackFunctionPointer(pxBuffer, Mock.uxStreamBufferMidSpace_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferMidSpace(CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE* cmock_call_instance, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
}

void uxStreamBufferMidSpace_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferMidSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferMidSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferMidSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferMidSpace_IgnoreBool = (char)1;
}

void uxStreamBufferMidSpace_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferMidSpace_IgnoreBool)
    Mock.uxStreamBufferMidSpace_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferMidSpace_CallInstance);
  Mock.uxStreamBufferMidSpace_IgnoreBool = (char)0;
}

void uxStreamBufferMidSpace_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferMidSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferMidSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferMidSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferMidSpace_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferMidSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferMidSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferMidSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferMidSpace(cmock_call_instance, pxBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferMidSpace_AddCallback(CMOCK_uxStreamBufferMidSpace_CALLBACK Callback)
{
  Mock.uxStreamBufferMidSpace_IgnoreBool = (char)0;
  Mock.uxStreamBufferMidSpace_CallbackBool = (char)1;
  Mock.uxStreamBufferMidSpace_CallbackFunctionPointer = Callback;
}

void uxStreamBufferMidSpace_Stub(CMOCK_uxStreamBufferMidSpace_CALLBACK Callback)
{
  Mock.uxStreamBufferMidSpace_IgnoreBool = (char)0;
  Mock.uxStreamBufferMidSpace_CallbackBool = (char)0;
  Mock.uxStreamBufferMidSpace_CallbackFunctionPointer = Callback;
}

void uxStreamBufferMidSpace_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE));
  CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferMidSpace_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferMidSpace_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferMidSpace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferMidSpace(cmock_call_instance, pxBuffer, pxBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferMidSpace_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferMidSpace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferMidSpace_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vStreamBufferMoveMid
#else
void vStreamBufferMoveMid(StreamBuffer_t* pxBuffer, size_t uxCount) __attribute__((weak));
#endif

void vStreamBufferMoveMid(StreamBuffer_t* pxBuffer, size_t uxCount)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vStreamBufferMoveMid_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vStreamBufferMoveMid);
  cmock_call_instance = (CMOCK_vStreamBufferMoveMid_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vStreamBufferMoveMid_CallInstance);
  Mock.vStreamBufferMoveMid_CallInstance = CMock_Guts_MemNext(Mock.vStreamBufferMoveMid_CallInstance);
  if (Mock.vStreamBufferMoveMid_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vStreamBufferMoveMid_CallbackBool &&
      Mock.vStreamBufferMoveMid_CallbackFunctionPointer != NULL)
  {
    Mock.vStreamBufferMoveMid_CallbackFunctionPointer(pxBuffer, uxCount, Mock.vStreamBufferMoveMid_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferMoveMid,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxCount)
  {
    UNITY_SET_DETAILS(CMockString_vStreamBufferMoveMid,CMockString_uxCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxCount), (void*)(&uxCount), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vStreamBufferMoveMid_CallbackFunctionPointer != NULL)
  {
    Mock.vStreamBufferMoveMid_CallbackFunctionPointer(pxBuffer, uxCount, Mock.vStreamBufferMoveMid_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxBuffer, (void*)cmock_call_instance->ReturnThruPtr_pxBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxBuffer_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vStreamBufferMoveMid(CMOCK_vStreamBufferMoveMid_CALL_INSTANCE* cmock_call_instance, StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t uxCount)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxCount), (void*)(&uxCount),
         sizeof(size_t[sizeof(uxCount) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxCount = 0;
}

void vStreamBufferMoveMid_CMockIgnore(void)
{
  Mock.vStreamBufferMoveMid_IgnoreBool = (char)1;
}

void vStreamBufferMoveMid_CMockStopIgnore(void)
{
  Mock.vStreamBufferMoveMid_IgnoreBool = (char)0;
}

void vStreamBufferMoveMid_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferMoveMid_CALL_INSTANCE));
  CMOCK_vStreamBufferMoveMid_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferMoveMid_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferMoveMid_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferMoveMid_CallInstance, cmock_guts_index);
  Mock.vStreamBufferMoveMid_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vStreamBufferMoveMid_CMockExpect(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, size_t uxCount)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferMoveMid_CALL_INSTANCE));
  CMOCK_vStreamBufferMoveMid_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferMoveMid_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferMoveMid_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferMoveMid_CallInstance, cmock_guts_index);
  Mock.vStreamBufferMoveMid_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vStreamBufferMoveMid(cmock_call_instance, pxBuffer, 1, uxCount);
}

void vStreamBufferMoveMid_AddCallback(CMOCK_vStreamBufferMoveMid_CALLBACK Callback)
{
  Mock.vStreamBufferMoveMid_IgnoreBool = (char)0;
  Mock.vStreamBufferMoveMid_CallbackBool = (char)1;
  Mock.vStreamBufferMoveMid_CallbackFunctionPointer = Callback;
}

void vStreamBufferMoveMid_Stub(CMOCK_vStreamBufferMoveMid_CALLBACK Callback)
{
  Mock.vStreamBufferMoveMid_IgnoreBool = (char)0;
  Mock.vStreamBufferMoveMid_CallbackBool = (char)0;
  Mock.vStreamBufferMoveMid_CallbackFunctionPointer = Callback;
}

void vStreamBufferMoveMid_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t uxCount)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vStreamBufferMoveMid_CALL_INSTANCE));
  CMOCK_vStreamBufferMoveMid_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferMoveMid_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vStreamBufferMoveMid_CallInstance = CMock_Guts_MemChain(Mock.vStreamBufferMoveMid_CallInstance, cmock_guts_index);
  Mock.vStreamBufferMoveMid_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vStreamBufferMoveMid(cmock_call_instance, pxBuffer, pxBuffer_Depth, uxCount);
}

void vStreamBufferMoveMid_CMockReturnMemThruPtr_pxBuffer(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int cmock_size)
{
  CMOCK_vStreamBufferMoveMid_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferMoveMid_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vStreamBufferMoveMid_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Val = pxBuffer;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Size = cmock_size;
}

void vStreamBufferMoveMid_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vStreamBufferMoveMid_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferMoveMid_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vStreamBufferMoveMid_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

void vStreamBufferMoveMid_CMockIgnoreArg_uxCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vStreamBufferMoveMid_CALL_INSTANCE* cmock_call_instance = (CMOCK_vStreamBufferMoveMid_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vStreamBufferMoveMid_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxCount = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xStreamBufferLessThenEqual
#else
BaseType_t xStreamBufferLessThenEqual(const StreamBuffer_t* pxBuffer, const size_t uxLeft, const size_t uxRight) __attribute__((weak));
#endif

BaseType_t xStreamBufferLessThenEqual(const StreamBuffer_t* pxBuffer, const size_t uxLeft, const size_t uxRight)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xStreamBufferLessThenEqual);
  cmock_call_instance = (CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xStreamBufferLessThenEqual_CallInstance);
  Mock.xStreamBufferLessThenEqual_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferLessThenEqual_CallInstance);
  if (Mock.xStreamBufferLessThenEqual_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xStreamBufferLessThenEqual_FinalReturn;
    memcpy((void*)(&Mock.xStreamBufferLessThenEqual_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xStreamBufferLessThenEqual_CallbackBool &&
      Mock.xStreamBufferLessThenEqual_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xStreamBufferLessThenEqual_CallbackFunctionPointer(pxBuffer, uxLeft, uxRight, Mock.xStreamBufferLessThenEqual_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferLessThenEqual,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(const StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxLeft)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferLessThenEqual,CMockString_uxLeft);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxLeft), (void*)(&uxLeft), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxRight)
  {
    UNITY_SET_DETAILS(CMockString_xStreamBufferLessThenEqual,CMockString_uxRight);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxRight), (void*)(&uxRight), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xStreamBufferLessThenEqual_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xStreamBufferLessThenEqual_CallbackFunctionPointer(pxBuffer, uxLeft, uxRight, Mock.xStreamBufferLessThenEqual_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xStreamBufferLessThenEqual(CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, const size_t uxLeft, const size_t uxRight)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxLeft), (void*)(&uxLeft),
         sizeof(size_t[sizeof(uxLeft) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxLeft = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxRight), (void*)(&uxRight),
         sizeof(size_t[sizeof(uxRight) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxRight = 0;
}

void xStreamBufferLessThenEqual_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE));
  CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferLessThenEqual_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferLessThenEqual_CallInstance, cmock_guts_index);
  Mock.xStreamBufferLessThenEqual_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xStreamBufferLessThenEqual_IgnoreBool = (char)1;
}

void xStreamBufferLessThenEqual_CMockStopIgnore(void)
{
  if(Mock.xStreamBufferLessThenEqual_IgnoreBool)
    Mock.xStreamBufferLessThenEqual_CallInstance = CMock_Guts_MemNext(Mock.xStreamBufferLessThenEqual_CallInstance);
  Mock.xStreamBufferLessThenEqual_IgnoreBool = (char)0;
}

void xStreamBufferLessThenEqual_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE));
  CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferLessThenEqual_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferLessThenEqual_CallInstance, cmock_guts_index);
  Mock.xStreamBufferLessThenEqual_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xStreamBufferLessThenEqual_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, const size_t uxLeft, const size_t uxRight, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE));
  CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferLessThenEqual_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferLessThenEqual_CallInstance, cmock_guts_index);
  Mock.xStreamBufferLessThenEqual_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferLessThenEqual(cmock_call_instance, pxBuffer, 1, uxLeft, uxRight);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xStreamBufferLessThenEqual_AddCallback(CMOCK_xStreamBufferLessThenEqual_CALLBACK Callback)
{
  Mock.xStreamBufferLessThenEqual_IgnoreBool = (char)0;
  Mock.xStreamBufferLessThenEqual_CallbackBool = (char)1;
  Mock.xStreamBufferLessThenEqual_CallbackFunctionPointer = Callback;
}

void xStreamBufferLessThenEqual_Stub(CMOCK_xStreamBufferLessThenEqual_CALLBACK Callback)
{
  Mock.xStreamBufferLessThenEqual_IgnoreBool = (char)0;
  Mock.xStreamBufferLessThenEqual_CallbackBool = (char)0;
  Mock.xStreamBufferLessThenEqual_CallbackFunctionPointer = Callback;
}

void xStreamBufferLessThenEqual_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const StreamBuffer_t* pxBuffer, int pxBuffer_Depth, const size_t uxLeft, const size_t uxRight, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE));
  CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xStreamBufferLessThenEqual_CallInstance = CMock_Guts_MemChain(Mock.xStreamBufferLessThenEqual_CallInstance, cmock_guts_index);
  Mock.xStreamBufferLessThenEqual_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xStreamBufferLessThenEqual(cmock_call_instance, pxBuffer, pxBuffer_Depth, uxLeft, uxRight);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xStreamBufferLessThenEqual_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferLessThenEqual_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

void xStreamBufferLessThenEqual_CMockIgnoreArg_uxLeft(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferLessThenEqual_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxLeft = 1;
}

void xStreamBufferLessThenEqual_CMockIgnoreArg_uxRight(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE* cmock_call_instance = (CMOCK_xStreamBufferLessThenEqual_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xStreamBufferLessThenEqual_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxRight = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferGetPtr
#else
size_t uxStreamBufferGetPtr(StreamBuffer_t* pxBuffer, uint8_t** ppucData) __attribute__((weak));
#endif

size_t uxStreamBufferGetPtr(StreamBuffer_t* pxBuffer, uint8_t** ppucData)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferGetPtr);
  cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferGetPtr_CallInstance);
  Mock.uxStreamBufferGetPtr_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGetPtr_CallInstance);
  if (Mock.uxStreamBufferGetPtr_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferGetPtr_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferGetPtr_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferGetPtr_CallbackBool &&
      Mock.uxStreamBufferGetPtr_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferGetPtr_CallbackFunctionPointer(pxBuffer, ppucData, Mock.uxStreamBufferGetPtr_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGetPtr,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ppucData)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGetPtr,CMockString_ppucData);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppucData, ppucData, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxStreamBufferGetPtr_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferGetPtr_CallbackFunctionPointer(pxBuffer, ppucData, Mock.uxStreamBufferGetPtr_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxBuffer, (void*)cmock_call_instance->ReturnThruPtr_pxBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_ppucData_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppucData, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppucData, (void*)cmock_call_instance->ReturnThruPtr_ppucData_Val,
      cmock_call_instance->ReturnThruPtr_ppucData_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferGetPtr(CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance, StreamBuffer_t* pxBuffer, int pxBuffer_Depth, uint8_t** ppucData, int ppucData_Depth)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 0;
  cmock_call_instance->Expected_ppucData = ppucData;
  cmock_call_instance->Expected_ppucData_Depth = ppucData_Depth;
  cmock_call_instance->IgnoreArg_ppucData = 0;
  cmock_call_instance->ReturnThruPtr_ppucData_Used = 0;
}

void uxStreamBufferGetPtr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetPtr_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetPtr_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetPtr_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferGetPtr_IgnoreBool = (char)1;
}

void uxStreamBufferGetPtr_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferGetPtr_IgnoreBool)
    Mock.uxStreamBufferGetPtr_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGetPtr_CallInstance);
  Mock.uxStreamBufferGetPtr_IgnoreBool = (char)0;
}

void uxStreamBufferGetPtr_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetPtr_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetPtr_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetPtr_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferGetPtr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, uint8_t** ppucData, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetPtr_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetPtr_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetPtr_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGetPtr(cmock_call_instance, pxBuffer, 1, ppucData, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferGetPtr_AddCallback(CMOCK_uxStreamBufferGetPtr_CALLBACK Callback)
{
  Mock.uxStreamBufferGetPtr_IgnoreBool = (char)0;
  Mock.uxStreamBufferGetPtr_CallbackBool = (char)1;
  Mock.uxStreamBufferGetPtr_CallbackFunctionPointer = Callback;
}

void uxStreamBufferGetPtr_Stub(CMOCK_uxStreamBufferGetPtr_CALLBACK Callback)
{
  Mock.uxStreamBufferGetPtr_IgnoreBool = (char)0;
  Mock.uxStreamBufferGetPtr_CallbackBool = (char)0;
  Mock.uxStreamBufferGetPtr_CallbackFunctionPointer = Callback;
}

void uxStreamBufferGetPtr_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int pxBuffer_Depth, uint8_t** ppucData, int ppucData_Depth, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE));
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGetPtr_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGetPtr_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGetPtr_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGetPtr(cmock_call_instance, pxBuffer, pxBuffer_Depth, ppucData, ppucData_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferGetPtr_CMockReturnMemThruPtr_pxBuffer(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int cmock_size)
{
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGetPtr_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Val = pxBuffer;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Size = cmock_size;
}

void uxStreamBufferGetPtr_CMockReturnMemThruPtr_ppucData(UNITY_LINE_TYPE cmock_line, uint8_t** ppucData, int cmock_size)
{
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGetPtr_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppucData_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppucData_Val = ppucData;
  cmock_call_instance->ReturnThruPtr_ppucData_Size = cmock_size;
}

void uxStreamBufferGetPtr_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGetPtr_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

void uxStreamBufferGetPtr_CMockIgnoreArg_ppucData(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGetPtr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGetPtr_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppucData = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferAdd
#else
size_t uxStreamBufferAdd(StreamBuffer_t* pxBuffer, size_t uxOffset, const uint8_t* pucData, size_t uxByteCount) __attribute__((weak));
#endif

size_t uxStreamBufferAdd(StreamBuffer_t* pxBuffer, size_t uxOffset, const uint8_t* pucData, size_t uxByteCount)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferAdd);
  cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferAdd_CallInstance);
  Mock.uxStreamBufferAdd_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferAdd_CallInstance);
  if (Mock.uxStreamBufferAdd_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferAdd_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferAdd_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferAdd_CallbackBool &&
      Mock.uxStreamBufferAdd_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferAdd_CallbackFunctionPointer(pxBuffer, uxOffset, pucData, uxByteCount, Mock.uxStreamBufferAdd_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferAdd,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxOffset)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferAdd,CMockString_uxOffset);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxOffset), (void*)(&uxOffset), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pucData)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferAdd,CMockString_pucData);
    if (cmock_call_instance->Expected_pucData == NULL)
      { UNITY_TEST_ASSERT_NULL(pucData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pucData, pucData, cmock_call_instance->Expected_pucData_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxByteCount)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferAdd,CMockString_uxByteCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxByteCount), (void*)(&uxByteCount), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxStreamBufferAdd_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferAdd_CallbackFunctionPointer(pxBuffer, uxOffset, pucData, uxByteCount, Mock.uxStreamBufferAdd_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxBuffer, (void*)cmock_call_instance->ReturnThruPtr_pxBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferAdd(CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance, StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t uxOffset, const uint8_t* pucData, int pucData_Depth, size_t uxByteCount)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxOffset), (void*)(&uxOffset),
         sizeof(size_t[sizeof(uxOffset) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxOffset = 0;
  cmock_call_instance->Expected_pucData = pucData;
  cmock_call_instance->Expected_pucData_Depth = pucData_Depth;
  cmock_call_instance->IgnoreArg_pucData = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxByteCount), (void*)(&uxByteCount),
         sizeof(size_t[sizeof(uxByteCount) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxByteCount = 0;
}

void uxStreamBufferAdd_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferAdd_CALL_INSTANCE));
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferAdd_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferAdd_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferAdd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferAdd_IgnoreBool = (char)1;
}

void uxStreamBufferAdd_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferAdd_IgnoreBool)
    Mock.uxStreamBufferAdd_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferAdd_CallInstance);
  Mock.uxStreamBufferAdd_IgnoreBool = (char)0;
}

void uxStreamBufferAdd_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferAdd_CALL_INSTANCE));
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferAdd_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferAdd_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferAdd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferAdd_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, size_t uxOffset, const uint8_t* pucData, size_t uxByteCount, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferAdd_CALL_INSTANCE));
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferAdd_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferAdd_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferAdd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferAdd(cmock_call_instance, pxBuffer, 1, uxOffset, pucData, 1, uxByteCount);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferAdd_AddCallback(CMOCK_uxStreamBufferAdd_CALLBACK Callback)
{
  Mock.uxStreamBufferAdd_IgnoreBool = (char)0;
  Mock.uxStreamBufferAdd_CallbackBool = (char)1;
  Mock.uxStreamBufferAdd_CallbackFunctionPointer = Callback;
}

void uxStreamBufferAdd_Stub(CMOCK_uxStreamBufferAdd_CALLBACK Callback)
{
  Mock.uxStreamBufferAdd_IgnoreBool = (char)0;
  Mock.uxStreamBufferAdd_CallbackBool = (char)0;
  Mock.uxStreamBufferAdd_CallbackFunctionPointer = Callback;
}

void uxStreamBufferAdd_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t uxOffset, const uint8_t* pucData, int pucData_Depth, size_t uxByteCount, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferAdd_CALL_INSTANCE));
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferAdd_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferAdd_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferAdd_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferAdd(cmock_call_instance, pxBuffer, pxBuffer_Depth, uxOffset, pucData, pucData_Depth, uxByteCount);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferAdd_CMockReturnMemThruPtr_pxBuffer(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int cmock_size)
{
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferAdd_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Val = pxBuffer;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Size = cmock_size;
}

void uxStreamBufferAdd_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferAdd_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

void uxStreamBufferAdd_CMockIgnoreArg_uxOffset(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferAdd_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxOffset = 1;
}

void uxStreamBufferAdd_CMockIgnoreArg_pucData(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferAdd_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pucData = 1;
}

void uxStreamBufferAdd_CMockIgnoreArg_uxByteCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferAdd_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferAdd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferAdd_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxByteCount = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxStreamBufferGet
#else
size_t uxStreamBufferGet(StreamBuffer_t* pxBuffer, size_t uxOffset, uint8_t* pucData, size_t uxMaxCount, BaseType_t xPeek) __attribute__((weak));
#endif

size_t uxStreamBufferGet(StreamBuffer_t* pxBuffer, size_t uxOffset, uint8_t* pucData, size_t uxMaxCount, BaseType_t xPeek)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxStreamBufferGet);
  cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxStreamBufferGet_CallInstance);
  Mock.uxStreamBufferGet_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGet_CallInstance);
  if (Mock.uxStreamBufferGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxStreamBufferGet_FinalReturn;
    memcpy((void*)(&Mock.uxStreamBufferGet_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(size_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxStreamBufferGet_CallbackBool &&
      Mock.uxStreamBufferGet_CallbackFunctionPointer != NULL)
  {
    size_t cmock_cb_ret = Mock.uxStreamBufferGet_CallbackFunctionPointer(pxBuffer, uxOffset, pucData, uxMaxCount, xPeek, Mock.uxStreamBufferGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxBuffer)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGet,CMockString_pxBuffer);
    if (cmock_call_instance->Expected_pxBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxBuffer), (void*)(pxBuffer), sizeof(StreamBuffer_t), cmock_call_instance->Expected_pxBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxOffset)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGet,CMockString_uxOffset);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxOffset), (void*)(&uxOffset), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pucData)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGet,CMockString_pucData);
    if (cmock_call_instance->Expected_pucData == NULL)
      { UNITY_TEST_ASSERT_NULL(pucData, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pucData, pucData, cmock_call_instance->Expected_pucData_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxMaxCount)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGet,CMockString_uxMaxCount);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xPeek)
  {
    UNITY_SET_DETAILS(CMockString_uxStreamBufferGet,CMockString_xPeek);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xPeek), (void*)(&xPeek), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.uxStreamBufferGet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxStreamBufferGet_CallbackFunctionPointer(pxBuffer, uxOffset, pucData, uxMaxCount, xPeek, Mock.uxStreamBufferGet_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxBuffer, (void*)cmock_call_instance->ReturnThruPtr_pxBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pucData_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pucData, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pucData, (void*)cmock_call_instance->ReturnThruPtr_pucData_Val,
      cmock_call_instance->ReturnThruPtr_pucData_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxStreamBufferGet(CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance, StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t uxOffset, uint8_t* pucData, int pucData_Depth, size_t uxMaxCount, BaseType_t xPeek)
{
  cmock_call_instance->Expected_pxBuffer = pxBuffer;
  cmock_call_instance->Expected_pxBuffer_Depth = pxBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxOffset), (void*)(&uxOffset),
         sizeof(size_t[sizeof(uxOffset) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxOffset = 0;
  cmock_call_instance->Expected_pucData = pucData;
  cmock_call_instance->Expected_pucData_Depth = pucData_Depth;
  cmock_call_instance->IgnoreArg_pucData = 0;
  cmock_call_instance->ReturnThruPtr_pucData_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxMaxCount), (void*)(&uxMaxCount),
         sizeof(size_t[sizeof(uxMaxCount) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxMaxCount = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xPeek), (void*)(&xPeek),
         sizeof(BaseType_t[sizeof(xPeek) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xPeek = 0;
}

void uxStreamBufferGet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGet_CALL_INSTANCE));
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGet_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGet_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxStreamBufferGet_IgnoreBool = (char)1;
}

void uxStreamBufferGet_CMockStopIgnore(void)
{
  if(Mock.uxStreamBufferGet_IgnoreBool)
    Mock.uxStreamBufferGet_CallInstance = CMock_Guts_MemNext(Mock.uxStreamBufferGet_CallInstance);
  Mock.uxStreamBufferGet_IgnoreBool = (char)0;
}

void uxStreamBufferGet_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGet_CALL_INSTANCE));
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGet_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGet_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxStreamBufferGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, size_t uxOffset, uint8_t* pucData, size_t uxMaxCount, BaseType_t xPeek, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGet_CALL_INSTANCE));
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGet_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGet_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGet(cmock_call_instance, pxBuffer, 1, uxOffset, pucData, 1, uxMaxCount, xPeek);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void uxStreamBufferGet_AddCallback(CMOCK_uxStreamBufferGet_CALLBACK Callback)
{
  Mock.uxStreamBufferGet_IgnoreBool = (char)0;
  Mock.uxStreamBufferGet_CallbackBool = (char)1;
  Mock.uxStreamBufferGet_CallbackFunctionPointer = Callback;
}

void uxStreamBufferGet_Stub(CMOCK_uxStreamBufferGet_CALLBACK Callback)
{
  Mock.uxStreamBufferGet_IgnoreBool = (char)0;
  Mock.uxStreamBufferGet_CallbackBool = (char)0;
  Mock.uxStreamBufferGet_CallbackFunctionPointer = Callback;
}

void uxStreamBufferGet_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int pxBuffer_Depth, size_t uxOffset, uint8_t* pucData, int pucData_Depth, size_t uxMaxCount, BaseType_t xPeek, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxStreamBufferGet_CALL_INSTANCE));
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxStreamBufferGet_CallInstance = CMock_Guts_MemChain(Mock.uxStreamBufferGet_CallInstance, cmock_guts_index);
  Mock.uxStreamBufferGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxStreamBufferGet(cmock_call_instance, pxBuffer, pxBuffer_Depth, uxOffset, pucData, pucData_Depth, uxMaxCount, xPeek);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxStreamBufferGet_CMockReturnMemThruPtr_pxBuffer(UNITY_LINE_TYPE cmock_line, StreamBuffer_t* pxBuffer, int cmock_size)
{
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Val = pxBuffer;
  cmock_call_instance->ReturnThruPtr_pxBuffer_Size = cmock_size;
}

void uxStreamBufferGet_CMockReturnMemThruPtr_pucData(UNITY_LINE_TYPE cmock_line, uint8_t* pucData, int cmock_size)
{
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pucData_Used = 1;
  cmock_call_instance->ReturnThruPtr_pucData_Val = pucData;
  cmock_call_instance->ReturnThruPtr_pucData_Size = cmock_size;
}

void uxStreamBufferGet_CMockIgnoreArg_pxBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxBuffer = 1;
}

void uxStreamBufferGet_CMockIgnoreArg_uxOffset(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxOffset = 1;
}

void uxStreamBufferGet_CMockIgnoreArg_pucData(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pucData = 1;
}

void uxStreamBufferGet_CMockIgnoreArg_uxMaxCount(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxMaxCount = 1;
}

void uxStreamBufferGet_CMockIgnoreArg_xPeek(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxStreamBufferGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxStreamBufferGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxStreamBufferGet_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xPeek = 1;
}

