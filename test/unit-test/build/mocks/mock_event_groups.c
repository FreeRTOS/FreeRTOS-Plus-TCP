/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_event_groups.h"

static const char* CMockString_pvEventGroup = "pvEventGroup";
static const char* CMockString_pxEventGroupBuffer = "pxEventGroupBuffer";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_ulBitsToClear = "ulBitsToClear";
static const char* CMockString_ulBitsToSet = "ulBitsToSet";
static const char* CMockString_uxBitsToClear = "uxBitsToClear";
static const char* CMockString_uxBitsToSet = "uxBitsToSet";
static const char* CMockString_uxBitsToWaitFor = "uxBitsToWaitFor";
static const char* CMockString_uxEventGroupGetNumber = "uxEventGroupGetNumber";
static const char* CMockString_uxEventGroupNumber = "uxEventGroupNumber";
static const char* CMockString_vEventGroupClearBitsCallback = "vEventGroupClearBitsCallback";
static const char* CMockString_vEventGroupDelete = "vEventGroupDelete";
static const char* CMockString_vEventGroupSetBitsCallback = "vEventGroupSetBitsCallback";
static const char* CMockString_vEventGroupSetNumber = "vEventGroupSetNumber";
static const char* CMockString_xClearOnExit = "xClearOnExit";
static const char* CMockString_xEventGroup = "xEventGroup";
static const char* CMockString_xEventGroupClearBits = "xEventGroupClearBits";
static const char* CMockString_xEventGroupClearBitsFromISR = "xEventGroupClearBitsFromISR";
static const char* CMockString_xEventGroupCreate = "xEventGroupCreate";
static const char* CMockString_xEventGroupCreateStatic = "xEventGroupCreateStatic";
static const char* CMockString_xEventGroupGetBitsFromISR = "xEventGroupGetBitsFromISR";
static const char* CMockString_xEventGroupSetBits = "xEventGroupSetBits";
static const char* CMockString_xEventGroupSetBitsFromISR = "xEventGroupSetBitsFromISR";
static const char* CMockString_xEventGroupSync = "xEventGroupSync";
static const char* CMockString_xEventGroupWaitBits = "xEventGroupWaitBits";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xWaitForAllBits = "xWaitForAllBits";

typedef struct _CMOCK_xEventGroupCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  EventGroupHandle_t ReturnVal;
  int CallOrder;

} CMOCK_xEventGroupCreate_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  EventGroupHandle_t ReturnVal;
  int CallOrder;
  StaticEventGroup_t* Expected_pxEventGroupBuffer;
  int Expected_pxEventGroupBuffer_Depth;
  char ReturnThruPtr_pxEventGroupBuffer_Used;
  StaticEventGroup_t* ReturnThruPtr_pxEventGroupBuffer_Val;
  int ReturnThruPtr_pxEventGroupBuffer_Size;
  char IgnoreArg_pxEventGroupBuffer;

} CMOCK_xEventGroupCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupWaitBits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  EventBits_t ReturnVal;
  int CallOrder;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToWaitFor;
  BaseType_t Expected_xClearOnExit;
  BaseType_t Expected_xWaitForAllBits;
  TickType_t Expected_xTicksToWait;
  char IgnoreArg_xEventGroup;
  char IgnoreArg_uxBitsToWaitFor;
  char IgnoreArg_xClearOnExit;
  char IgnoreArg_xWaitForAllBits;
  char IgnoreArg_xTicksToWait;

} CMOCK_xEventGroupWaitBits_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupClearBits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  EventBits_t ReturnVal;
  int CallOrder;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToClear;
  char IgnoreArg_xEventGroup;
  char IgnoreArg_uxBitsToClear;

} CMOCK_xEventGroupClearBits_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToClear;
  char IgnoreArg_xEventGroup;
  char IgnoreArg_uxBitsToClear;

} CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupSetBits_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  EventBits_t ReturnVal;
  int CallOrder;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToSet;
  char IgnoreArg_xEventGroup;
  char IgnoreArg_uxBitsToSet;

} CMOCK_xEventGroupSetBits_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToSet;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char ReturnThruPtr_pxHigherPriorityTaskWoken_Used;
  BaseType_t* ReturnThruPtr_pxHigherPriorityTaskWoken_Val;
  int ReturnThruPtr_pxHigherPriorityTaskWoken_Size;
  char IgnoreArg_xEventGroup;
  char IgnoreArg_uxBitsToSet;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupSync_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  EventBits_t ReturnVal;
  int CallOrder;
  EventGroupHandle_t Expected_xEventGroup;
  EventBits_t Expected_uxBitsToSet;
  EventBits_t Expected_uxBitsToWaitFor;
  TickType_t Expected_xTicksToWait;
  char IgnoreArg_xEventGroup;
  char IgnoreArg_uxBitsToSet;
  char IgnoreArg_uxBitsToWaitFor;
  char IgnoreArg_xTicksToWait;

} CMOCK_xEventGroupSync_CALL_INSTANCE;

typedef struct _CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  EventBits_t ReturnVal;
  int CallOrder;
  EventGroupHandle_t Expected_xEventGroup;
  char IgnoreArg_xEventGroup;

} CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vEventGroupDelete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  EventGroupHandle_t Expected_xEventGroup;
  char IgnoreArg_xEventGroup;

} CMOCK_vEventGroupDelete_CALL_INSTANCE;

typedef struct _CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  void* Expected_pvEventGroup;
  uint32_t Expected_ulBitsToSet;
  int Expected_pvEventGroup_Depth;
  char ReturnThruPtr_pvEventGroup_Used;
  void* ReturnThruPtr_pvEventGroup_Val;
  int ReturnThruPtr_pvEventGroup_Size;
  char IgnoreArg_pvEventGroup;
  char IgnoreArg_ulBitsToSet;

} CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE;

typedef struct _CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  void* Expected_pvEventGroup;
  uint32_t Expected_ulBitsToClear;
  int Expected_pvEventGroup_Depth;
  char ReturnThruPtr_pvEventGroup_Used;
  void* ReturnThruPtr_pvEventGroup_Val;
  int ReturnThruPtr_pvEventGroup_Size;
  char IgnoreArg_pvEventGroup;
  char IgnoreArg_ulBitsToClear;

} CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE;

typedef struct _CMOCK_uxEventGroupGetNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  UBaseType_t ReturnVal;
  int CallOrder;
  void* Expected_xEventGroup;
  int Expected_xEventGroup_Depth;
  char ReturnThruPtr_xEventGroup_Used;
  void* ReturnThruPtr_xEventGroup_Val;
  int ReturnThruPtr_xEventGroup_Size;
  char IgnoreArg_xEventGroup;

} CMOCK_uxEventGroupGetNumber_CALL_INSTANCE;

typedef struct _CMOCK_vEventGroupSetNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  void* Expected_xEventGroup;
  UBaseType_t Expected_uxEventGroupNumber;
  int Expected_xEventGroup_Depth;
  char ReturnThruPtr_xEventGroup_Used;
  void* ReturnThruPtr_xEventGroup_Val;
  int ReturnThruPtr_xEventGroup_Size;
  char IgnoreArg_xEventGroup;
  char IgnoreArg_uxEventGroupNumber;

} CMOCK_vEventGroupSetNumber_CALL_INSTANCE;

static struct mock_event_groupsInstance
{
  char xEventGroupCreate_IgnoreBool;
  EventGroupHandle_t xEventGroupCreate_FinalReturn;
  char xEventGroupCreate_CallbackBool;
  CMOCK_xEventGroupCreate_CALLBACK xEventGroupCreate_CallbackFunctionPointer;
  int xEventGroupCreate_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupCreate_CallInstance;
  char xEventGroupCreateStatic_IgnoreBool;
  EventGroupHandle_t xEventGroupCreateStatic_FinalReturn;
  char xEventGroupCreateStatic_CallbackBool;
  CMOCK_xEventGroupCreateStatic_CALLBACK xEventGroupCreateStatic_CallbackFunctionPointer;
  int xEventGroupCreateStatic_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupCreateStatic_CallInstance;
  char xEventGroupWaitBits_IgnoreBool;
  EventBits_t xEventGroupWaitBits_FinalReturn;
  char xEventGroupWaitBits_CallbackBool;
  CMOCK_xEventGroupWaitBits_CALLBACK xEventGroupWaitBits_CallbackFunctionPointer;
  int xEventGroupWaitBits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupWaitBits_CallInstance;
  char xEventGroupClearBits_IgnoreBool;
  EventBits_t xEventGroupClearBits_FinalReturn;
  char xEventGroupClearBits_CallbackBool;
  CMOCK_xEventGroupClearBits_CALLBACK xEventGroupClearBits_CallbackFunctionPointer;
  int xEventGroupClearBits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupClearBits_CallInstance;
  char xEventGroupClearBitsFromISR_IgnoreBool;
  BaseType_t xEventGroupClearBitsFromISR_FinalReturn;
  char xEventGroupClearBitsFromISR_CallbackBool;
  CMOCK_xEventGroupClearBitsFromISR_CALLBACK xEventGroupClearBitsFromISR_CallbackFunctionPointer;
  int xEventGroupClearBitsFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupClearBitsFromISR_CallInstance;
  char xEventGroupSetBits_IgnoreBool;
  EventBits_t xEventGroupSetBits_FinalReturn;
  char xEventGroupSetBits_CallbackBool;
  CMOCK_xEventGroupSetBits_CALLBACK xEventGroupSetBits_CallbackFunctionPointer;
  int xEventGroupSetBits_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupSetBits_CallInstance;
  char xEventGroupSetBitsFromISR_IgnoreBool;
  BaseType_t xEventGroupSetBitsFromISR_FinalReturn;
  char xEventGroupSetBitsFromISR_CallbackBool;
  CMOCK_xEventGroupSetBitsFromISR_CALLBACK xEventGroupSetBitsFromISR_CallbackFunctionPointer;
  int xEventGroupSetBitsFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupSetBitsFromISR_CallInstance;
  char xEventGroupSync_IgnoreBool;
  EventBits_t xEventGroupSync_FinalReturn;
  char xEventGroupSync_CallbackBool;
  CMOCK_xEventGroupSync_CALLBACK xEventGroupSync_CallbackFunctionPointer;
  int xEventGroupSync_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupSync_CallInstance;
  char xEventGroupGetBitsFromISR_IgnoreBool;
  EventBits_t xEventGroupGetBitsFromISR_FinalReturn;
  char xEventGroupGetBitsFromISR_CallbackBool;
  CMOCK_xEventGroupGetBitsFromISR_CALLBACK xEventGroupGetBitsFromISR_CallbackFunctionPointer;
  int xEventGroupGetBitsFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xEventGroupGetBitsFromISR_CallInstance;
  char vEventGroupDelete_IgnoreBool;
  char vEventGroupDelete_CallbackBool;
  CMOCK_vEventGroupDelete_CALLBACK vEventGroupDelete_CallbackFunctionPointer;
  int vEventGroupDelete_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vEventGroupDelete_CallInstance;
  char vEventGroupSetBitsCallback_IgnoreBool;
  char vEventGroupSetBitsCallback_CallbackBool;
  CMOCK_vEventGroupSetBitsCallback_CALLBACK vEventGroupSetBitsCallback_CallbackFunctionPointer;
  int vEventGroupSetBitsCallback_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vEventGroupSetBitsCallback_CallInstance;
  char vEventGroupClearBitsCallback_IgnoreBool;
  char vEventGroupClearBitsCallback_CallbackBool;
  CMOCK_vEventGroupClearBitsCallback_CALLBACK vEventGroupClearBitsCallback_CallbackFunctionPointer;
  int vEventGroupClearBitsCallback_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vEventGroupClearBitsCallback_CallInstance;
  char uxEventGroupGetNumber_IgnoreBool;
  UBaseType_t uxEventGroupGetNumber_FinalReturn;
  char uxEventGroupGetNumber_CallbackBool;
  CMOCK_uxEventGroupGetNumber_CALLBACK uxEventGroupGetNumber_CallbackFunctionPointer;
  int uxEventGroupGetNumber_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxEventGroupGetNumber_CallInstance;
  char vEventGroupSetNumber_IgnoreBool;
  char vEventGroupSetNumber_CallbackBool;
  CMOCK_vEventGroupSetNumber_CALLBACK vEventGroupSetNumber_CallbackFunctionPointer;
  int vEventGroupSetNumber_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vEventGroupSetNumber_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_event_groups_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xEventGroupCreate_CallInstance;
  if (Mock.xEventGroupCreate_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupCreate_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xEventGroupCreateStatic_CallInstance;
  if (Mock.xEventGroupCreateStatic_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupCreateStatic_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xEventGroupWaitBits_CallInstance;
  if (Mock.xEventGroupWaitBits_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupWaitBits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupWaitBits_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xEventGroupClearBits_CallInstance;
  if (Mock.xEventGroupClearBits_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupClearBits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupClearBits_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xEventGroupClearBitsFromISR_CallInstance;
  if (Mock.xEventGroupClearBitsFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupClearBitsFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupClearBitsFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xEventGroupSetBits_CallInstance;
  if (Mock.xEventGroupSetBits_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupSetBits);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupSetBits_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xEventGroupSetBitsFromISR_CallInstance;
  if (Mock.xEventGroupSetBitsFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupSetBitsFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupSetBitsFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xEventGroupSync_CallInstance;
  if (Mock.xEventGroupSync_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupSync);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupSync_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xEventGroupGetBitsFromISR_CallInstance;
  if (Mock.xEventGroupGetBitsFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xEventGroupGetBitsFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xEventGroupGetBitsFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vEventGroupDelete_CallInstance;
  if (Mock.vEventGroupDelete_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEventGroupDelete);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vEventGroupDelete_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vEventGroupSetBitsCallback_CallInstance;
  if (Mock.vEventGroupSetBitsCallback_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEventGroupSetBitsCallback);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vEventGroupSetBitsCallback_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vEventGroupClearBitsCallback_CallInstance;
  if (Mock.vEventGroupClearBitsCallback_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEventGroupClearBitsCallback);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vEventGroupClearBitsCallback_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxEventGroupGetNumber_CallInstance;
  if (Mock.uxEventGroupGetNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxEventGroupGetNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxEventGroupGetNumber_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vEventGroupSetNumber_CallInstance;
  if (Mock.vEventGroupSetNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vEventGroupSetNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vEventGroupSetNumber_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_event_groups_Init(void)
{
  mock_event_groups_Destroy();
}

void mock_event_groups_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupCreate
#else
EventGroupHandle_t xEventGroupCreate(void) __attribute__((weak));
#endif

EventGroupHandle_t xEventGroupCreate(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupCreate);
  cmock_call_instance = (CMOCK_xEventGroupCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupCreate_CallInstance);
  Mock.xEventGroupCreate_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupCreate_CallInstance);
  if (Mock.xEventGroupCreate_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupCreate_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupCreate_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(EventGroupHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupCreate_CallbackBool &&
      Mock.xEventGroupCreate_CallbackFunctionPointer != NULL)
  {
    EventGroupHandle_t cmock_cb_ret = Mock.xEventGroupCreate_CallbackFunctionPointer(Mock.xEventGroupCreate_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.xEventGroupCreate_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupCreate_CallbackFunctionPointer(Mock.xEventGroupCreate_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xEventGroupCreate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupCreate_CALL_INSTANCE));
  CMOCK_xEventGroupCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupCreate_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupCreate_CallInstance, cmock_guts_index);
  Mock.xEventGroupCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupCreate_IgnoreBool = (char)1;
}

void xEventGroupCreate_CMockStopIgnore(void)
{
  if(Mock.xEventGroupCreate_IgnoreBool)
    Mock.xEventGroupCreate_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupCreate_CallInstance);
  Mock.xEventGroupCreate_IgnoreBool = (char)0;
}

void xEventGroupCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupCreate_CALL_INSTANCE));
  CMOCK_xEventGroupCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupCreate_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupCreate_CallInstance, cmock_guts_index);
  Mock.xEventGroupCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventGroupHandle_t[sizeof(cmock_to_return) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
}

void xEventGroupCreate_AddCallback(CMOCK_xEventGroupCreate_CALLBACK Callback)
{
  Mock.xEventGroupCreate_IgnoreBool = (char)0;
  Mock.xEventGroupCreate_CallbackBool = (char)1;
  Mock.xEventGroupCreate_CallbackFunctionPointer = Callback;
}

void xEventGroupCreate_Stub(CMOCK_xEventGroupCreate_CALLBACK Callback)
{
  Mock.xEventGroupCreate_IgnoreBool = (char)0;
  Mock.xEventGroupCreate_CallbackBool = (char)0;
  Mock.xEventGroupCreate_CallbackFunctionPointer = Callback;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupCreateStatic
#else
EventGroupHandle_t xEventGroupCreateStatic(StaticEventGroup_t* pxEventGroupBuffer) __attribute__((weak));
#endif

EventGroupHandle_t xEventGroupCreateStatic(StaticEventGroup_t* pxEventGroupBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupCreateStatic);
  cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupCreateStatic_CallInstance);
  Mock.xEventGroupCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupCreateStatic_CallInstance);
  if (Mock.xEventGroupCreateStatic_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupCreateStatic_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupCreateStatic_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(EventGroupHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupCreateStatic_CallbackBool &&
      Mock.xEventGroupCreateStatic_CallbackFunctionPointer != NULL)
  {
    EventGroupHandle_t cmock_cb_ret = Mock.xEventGroupCreateStatic_CallbackFunctionPointer(pxEventGroupBuffer, Mock.xEventGroupCreateStatic_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxEventGroupBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupCreateStatic,CMockString_pxEventGroupBuffer);
    if (cmock_call_instance->Expected_pxEventGroupBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxEventGroupBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxEventGroupBuffer), (void*)(pxEventGroupBuffer), sizeof(StaticEventGroup_t), cmock_call_instance->Expected_pxEventGroupBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xEventGroupCreateStatic_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupCreateStatic_CallbackFunctionPointer(pxEventGroupBuffer, Mock.xEventGroupCreateStatic_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxEventGroupBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxEventGroupBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxEventGroupBuffer, (void*)cmock_call_instance->ReturnThruPtr_pxEventGroupBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxEventGroupBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupCreateStatic(CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance, StaticEventGroup_t* pxEventGroupBuffer, int pxEventGroupBuffer_Depth)
{
  cmock_call_instance->Expected_pxEventGroupBuffer = pxEventGroupBuffer;
  cmock_call_instance->Expected_pxEventGroupBuffer_Depth = pxEventGroupBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxEventGroupBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxEventGroupBuffer_Used = 0;
}

void xEventGroupCreateStatic_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupCreateStatic_CALL_INSTANCE));
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupCreateStatic_CallInstance, cmock_guts_index);
  Mock.xEventGroupCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupCreateStatic_IgnoreBool = (char)1;
}

void xEventGroupCreateStatic_CMockStopIgnore(void)
{
  if(Mock.xEventGroupCreateStatic_IgnoreBool)
    Mock.xEventGroupCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupCreateStatic_CallInstance);
  Mock.xEventGroupCreateStatic_IgnoreBool = (char)0;
}

void xEventGroupCreateStatic_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupCreateStatic_CALL_INSTANCE));
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupCreateStatic_CallInstance, cmock_guts_index);
  Mock.xEventGroupCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xEventGroupCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, StaticEventGroup_t* pxEventGroupBuffer, EventGroupHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupCreateStatic_CALL_INSTANCE));
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupCreateStatic_CallInstance, cmock_guts_index);
  Mock.xEventGroupCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupCreateStatic(cmock_call_instance, pxEventGroupBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventGroupHandle_t[sizeof(cmock_to_return) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
}

void xEventGroupCreateStatic_AddCallback(CMOCK_xEventGroupCreateStatic_CALLBACK Callback)
{
  Mock.xEventGroupCreateStatic_IgnoreBool = (char)0;
  Mock.xEventGroupCreateStatic_CallbackBool = (char)1;
  Mock.xEventGroupCreateStatic_CallbackFunctionPointer = Callback;
}

void xEventGroupCreateStatic_Stub(CMOCK_xEventGroupCreateStatic_CALLBACK Callback)
{
  Mock.xEventGroupCreateStatic_IgnoreBool = (char)0;
  Mock.xEventGroupCreateStatic_CallbackBool = (char)0;
  Mock.xEventGroupCreateStatic_CallbackFunctionPointer = Callback;
}

void xEventGroupCreateStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, StaticEventGroup_t* pxEventGroupBuffer, int pxEventGroupBuffer_Depth, EventGroupHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupCreateStatic_CALL_INSTANCE));
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupCreateStatic_CallInstance, cmock_guts_index);
  Mock.xEventGroupCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupCreateStatic(cmock_call_instance, pxEventGroupBuffer, pxEventGroupBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xEventGroupCreateStatic_CMockReturnMemThruPtr_pxEventGroupBuffer(UNITY_LINE_TYPE cmock_line, StaticEventGroup_t* pxEventGroupBuffer, int cmock_size)
{
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxEventGroupBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxEventGroupBuffer_Val = pxEventGroupBuffer;
  cmock_call_instance->ReturnThruPtr_pxEventGroupBuffer_Size = cmock_size;
}

void xEventGroupCreateStatic_CMockIgnoreArg_pxEventGroupBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxEventGroupBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupWaitBits
#else
EventBits_t xEventGroupWaitBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait) __attribute__((weak));
#endif

EventBits_t xEventGroupWaitBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupWaitBits);
  cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupWaitBits_CallInstance);
  Mock.xEventGroupWaitBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupWaitBits_CallInstance);
  if (Mock.xEventGroupWaitBits_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupWaitBits_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupWaitBits_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(EventBits_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupWaitBits_CallbackBool &&
      Mock.xEventGroupWaitBits_CallbackFunctionPointer != NULL)
  {
    EventBits_t cmock_cb_ret = Mock.xEventGroupWaitBits_CallbackFunctionPointer(xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait, Mock.xEventGroupWaitBits_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBitsToWaitFor)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_uxBitsToWaitFor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToWaitFor), (void*)(&uxBitsToWaitFor), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xClearOnExit)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_xClearOnExit);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xClearOnExit), (void*)(&xClearOnExit), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xWaitForAllBits)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_xWaitForAllBits);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xWaitForAllBits), (void*)(&xWaitForAllBits), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupWaitBits,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xEventGroupWaitBits_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupWaitBits_CallbackFunctionPointer(xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait, Mock.xEventGroupWaitBits_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupWaitBits(CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToWaitFor), (void*)(&uxBitsToWaitFor),
         sizeof(EventBits_t[sizeof(uxBitsToWaitFor) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBitsToWaitFor = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xClearOnExit), (void*)(&xClearOnExit),
         sizeof(BaseType_t[sizeof(xClearOnExit) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xClearOnExit = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xWaitForAllBits), (void*)(&xWaitForAllBits),
         sizeof(BaseType_t[sizeof(xWaitForAllBits) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xWaitForAllBits = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xEventGroupWaitBits_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupWaitBits_CALL_INSTANCE));
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupWaitBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupWaitBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupWaitBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupWaitBits_IgnoreBool = (char)1;
}

void xEventGroupWaitBits_CMockStopIgnore(void)
{
  if(Mock.xEventGroupWaitBits_IgnoreBool)
    Mock.xEventGroupWaitBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupWaitBits_CallInstance);
  Mock.xEventGroupWaitBits_IgnoreBool = (char)0;
}

void xEventGroupWaitBits_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupWaitBits_CALL_INSTANCE));
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupWaitBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupWaitBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupWaitBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xEventGroupWaitBits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupWaitBits_CALL_INSTANCE));
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupWaitBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupWaitBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupWaitBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupWaitBits(cmock_call_instance, xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void xEventGroupWaitBits_AddCallback(CMOCK_xEventGroupWaitBits_CALLBACK Callback)
{
  Mock.xEventGroupWaitBits_IgnoreBool = (char)0;
  Mock.xEventGroupWaitBits_CallbackBool = (char)1;
  Mock.xEventGroupWaitBits_CallbackFunctionPointer = Callback;
}

void xEventGroupWaitBits_Stub(CMOCK_xEventGroupWaitBits_CALLBACK Callback)
{
  Mock.xEventGroupWaitBits_IgnoreBool = (char)0;
  Mock.xEventGroupWaitBits_CallbackBool = (char)0;
  Mock.xEventGroupWaitBits_CallbackFunctionPointer = Callback;
}

void xEventGroupWaitBits_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupWaitBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

void xEventGroupWaitBits_CMockIgnoreArg_uxBitsToWaitFor(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupWaitBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBitsToWaitFor = 1;
}

void xEventGroupWaitBits_CMockIgnoreArg_xClearOnExit(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupWaitBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xClearOnExit = 1;
}

void xEventGroupWaitBits_CMockIgnoreArg_xWaitForAllBits(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupWaitBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xWaitForAllBits = 1;
}

void xEventGroupWaitBits_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupWaitBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupWaitBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupWaitBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupClearBits
#else
EventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear) __attribute__((weak));
#endif

EventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupClearBits);
  cmock_call_instance = (CMOCK_xEventGroupClearBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupClearBits_CallInstance);
  Mock.xEventGroupClearBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupClearBits_CallInstance);
  if (Mock.xEventGroupClearBits_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupClearBits_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupClearBits_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(EventBits_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupClearBits_CallbackBool &&
      Mock.xEventGroupClearBits_CallbackFunctionPointer != NULL)
  {
    EventBits_t cmock_cb_ret = Mock.xEventGroupClearBits_CallbackFunctionPointer(xEventGroup, uxBitsToClear, Mock.xEventGroupClearBits_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupClearBits,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBitsToClear)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupClearBits,CMockString_uxBitsToClear);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToClear), (void*)(&uxBitsToClear), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xEventGroupClearBits_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupClearBits_CallbackFunctionPointer(xEventGroup, uxBitsToClear, Mock.xEventGroupClearBits_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupClearBits(CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToClear), (void*)(&uxBitsToClear),
         sizeof(EventBits_t[sizeof(uxBitsToClear) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBitsToClear = 0;
}

void xEventGroupClearBits_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupClearBits_CALL_INSTANCE));
  CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupClearBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupClearBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupClearBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupClearBits_IgnoreBool = (char)1;
}

void xEventGroupClearBits_CMockStopIgnore(void)
{
  if(Mock.xEventGroupClearBits_IgnoreBool)
    Mock.xEventGroupClearBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupClearBits_CallInstance);
  Mock.xEventGroupClearBits_IgnoreBool = (char)0;
}

void xEventGroupClearBits_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupClearBits_CALL_INSTANCE));
  CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupClearBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupClearBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupClearBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xEventGroupClearBits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupClearBits_CALL_INSTANCE));
  CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupClearBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupClearBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupClearBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupClearBits(cmock_call_instance, xEventGroup, uxBitsToClear);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void xEventGroupClearBits_AddCallback(CMOCK_xEventGroupClearBits_CALLBACK Callback)
{
  Mock.xEventGroupClearBits_IgnoreBool = (char)0;
  Mock.xEventGroupClearBits_CallbackBool = (char)1;
  Mock.xEventGroupClearBits_CallbackFunctionPointer = Callback;
}

void xEventGroupClearBits_Stub(CMOCK_xEventGroupClearBits_CALLBACK Callback)
{
  Mock.xEventGroupClearBits_IgnoreBool = (char)0;
  Mock.xEventGroupClearBits_CallbackBool = (char)0;
  Mock.xEventGroupClearBits_CallbackFunctionPointer = Callback;
}

void xEventGroupClearBits_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupClearBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

void xEventGroupClearBits_CMockIgnoreArg_uxBitsToClear(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupClearBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupClearBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBitsToClear = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupClearBitsFromISR
#else
BaseType_t xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear) __attribute__((weak));
#endif

BaseType_t xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupClearBitsFromISR);
  cmock_call_instance = (CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupClearBitsFromISR_CallInstance);
  Mock.xEventGroupClearBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupClearBitsFromISR_CallInstance);
  if (Mock.xEventGroupClearBitsFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupClearBitsFromISR_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupClearBitsFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupClearBitsFromISR_CallbackBool &&
      Mock.xEventGroupClearBitsFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xEventGroupClearBitsFromISR_CallbackFunctionPointer(xEventGroup, uxBitsToClear, Mock.xEventGroupClearBitsFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupClearBitsFromISR,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBitsToClear)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupClearBitsFromISR,CMockString_uxBitsToClear);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToClear), (void*)(&uxBitsToClear), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xEventGroupClearBitsFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupClearBitsFromISR_CallbackFunctionPointer(xEventGroup, uxBitsToClear, Mock.xEventGroupClearBitsFromISR_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupClearBitsFromISR(CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToClear), (void*)(&uxBitsToClear),
         sizeof(EventBits_t[sizeof(uxBitsToClear) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBitsToClear = 0;
}

void xEventGroupClearBitsFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupClearBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupClearBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupClearBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupClearBitsFromISR_IgnoreBool = (char)1;
}

void xEventGroupClearBitsFromISR_CMockStopIgnore(void)
{
  if(Mock.xEventGroupClearBitsFromISR_IgnoreBool)
    Mock.xEventGroupClearBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupClearBitsFromISR_CallInstance);
  Mock.xEventGroupClearBitsFromISR_IgnoreBool = (char)0;
}

void xEventGroupClearBitsFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupClearBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupClearBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupClearBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xEventGroupClearBitsFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupClearBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupClearBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupClearBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupClearBitsFromISR(cmock_call_instance, xEventGroup, uxBitsToClear);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xEventGroupClearBitsFromISR_AddCallback(CMOCK_xEventGroupClearBitsFromISR_CALLBACK Callback)
{
  Mock.xEventGroupClearBitsFromISR_IgnoreBool = (char)0;
  Mock.xEventGroupClearBitsFromISR_CallbackBool = (char)1;
  Mock.xEventGroupClearBitsFromISR_CallbackFunctionPointer = Callback;
}

void xEventGroupClearBitsFromISR_Stub(CMOCK_xEventGroupClearBitsFromISR_CALLBACK Callback)
{
  Mock.xEventGroupClearBitsFromISR_IgnoreBool = (char)0;
  Mock.xEventGroupClearBitsFromISR_CallbackBool = (char)0;
  Mock.xEventGroupClearBitsFromISR_CallbackFunctionPointer = Callback;
}

void xEventGroupClearBitsFromISR_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupClearBitsFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

void xEventGroupClearBitsFromISR_CMockIgnoreArg_uxBitsToClear(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupClearBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupClearBitsFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBitsToClear = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupSetBits
#else
EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet) __attribute__((weak));
#endif

EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupSetBits);
  cmock_call_instance = (CMOCK_xEventGroupSetBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupSetBits_CallInstance);
  Mock.xEventGroupSetBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSetBits_CallInstance);
  if (Mock.xEventGroupSetBits_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupSetBits_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupSetBits_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(EventBits_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupSetBits_CallbackBool &&
      Mock.xEventGroupSetBits_CallbackFunctionPointer != NULL)
  {
    EventBits_t cmock_cb_ret = Mock.xEventGroupSetBits_CallbackFunctionPointer(xEventGroup, uxBitsToSet, Mock.xEventGroupSetBits_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBits,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBitsToSet)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBits,CMockString_uxBitsToSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xEventGroupSetBits_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupSetBits_CallbackFunctionPointer(xEventGroup, uxBitsToSet, Mock.xEventGroupSetBits_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupSetBits(CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet),
         sizeof(EventBits_t[sizeof(uxBitsToSet) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBitsToSet = 0;
}

void xEventGroupSetBits_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBits_CALL_INSTANCE));
  CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupSetBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupSetBits_IgnoreBool = (char)1;
}

void xEventGroupSetBits_CMockStopIgnore(void)
{
  if(Mock.xEventGroupSetBits_IgnoreBool)
    Mock.xEventGroupSetBits_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSetBits_CallInstance);
  Mock.xEventGroupSetBits_IgnoreBool = (char)0;
}

void xEventGroupSetBits_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBits_CALL_INSTANCE));
  CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupSetBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xEventGroupSetBits_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBits_CALL_INSTANCE));
  CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBits_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBits_CallInstance, cmock_guts_index);
  Mock.xEventGroupSetBits_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupSetBits(cmock_call_instance, xEventGroup, uxBitsToSet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void xEventGroupSetBits_AddCallback(CMOCK_xEventGroupSetBits_CALLBACK Callback)
{
  Mock.xEventGroupSetBits_IgnoreBool = (char)0;
  Mock.xEventGroupSetBits_CallbackBool = (char)1;
  Mock.xEventGroupSetBits_CallbackFunctionPointer = Callback;
}

void xEventGroupSetBits_Stub(CMOCK_xEventGroupSetBits_CALLBACK Callback)
{
  Mock.xEventGroupSetBits_IgnoreBool = (char)0;
  Mock.xEventGroupSetBits_CallbackBool = (char)0;
  Mock.xEventGroupSetBits_CallbackFunctionPointer = Callback;
}

void xEventGroupSetBits_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSetBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

void xEventGroupSetBits_CMockIgnoreArg_uxBitsToSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSetBits_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBits_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSetBits_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBitsToSet = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupSetBitsFromISR
#else
BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t* pxHigherPriorityTaskWoken) __attribute__((weak));
#endif

BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupSetBitsFromISR);
  cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupSetBitsFromISR_CallInstance);
  Mock.xEventGroupSetBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSetBitsFromISR_CallInstance);
  if (Mock.xEventGroupSetBitsFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupSetBitsFromISR_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupSetBitsFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupSetBitsFromISR_CallbackBool &&
      Mock.xEventGroupSetBitsFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xEventGroupSetBitsFromISR_CallbackFunctionPointer(xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken, Mock.xEventGroupSetBitsFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBitsFromISR,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBitsToSet)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBitsFromISR,CMockString_uxBitsToSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSetBitsFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xEventGroupSetBitsFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupSetBitsFromISR_CallbackFunctionPointer(xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken, Mock.xEventGroupSetBitsFromISR_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxHigherPriorityTaskWoken, (void*)cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupSetBitsFromISR(CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet),
         sizeof(EventBits_t[sizeof(uxBitsToSet) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBitsToSet = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 0;
}

void xEventGroupSetBitsFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupSetBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupSetBitsFromISR_IgnoreBool = (char)1;
}

void xEventGroupSetBitsFromISR_CMockStopIgnore(void)
{
  if(Mock.xEventGroupSetBitsFromISR_IgnoreBool)
    Mock.xEventGroupSetBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSetBitsFromISR_CallInstance);
  Mock.xEventGroupSetBitsFromISR_IgnoreBool = (char)0;
}

void xEventGroupSetBitsFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupSetBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xEventGroupSetBitsFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupSetBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupSetBitsFromISR(cmock_call_instance, xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xEventGroupSetBitsFromISR_AddCallback(CMOCK_xEventGroupSetBitsFromISR_CALLBACK Callback)
{
  Mock.xEventGroupSetBitsFromISR_IgnoreBool = (char)0;
  Mock.xEventGroupSetBitsFromISR_CallbackBool = (char)1;
  Mock.xEventGroupSetBitsFromISR_CallbackFunctionPointer = Callback;
}

void xEventGroupSetBitsFromISR_Stub(CMOCK_xEventGroupSetBitsFromISR_CALLBACK Callback)
{
  Mock.xEventGroupSetBitsFromISR_IgnoreBool = (char)0;
  Mock.xEventGroupSetBitsFromISR_CallbackBool = (char)0;
  Mock.xEventGroupSetBitsFromISR_CallbackFunctionPointer = Callback;
}

void xEventGroupSetBitsFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSetBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupSetBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupSetBitsFromISR(cmock_call_instance, xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xEventGroupSetBitsFromISR_CMockReturnMemThruPtr_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t* pxHigherPriorityTaskWoken, int cmock_size)
{
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSetBitsFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val = pxHigherPriorityTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size = cmock_size;
}

void xEventGroupSetBitsFromISR_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSetBitsFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

void xEventGroupSetBitsFromISR_CMockIgnoreArg_uxBitsToSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSetBitsFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBitsToSet = 1;
}

void xEventGroupSetBitsFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSetBitsFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupSync
#else
EventBits_t xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait) __attribute__((weak));
#endif

EventBits_t xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupSync);
  cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupSync_CallInstance);
  Mock.xEventGroupSync_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSync_CallInstance);
  if (Mock.xEventGroupSync_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupSync_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupSync_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(EventBits_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupSync_CallbackBool &&
      Mock.xEventGroupSync_CallbackFunctionPointer != NULL)
  {
    EventBits_t cmock_cb_ret = Mock.xEventGroupSync_CallbackFunctionPointer(xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait, Mock.xEventGroupSync_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSync,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBitsToSet)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSync,CMockString_uxBitsToSet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxBitsToWaitFor)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSync,CMockString_uxBitsToWaitFor);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxBitsToWaitFor), (void*)(&uxBitsToWaitFor), sizeof(EventBits_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupSync,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xEventGroupSync_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupSync_CallbackFunctionPointer(xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait, Mock.xEventGroupSync_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupSync(CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToSet), (void*)(&uxBitsToSet),
         sizeof(EventBits_t[sizeof(uxBitsToSet) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBitsToSet = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxBitsToWaitFor), (void*)(&uxBitsToWaitFor),
         sizeof(EventBits_t[sizeof(uxBitsToWaitFor) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxBitsToWaitFor = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xEventGroupSync_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSync_CALL_INSTANCE));
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSync_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSync_CallInstance, cmock_guts_index);
  Mock.xEventGroupSync_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupSync_IgnoreBool = (char)1;
}

void xEventGroupSync_CMockStopIgnore(void)
{
  if(Mock.xEventGroupSync_IgnoreBool)
    Mock.xEventGroupSync_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupSync_CallInstance);
  Mock.xEventGroupSync_IgnoreBool = (char)0;
}

void xEventGroupSync_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSync_CALL_INSTANCE));
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSync_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSync_CallInstance, cmock_guts_index);
  Mock.xEventGroupSync_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xEventGroupSync_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupSync_CALL_INSTANCE));
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupSync_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupSync_CallInstance, cmock_guts_index);
  Mock.xEventGroupSync_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupSync(cmock_call_instance, xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void xEventGroupSync_AddCallback(CMOCK_xEventGroupSync_CALLBACK Callback)
{
  Mock.xEventGroupSync_IgnoreBool = (char)0;
  Mock.xEventGroupSync_CallbackBool = (char)1;
  Mock.xEventGroupSync_CallbackFunctionPointer = Callback;
}

void xEventGroupSync_Stub(CMOCK_xEventGroupSync_CALLBACK Callback)
{
  Mock.xEventGroupSync_IgnoreBool = (char)0;
  Mock.xEventGroupSync_CallbackBool = (char)0;
  Mock.xEventGroupSync_CallbackFunctionPointer = Callback;
}

void xEventGroupSync_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSync_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

void xEventGroupSync_CMockIgnoreArg_uxBitsToSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSync_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBitsToSet = 1;
}

void xEventGroupSync_CMockIgnoreArg_uxBitsToWaitFor(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSync_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxBitsToWaitFor = 1;
}

void xEventGroupSync_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupSync_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupSync_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupSync_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xEventGroupGetBitsFromISR
#else
EventBits_t xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup) __attribute__((weak));
#endif

EventBits_t xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xEventGroupGetBitsFromISR);
  cmock_call_instance = (CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xEventGroupGetBitsFromISR_CallInstance);
  Mock.xEventGroupGetBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupGetBitsFromISR_CallInstance);
  if (Mock.xEventGroupGetBitsFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xEventGroupGetBitsFromISR_FinalReturn;
    memcpy((void*)(&Mock.xEventGroupGetBitsFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(EventBits_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xEventGroupGetBitsFromISR_CallbackBool &&
      Mock.xEventGroupGetBitsFromISR_CallbackFunctionPointer != NULL)
  {
    EventBits_t cmock_cb_ret = Mock.xEventGroupGetBitsFromISR_CallbackFunctionPointer(xEventGroup, Mock.xEventGroupGetBitsFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_xEventGroupGetBitsFromISR,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xEventGroupGetBitsFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xEventGroupGetBitsFromISR_CallbackFunctionPointer(xEventGroup, Mock.xEventGroupGetBitsFromISR_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xEventGroupGetBitsFromISR(CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
}

void xEventGroupGetBitsFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupGetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupGetBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupGetBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xEventGroupGetBitsFromISR_IgnoreBool = (char)1;
}

void xEventGroupGetBitsFromISR_CMockStopIgnore(void)
{
  if(Mock.xEventGroupGetBitsFromISR_IgnoreBool)
    Mock.xEventGroupGetBitsFromISR_CallInstance = CMock_Guts_MemNext(Mock.xEventGroupGetBitsFromISR_CallInstance);
  Mock.xEventGroupGetBitsFromISR_IgnoreBool = (char)0;
}

void xEventGroupGetBitsFromISR_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupGetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupGetBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupGetBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xEventGroupGetBitsFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup, EventBits_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE));
  CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xEventGroupGetBitsFromISR_CallInstance = CMock_Guts_MemChain(Mock.xEventGroupGetBitsFromISR_CallInstance, cmock_guts_index);
  Mock.xEventGroupGetBitsFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xEventGroupGetBitsFromISR(cmock_call_instance, xEventGroup);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(EventBits_t[sizeof(cmock_to_return) == sizeof(EventBits_t) ? 1 : -1])); /* add EventBits_t to :treat_as_array if this causes an error */
}

void xEventGroupGetBitsFromISR_AddCallback(CMOCK_xEventGroupGetBitsFromISR_CALLBACK Callback)
{
  Mock.xEventGroupGetBitsFromISR_IgnoreBool = (char)0;
  Mock.xEventGroupGetBitsFromISR_CallbackBool = (char)1;
  Mock.xEventGroupGetBitsFromISR_CallbackFunctionPointer = Callback;
}

void xEventGroupGetBitsFromISR_Stub(CMOCK_xEventGroupGetBitsFromISR_CALLBACK Callback)
{
  Mock.xEventGroupGetBitsFromISR_IgnoreBool = (char)0;
  Mock.xEventGroupGetBitsFromISR_CallbackBool = (char)0;
  Mock.xEventGroupGetBitsFromISR_CallbackFunctionPointer = Callback;
}

void xEventGroupGetBitsFromISR_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xEventGroupGetBitsFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xEventGroupGetBitsFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vEventGroupDelete
#else
void vEventGroupDelete(EventGroupHandle_t xEventGroup) __attribute__((weak));
#endif

void vEventGroupDelete(EventGroupHandle_t xEventGroup)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEventGroupDelete_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEventGroupDelete);
  cmock_call_instance = (CMOCK_vEventGroupDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEventGroupDelete_CallInstance);
  Mock.vEventGroupDelete_CallInstance = CMock_Guts_MemNext(Mock.vEventGroupDelete_CallInstance);
  if (Mock.vEventGroupDelete_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vEventGroupDelete_CallbackBool &&
      Mock.vEventGroupDelete_CallbackFunctionPointer != NULL)
  {
    Mock.vEventGroupDelete_CallbackFunctionPointer(xEventGroup, Mock.vEventGroupDelete_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupDelete,CMockString_xEventGroup);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup), sizeof(EventGroupHandle_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vEventGroupDelete_CallbackFunctionPointer != NULL)
  {
    Mock.vEventGroupDelete_CallbackFunctionPointer(xEventGroup, Mock.vEventGroupDelete_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEventGroupDelete(CMOCK_vEventGroupDelete_CALL_INSTANCE* cmock_call_instance, EventGroupHandle_t xEventGroup)
{
  memcpy((void*)(&cmock_call_instance->Expected_xEventGroup), (void*)(&xEventGroup),
         sizeof(EventGroupHandle_t[sizeof(xEventGroup) == sizeof(EventGroupHandle_t) ? 1 : -1])); /* add EventGroupHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
}

void vEventGroupDelete_CMockIgnore(void)
{
  Mock.vEventGroupDelete_IgnoreBool = (char)1;
}

void vEventGroupDelete_CMockStopIgnore(void)
{
  Mock.vEventGroupDelete_IgnoreBool = (char)0;
}

void vEventGroupDelete_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupDelete_CALL_INSTANCE));
  CMOCK_vEventGroupDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupDelete_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupDelete_CallInstance, cmock_guts_index);
  Mock.vEventGroupDelete_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vEventGroupDelete_CMockExpect(UNITY_LINE_TYPE cmock_line, EventGroupHandle_t xEventGroup)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupDelete_CALL_INSTANCE));
  CMOCK_vEventGroupDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupDelete_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupDelete_CallInstance, cmock_guts_index);
  Mock.vEventGroupDelete_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEventGroupDelete(cmock_call_instance, xEventGroup);
}

void vEventGroupDelete_AddCallback(CMOCK_vEventGroupDelete_CALLBACK Callback)
{
  Mock.vEventGroupDelete_IgnoreBool = (char)0;
  Mock.vEventGroupDelete_CallbackBool = (char)1;
  Mock.vEventGroupDelete_CallbackFunctionPointer = Callback;
}

void vEventGroupDelete_Stub(CMOCK_vEventGroupDelete_CALLBACK Callback)
{
  Mock.vEventGroupDelete_IgnoreBool = (char)0;
  Mock.vEventGroupDelete_CallbackBool = (char)0;
  Mock.vEventGroupDelete_CallbackFunctionPointer = Callback;
}

void vEventGroupDelete_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEventGroupDelete_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupDelete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupDelete_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vEventGroupSetBitsCallback
#else
void vEventGroupSetBitsCallback(void* pvEventGroup, const uint32_t ulBitsToSet) __attribute__((weak));
#endif

void vEventGroupSetBitsCallback(void* pvEventGroup, const uint32_t ulBitsToSet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEventGroupSetBitsCallback);
  cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEventGroupSetBitsCallback_CallInstance);
  Mock.vEventGroupSetBitsCallback_CallInstance = CMock_Guts_MemNext(Mock.vEventGroupSetBitsCallback_CallInstance);
  if (Mock.vEventGroupSetBitsCallback_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vEventGroupSetBitsCallback_CallbackBool &&
      Mock.vEventGroupSetBitsCallback_CallbackFunctionPointer != NULL)
  {
    Mock.vEventGroupSetBitsCallback_CallbackFunctionPointer(pvEventGroup, ulBitsToSet, Mock.vEventGroupSetBitsCallback_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pvEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupSetBitsCallback,CMockString_pvEventGroup);
    if (cmock_call_instance->Expected_pvEventGroup == NULL)
      { UNITY_TEST_ASSERT_NULL(pvEventGroup, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvEventGroup, pvEventGroup, cmock_call_instance->Expected_pvEventGroup_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ulBitsToSet)
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupSetBitsCallback,CMockString_ulBitsToSet);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToSet, ulBitsToSet, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vEventGroupSetBitsCallback_CallbackFunctionPointer != NULL)
  {
    Mock.vEventGroupSetBitsCallback_CallbackFunctionPointer(pvEventGroup, ulBitsToSet, Mock.vEventGroupSetBitsCallback_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvEventGroup_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvEventGroup, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvEventGroup, (void*)cmock_call_instance->ReturnThruPtr_pvEventGroup_Val,
      cmock_call_instance->ReturnThruPtr_pvEventGroup_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEventGroupSetBitsCallback(CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance, void* pvEventGroup, int pvEventGroup_Depth, const uint32_t ulBitsToSet)
{
  cmock_call_instance->Expected_pvEventGroup = pvEventGroup;
  cmock_call_instance->Expected_pvEventGroup_Depth = pvEventGroup_Depth;
  cmock_call_instance->IgnoreArg_pvEventGroup = 0;
  cmock_call_instance->ReturnThruPtr_pvEventGroup_Used = 0;
  cmock_call_instance->Expected_ulBitsToSet = ulBitsToSet;
  cmock_call_instance->IgnoreArg_ulBitsToSet = 0;
}

void vEventGroupSetBitsCallback_CMockIgnore(void)
{
  Mock.vEventGroupSetBitsCallback_IgnoreBool = (char)1;
}

void vEventGroupSetBitsCallback_CMockStopIgnore(void)
{
  Mock.vEventGroupSetBitsCallback_IgnoreBool = (char)0;
}

void vEventGroupSetBitsCallback_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE));
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupSetBitsCallback_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupSetBitsCallback_CallInstance, cmock_guts_index);
  Mock.vEventGroupSetBitsCallback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vEventGroupSetBitsCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, void* pvEventGroup, const uint32_t ulBitsToSet)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE));
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupSetBitsCallback_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupSetBitsCallback_CallInstance, cmock_guts_index);
  Mock.vEventGroupSetBitsCallback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEventGroupSetBitsCallback(cmock_call_instance, pvEventGroup, 1, ulBitsToSet);
}

void vEventGroupSetBitsCallback_AddCallback(CMOCK_vEventGroupSetBitsCallback_CALLBACK Callback)
{
  Mock.vEventGroupSetBitsCallback_IgnoreBool = (char)0;
  Mock.vEventGroupSetBitsCallback_CallbackBool = (char)1;
  Mock.vEventGroupSetBitsCallback_CallbackFunctionPointer = Callback;
}

void vEventGroupSetBitsCallback_Stub(CMOCK_vEventGroupSetBitsCallback_CALLBACK Callback)
{
  Mock.vEventGroupSetBitsCallback_IgnoreBool = (char)0;
  Mock.vEventGroupSetBitsCallback_CallbackBool = (char)0;
  Mock.vEventGroupSetBitsCallback_CallbackFunctionPointer = Callback;
}

void vEventGroupSetBitsCallback_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, void* pvEventGroup, int pvEventGroup_Depth, const uint32_t ulBitsToSet)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE));
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupSetBitsCallback_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupSetBitsCallback_CallInstance, cmock_guts_index);
  Mock.vEventGroupSetBitsCallback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEventGroupSetBitsCallback(cmock_call_instance, pvEventGroup, pvEventGroup_Depth, ulBitsToSet);
}

void vEventGroupSetBitsCallback_CMockReturnMemThruPtr_pvEventGroup(UNITY_LINE_TYPE cmock_line, void* pvEventGroup, int cmock_size)
{
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupSetBitsCallback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvEventGroup_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvEventGroup_Val = pvEventGroup;
  cmock_call_instance->ReturnThruPtr_pvEventGroup_Size = cmock_size;
}

void vEventGroupSetBitsCallback_CMockIgnoreArg_pvEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupSetBitsCallback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvEventGroup = 1;
}

void vEventGroupSetBitsCallback_CMockIgnoreArg_ulBitsToSet(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupSetBitsCallback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulBitsToSet = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vEventGroupClearBitsCallback
#else
void vEventGroupClearBitsCallback(void* pvEventGroup, const uint32_t ulBitsToClear) __attribute__((weak));
#endif

void vEventGroupClearBitsCallback(void* pvEventGroup, const uint32_t ulBitsToClear)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEventGroupClearBitsCallback);
  cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEventGroupClearBitsCallback_CallInstance);
  Mock.vEventGroupClearBitsCallback_CallInstance = CMock_Guts_MemNext(Mock.vEventGroupClearBitsCallback_CallInstance);
  if (Mock.vEventGroupClearBitsCallback_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vEventGroupClearBitsCallback_CallbackBool &&
      Mock.vEventGroupClearBitsCallback_CallbackFunctionPointer != NULL)
  {
    Mock.vEventGroupClearBitsCallback_CallbackFunctionPointer(pvEventGroup, ulBitsToClear, Mock.vEventGroupClearBitsCallback_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pvEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupClearBitsCallback,CMockString_pvEventGroup);
    if (cmock_call_instance->Expected_pvEventGroup == NULL)
      { UNITY_TEST_ASSERT_NULL(pvEventGroup, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvEventGroup, pvEventGroup, cmock_call_instance->Expected_pvEventGroup_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ulBitsToClear)
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupClearBitsCallback,CMockString_ulBitsToClear);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulBitsToClear, ulBitsToClear, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vEventGroupClearBitsCallback_CallbackFunctionPointer != NULL)
  {
    Mock.vEventGroupClearBitsCallback_CallbackFunctionPointer(pvEventGroup, ulBitsToClear, Mock.vEventGroupClearBitsCallback_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvEventGroup_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvEventGroup, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvEventGroup, (void*)cmock_call_instance->ReturnThruPtr_pvEventGroup_Val,
      cmock_call_instance->ReturnThruPtr_pvEventGroup_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEventGroupClearBitsCallback(CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance, void* pvEventGroup, int pvEventGroup_Depth, const uint32_t ulBitsToClear)
{
  cmock_call_instance->Expected_pvEventGroup = pvEventGroup;
  cmock_call_instance->Expected_pvEventGroup_Depth = pvEventGroup_Depth;
  cmock_call_instance->IgnoreArg_pvEventGroup = 0;
  cmock_call_instance->ReturnThruPtr_pvEventGroup_Used = 0;
  cmock_call_instance->Expected_ulBitsToClear = ulBitsToClear;
  cmock_call_instance->IgnoreArg_ulBitsToClear = 0;
}

void vEventGroupClearBitsCallback_CMockIgnore(void)
{
  Mock.vEventGroupClearBitsCallback_IgnoreBool = (char)1;
}

void vEventGroupClearBitsCallback_CMockStopIgnore(void)
{
  Mock.vEventGroupClearBitsCallback_IgnoreBool = (char)0;
}

void vEventGroupClearBitsCallback_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE));
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupClearBitsCallback_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupClearBitsCallback_CallInstance, cmock_guts_index);
  Mock.vEventGroupClearBitsCallback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vEventGroupClearBitsCallback_CMockExpect(UNITY_LINE_TYPE cmock_line, void* pvEventGroup, const uint32_t ulBitsToClear)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE));
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupClearBitsCallback_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupClearBitsCallback_CallInstance, cmock_guts_index);
  Mock.vEventGroupClearBitsCallback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEventGroupClearBitsCallback(cmock_call_instance, pvEventGroup, 1, ulBitsToClear);
}

void vEventGroupClearBitsCallback_AddCallback(CMOCK_vEventGroupClearBitsCallback_CALLBACK Callback)
{
  Mock.vEventGroupClearBitsCallback_IgnoreBool = (char)0;
  Mock.vEventGroupClearBitsCallback_CallbackBool = (char)1;
  Mock.vEventGroupClearBitsCallback_CallbackFunctionPointer = Callback;
}

void vEventGroupClearBitsCallback_Stub(CMOCK_vEventGroupClearBitsCallback_CALLBACK Callback)
{
  Mock.vEventGroupClearBitsCallback_IgnoreBool = (char)0;
  Mock.vEventGroupClearBitsCallback_CallbackBool = (char)0;
  Mock.vEventGroupClearBitsCallback_CallbackFunctionPointer = Callback;
}

void vEventGroupClearBitsCallback_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, void* pvEventGroup, int pvEventGroup_Depth, const uint32_t ulBitsToClear)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE));
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupClearBitsCallback_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupClearBitsCallback_CallInstance, cmock_guts_index);
  Mock.vEventGroupClearBitsCallback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEventGroupClearBitsCallback(cmock_call_instance, pvEventGroup, pvEventGroup_Depth, ulBitsToClear);
}

void vEventGroupClearBitsCallback_CMockReturnMemThruPtr_pvEventGroup(UNITY_LINE_TYPE cmock_line, void* pvEventGroup, int cmock_size)
{
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupClearBitsCallback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvEventGroup_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvEventGroup_Val = pvEventGroup;
  cmock_call_instance->ReturnThruPtr_pvEventGroup_Size = cmock_size;
}

void vEventGroupClearBitsCallback_CMockIgnoreArg_pvEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupClearBitsCallback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvEventGroup = 1;
}

void vEventGroupClearBitsCallback_CMockIgnoreArg_ulBitsToClear(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupClearBitsCallback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupClearBitsCallback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulBitsToClear = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak uxEventGroupGetNumber
#else
UBaseType_t uxEventGroupGetNumber(void* xEventGroup) __attribute__((weak));
#endif

UBaseType_t uxEventGroupGetNumber(void* xEventGroup)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxEventGroupGetNumber);
  cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxEventGroupGetNumber_CallInstance);
  Mock.uxEventGroupGetNumber_CallInstance = CMock_Guts_MemNext(Mock.uxEventGroupGetNumber_CallInstance);
  if (Mock.uxEventGroupGetNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxEventGroupGetNumber_FinalReturn;
    memcpy((void*)(&Mock.uxEventGroupGetNumber_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxEventGroupGetNumber_CallbackBool &&
      Mock.uxEventGroupGetNumber_CallbackFunctionPointer != NULL)
  {
    UBaseType_t cmock_cb_ret = Mock.uxEventGroupGetNumber_CallbackFunctionPointer(xEventGroup, Mock.uxEventGroupGetNumber_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_uxEventGroupGetNumber,CMockString_xEventGroup);
    if (cmock_call_instance->Expected_xEventGroup == NULL)
      { UNITY_TEST_ASSERT_NULL(xEventGroup, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_xEventGroup, xEventGroup, cmock_call_instance->Expected_xEventGroup_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.uxEventGroupGetNumber_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxEventGroupGetNumber_CallbackFunctionPointer(xEventGroup, Mock.uxEventGroupGetNumber_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_xEventGroup_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(xEventGroup, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)xEventGroup, (void*)cmock_call_instance->ReturnThruPtr_xEventGroup_Val,
      cmock_call_instance->ReturnThruPtr_xEventGroup_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxEventGroupGetNumber(CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance, void* xEventGroup, int xEventGroup_Depth)
{
  cmock_call_instance->Expected_xEventGroup = xEventGroup;
  cmock_call_instance->Expected_xEventGroup_Depth = xEventGroup_Depth;
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
  cmock_call_instance->ReturnThruPtr_xEventGroup_Used = 0;
}

void uxEventGroupGetNumber_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxEventGroupGetNumber_CALL_INSTANCE));
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxEventGroupGetNumber_CallInstance = CMock_Guts_MemChain(Mock.uxEventGroupGetNumber_CallInstance, cmock_guts_index);
  Mock.uxEventGroupGetNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxEventGroupGetNumber_IgnoreBool = (char)1;
}

void uxEventGroupGetNumber_CMockStopIgnore(void)
{
  if(Mock.uxEventGroupGetNumber_IgnoreBool)
    Mock.uxEventGroupGetNumber_CallInstance = CMock_Guts_MemNext(Mock.uxEventGroupGetNumber_CallInstance);
  Mock.uxEventGroupGetNumber_IgnoreBool = (char)0;
}

void uxEventGroupGetNumber_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxEventGroupGetNumber_CALL_INSTANCE));
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxEventGroupGetNumber_CallInstance = CMock_Guts_MemChain(Mock.uxEventGroupGetNumber_CallInstance, cmock_guts_index);
  Mock.uxEventGroupGetNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void uxEventGroupGetNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, void* xEventGroup, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxEventGroupGetNumber_CALL_INSTANCE));
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxEventGroupGetNumber_CallInstance = CMock_Guts_MemChain(Mock.uxEventGroupGetNumber_CallInstance, cmock_guts_index);
  Mock.uxEventGroupGetNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxEventGroupGetNumber(cmock_call_instance, xEventGroup, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxEventGroupGetNumber_AddCallback(CMOCK_uxEventGroupGetNumber_CALLBACK Callback)
{
  Mock.uxEventGroupGetNumber_IgnoreBool = (char)0;
  Mock.uxEventGroupGetNumber_CallbackBool = (char)1;
  Mock.uxEventGroupGetNumber_CallbackFunctionPointer = Callback;
}

void uxEventGroupGetNumber_Stub(CMOCK_uxEventGroupGetNumber_CALLBACK Callback)
{
  Mock.uxEventGroupGetNumber_IgnoreBool = (char)0;
  Mock.uxEventGroupGetNumber_CallbackBool = (char)0;
  Mock.uxEventGroupGetNumber_CallbackFunctionPointer = Callback;
}

void uxEventGroupGetNumber_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, void* xEventGroup, int xEventGroup_Depth, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxEventGroupGetNumber_CALL_INSTANCE));
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxEventGroupGetNumber_CallInstance = CMock_Guts_MemChain(Mock.uxEventGroupGetNumber_CallInstance, cmock_guts_index);
  Mock.uxEventGroupGetNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_uxEventGroupGetNumber(cmock_call_instance, xEventGroup, xEventGroup_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void uxEventGroupGetNumber_CMockReturnMemThruPtr_xEventGroup(UNITY_LINE_TYPE cmock_line, void* xEventGroup, int cmock_size)
{
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxEventGroupGetNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_xEventGroup_Used = 1;
  cmock_call_instance->ReturnThruPtr_xEventGroup_Val = xEventGroup;
  cmock_call_instance->ReturnThruPtr_xEventGroup_Size = cmock_size;
}

void uxEventGroupGetNumber_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxEventGroupGetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxEventGroupGetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxEventGroupGetNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vEventGroupSetNumber
#else
void vEventGroupSetNumber(void* xEventGroup, UBaseType_t uxEventGroupNumber) __attribute__((weak));
#endif

void vEventGroupSetNumber(void* xEventGroup, UBaseType_t uxEventGroupNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vEventGroupSetNumber);
  cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vEventGroupSetNumber_CallInstance);
  Mock.vEventGroupSetNumber_CallInstance = CMock_Guts_MemNext(Mock.vEventGroupSetNumber_CallInstance);
  if (Mock.vEventGroupSetNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vEventGroupSetNumber_CallbackBool &&
      Mock.vEventGroupSetNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vEventGroupSetNumber_CallbackFunctionPointer(xEventGroup, uxEventGroupNumber, Mock.vEventGroupSetNumber_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_xEventGroup)
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupSetNumber,CMockString_xEventGroup);
    if (cmock_call_instance->Expected_xEventGroup == NULL)
      { UNITY_TEST_ASSERT_NULL(xEventGroup, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_xEventGroup, xEventGroup, cmock_call_instance->Expected_xEventGroup_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_uxEventGroupNumber)
  {
    UNITY_SET_DETAILS(CMockString_vEventGroupSetNumber,CMockString_uxEventGroupNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxEventGroupNumber), (void*)(&uxEventGroupNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.vEventGroupSetNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vEventGroupSetNumber_CallbackFunctionPointer(xEventGroup, uxEventGroupNumber, Mock.vEventGroupSetNumber_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_xEventGroup_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(xEventGroup, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)xEventGroup, (void*)cmock_call_instance->ReturnThruPtr_xEventGroup_Val,
      cmock_call_instance->ReturnThruPtr_xEventGroup_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vEventGroupSetNumber(CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance, void* xEventGroup, int xEventGroup_Depth, UBaseType_t uxEventGroupNumber)
{
  cmock_call_instance->Expected_xEventGroup = xEventGroup;
  cmock_call_instance->Expected_xEventGroup_Depth = xEventGroup_Depth;
  cmock_call_instance->IgnoreArg_xEventGroup = 0;
  cmock_call_instance->ReturnThruPtr_xEventGroup_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxEventGroupNumber), (void*)(&uxEventGroupNumber),
         sizeof(UBaseType_t[sizeof(uxEventGroupNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxEventGroupNumber = 0;
}

void vEventGroupSetNumber_CMockIgnore(void)
{
  Mock.vEventGroupSetNumber_IgnoreBool = (char)1;
}

void vEventGroupSetNumber_CMockStopIgnore(void)
{
  Mock.vEventGroupSetNumber_IgnoreBool = (char)0;
}

void vEventGroupSetNumber_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupSetNumber_CALL_INSTANCE));
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupSetNumber_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupSetNumber_CallInstance, cmock_guts_index);
  Mock.vEventGroupSetNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vEventGroupSetNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, void* xEventGroup, UBaseType_t uxEventGroupNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupSetNumber_CALL_INSTANCE));
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupSetNumber_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupSetNumber_CallInstance, cmock_guts_index);
  Mock.vEventGroupSetNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEventGroupSetNumber(cmock_call_instance, xEventGroup, 1, uxEventGroupNumber);
}

void vEventGroupSetNumber_AddCallback(CMOCK_vEventGroupSetNumber_CALLBACK Callback)
{
  Mock.vEventGroupSetNumber_IgnoreBool = (char)0;
  Mock.vEventGroupSetNumber_CallbackBool = (char)1;
  Mock.vEventGroupSetNumber_CallbackFunctionPointer = Callback;
}

void vEventGroupSetNumber_Stub(CMOCK_vEventGroupSetNumber_CALLBACK Callback)
{
  Mock.vEventGroupSetNumber_IgnoreBool = (char)0;
  Mock.vEventGroupSetNumber_CallbackBool = (char)0;
  Mock.vEventGroupSetNumber_CallbackFunctionPointer = Callback;
}

void vEventGroupSetNumber_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, void* xEventGroup, int xEventGroup_Depth, UBaseType_t uxEventGroupNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vEventGroupSetNumber_CALL_INSTANCE));
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vEventGroupSetNumber_CallInstance = CMock_Guts_MemChain(Mock.vEventGroupSetNumber_CallInstance, cmock_guts_index);
  Mock.vEventGroupSetNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vEventGroupSetNumber(cmock_call_instance, xEventGroup, xEventGroup_Depth, uxEventGroupNumber);
}

void vEventGroupSetNumber_CMockReturnMemThruPtr_xEventGroup(UNITY_LINE_TYPE cmock_line, void* xEventGroup, int cmock_size)
{
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupSetNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_xEventGroup_Used = 1;
  cmock_call_instance->ReturnThruPtr_xEventGroup_Val = xEventGroup;
  cmock_call_instance->ReturnThruPtr_xEventGroup_Size = cmock_size;
}

void vEventGroupSetNumber_CMockIgnoreArg_xEventGroup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupSetNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xEventGroup = 1;
}

void vEventGroupSetNumber_CMockIgnoreArg_uxEventGroupNumber(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vEventGroupSetNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vEventGroupSetNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vEventGroupSetNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxEventGroupNumber = 1;
}

