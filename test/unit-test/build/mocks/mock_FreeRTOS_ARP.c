/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_FreeRTOS_ARP.h"

static const char* CMockString_FreeRTOS_ClearARP = "FreeRTOS_ClearARP";
static const char* CMockString_FreeRTOS_OutputARPRequest = "FreeRTOS_OutputARPRequest";
static const char* CMockString_bReleaseAfterSend = "bReleaseAfterSend";
static const char* CMockString_eARPGetCacheEntry = "eARPGetCacheEntry";
static const char* CMockString_eARPGetCacheEntryByMac = "eARPGetCacheEntryByMac";
static const char* CMockString_ppxEndPoint = "ppxEndPoint";
static const char* CMockString_ppxInterface = "ppxInterface";
static const char* CMockString_pulIPAddress = "pulIPAddress";
static const char* CMockString_pxDescriptor = "pxDescriptor";
static const char* CMockString_pxEndPoint = "pxEndPoint";
static const char* CMockString_pxMACAddress = "pxMACAddress";
static const char* CMockString_pxNetworkBuffer = "pxNetworkBuffer";
static const char* CMockString_ulARPRemoveCacheEntryByMac = "ulARPRemoveCacheEntryByMac";
static const char* CMockString_ulAddressToLookup = "ulAddressToLookup";
static const char* CMockString_ulIPAddress = "ulIPAddress";
static const char* CMockString_vARPAgeCache = "vARPAgeCache";
static const char* CMockString_vARPGenerateRequestPacket = "vARPGenerateRequestPacket";
static const char* CMockString_vARPRefreshCacheEntry = "vARPRefreshCacheEntry";
static const char* CMockString_vARPSendGratuitous = "vARPSendGratuitous";
static const char* CMockString_xCheckLoopback = "xCheckLoopback";
static const char* CMockString_xCheckRequiresARPResolution = "xCheckRequiresARPResolution";
static const char* CMockString_xIsIPInARPCache = "xIsIPInARPCache";

typedef struct _CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  const MACAddress_t* Expected_pxMACAddress;
  uint32_t Expected_ulIPAddress;
  struct xNetworkEndPoint* Expected_pxEndPoint;
  int Expected_pxMACAddress_Depth;
  int Expected_pxEndPoint_Depth;
  char ReturnThruPtr_pxEndPoint_Used;
  struct xNetworkEndPoint* ReturnThruPtr_pxEndPoint_Val;
  int ReturnThruPtr_pxEndPoint_Size;
  char IgnoreArg_pxMACAddress;
  char IgnoreArg_ulIPAddress;
  char IgnoreArg_pxEndPoint;

} CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE;

typedef struct _CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  uint32_t ReturnVal;
  int CallOrder;
  const MACAddress_t* Expected_pxMACAddress;
  int Expected_pxMACAddress_Depth;
  char IgnoreArg_pxMACAddress;

} CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE;

typedef struct _CMOCK_xIsIPInARPCache_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  uint32_t Expected_ulAddressToLookup;
  char IgnoreArg_ulAddressToLookup;

} CMOCK_xIsIPInARPCache_CALL_INSTANCE;

typedef struct _CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  const NetworkBufferDescriptor_t* Expected_pxNetworkBuffer;
  int Expected_pxNetworkBuffer_Depth;
  char IgnoreArg_pxNetworkBuffer;

} CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE;

typedef struct _CMOCK_eARPGetCacheEntry_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eARPLookupResult_t ReturnVal;
  int CallOrder;
  uint32_t* Expected_pulIPAddress;
  MACAddress_t* Expected_pxMACAddress;
  struct xNetworkEndPoint** Expected_ppxEndPoint;
  int Expected_pulIPAddress_Depth;
  int Expected_pxMACAddress_Depth;
  int Expected_ppxEndPoint_Depth;
  char ReturnThruPtr_pulIPAddress_Used;
  uint32_t* ReturnThruPtr_pulIPAddress_Val;
  int ReturnThruPtr_pulIPAddress_Size;
  char ReturnThruPtr_pxMACAddress_Used;
  MACAddress_t* ReturnThruPtr_pxMACAddress_Val;
  int ReturnThruPtr_pxMACAddress_Size;
  char ReturnThruPtr_ppxEndPoint_Used;
  struct xNetworkEndPoint** ReturnThruPtr_ppxEndPoint_Val;
  int ReturnThruPtr_ppxEndPoint_Size;
  char IgnoreArg_pulIPAddress;
  char IgnoreArg_pxMACAddress;
  char IgnoreArg_ppxEndPoint;

} CMOCK_eARPGetCacheEntry_CALL_INSTANCE;

typedef struct _CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  eARPLookupResult_t ReturnVal;
  int CallOrder;
  const MACAddress_t* Expected_pxMACAddress;
  uint32_t* Expected_pulIPAddress;
  struct xNetworkInterface** Expected_ppxInterface;
  int Expected_pxMACAddress_Depth;
  int Expected_pulIPAddress_Depth;
  int Expected_ppxInterface_Depth;
  char ReturnThruPtr_pulIPAddress_Used;
  uint32_t* ReturnThruPtr_pulIPAddress_Val;
  int ReturnThruPtr_pulIPAddress_Size;
  char ReturnThruPtr_ppxInterface_Used;
  struct xNetworkInterface** ReturnThruPtr_ppxInterface_Val;
  int ReturnThruPtr_ppxInterface_Size;
  char IgnoreArg_pxMACAddress;
  char IgnoreArg_pulIPAddress;
  char IgnoreArg_ppxInterface;

} CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE;

typedef struct _CMOCK_vARPAgeCache_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vARPAgeCache_CALL_INSTANCE;

typedef struct _CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  NetworkBufferDescriptor_t* Expected_pxNetworkBuffer;
  int Expected_pxNetworkBuffer_Depth;
  char ReturnThruPtr_pxNetworkBuffer_Used;
  NetworkBufferDescriptor_t* ReturnThruPtr_pxNetworkBuffer_Val;
  int ReturnThruPtr_pxNetworkBuffer_Size;
  char IgnoreArg_pxNetworkBuffer;

} CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE;

typedef struct _CMOCK_vARPSendGratuitous_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;

} CMOCK_vARPSendGratuitous_CALL_INSTANCE;

typedef struct _CMOCK_xCheckLoopback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  BaseType_t ReturnVal;
  int CallOrder;
  NetworkBufferDescriptor_t* Expected_pxDescriptor;
  BaseType_t Expected_bReleaseAfterSend;
  int Expected_pxDescriptor_Depth;
  char ReturnThruPtr_pxDescriptor_Used;
  NetworkBufferDescriptor_t* ReturnThruPtr_pxDescriptor_Val;
  int ReturnThruPtr_pxDescriptor_Size;
  char IgnoreArg_pxDescriptor;
  char IgnoreArg_bReleaseAfterSend;

} CMOCK_xCheckLoopback_CALL_INSTANCE;

typedef struct _CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  uint32_t Expected_ulIPAddress;
  char IgnoreArg_ulIPAddress;

} CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE;

typedef struct _CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  char ExpectAnyArgsBool;
  int CallOrder;
  const struct xNetworkEndPoint* Expected_pxEndPoint;
  int Expected_pxEndPoint_Depth;
  char IgnoreArg_pxEndPoint;

} CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE;

static struct mock_FreeRTOS_ARPInstance
{
  char vARPRefreshCacheEntry_IgnoreBool;
  char vARPRefreshCacheEntry_CallbackBool;
  CMOCK_vARPRefreshCacheEntry_CALLBACK vARPRefreshCacheEntry_CallbackFunctionPointer;
  int vARPRefreshCacheEntry_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vARPRefreshCacheEntry_CallInstance;
  char ulARPRemoveCacheEntryByMac_IgnoreBool;
  uint32_t ulARPRemoveCacheEntryByMac_FinalReturn;
  char ulARPRemoveCacheEntryByMac_CallbackBool;
  CMOCK_ulARPRemoveCacheEntryByMac_CALLBACK ulARPRemoveCacheEntryByMac_CallbackFunctionPointer;
  int ulARPRemoveCacheEntryByMac_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ulARPRemoveCacheEntryByMac_CallInstance;
  char xIsIPInARPCache_IgnoreBool;
  BaseType_t xIsIPInARPCache_FinalReturn;
  char xIsIPInARPCache_CallbackBool;
  CMOCK_xIsIPInARPCache_CALLBACK xIsIPInARPCache_CallbackFunctionPointer;
  int xIsIPInARPCache_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xIsIPInARPCache_CallInstance;
  char xCheckRequiresARPResolution_IgnoreBool;
  BaseType_t xCheckRequiresARPResolution_FinalReturn;
  char xCheckRequiresARPResolution_CallbackBool;
  CMOCK_xCheckRequiresARPResolution_CALLBACK xCheckRequiresARPResolution_CallbackFunctionPointer;
  int xCheckRequiresARPResolution_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xCheckRequiresARPResolution_CallInstance;
  char eARPGetCacheEntry_IgnoreBool;
  eARPLookupResult_t eARPGetCacheEntry_FinalReturn;
  char eARPGetCacheEntry_CallbackBool;
  CMOCK_eARPGetCacheEntry_CALLBACK eARPGetCacheEntry_CallbackFunctionPointer;
  int eARPGetCacheEntry_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE eARPGetCacheEntry_CallInstance;
  char eARPGetCacheEntryByMac_IgnoreBool;
  eARPLookupResult_t eARPGetCacheEntryByMac_FinalReturn;
  char eARPGetCacheEntryByMac_CallbackBool;
  CMOCK_eARPGetCacheEntryByMac_CALLBACK eARPGetCacheEntryByMac_CallbackFunctionPointer;
  int eARPGetCacheEntryByMac_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE eARPGetCacheEntryByMac_CallInstance;
  char vARPAgeCache_IgnoreBool;
  char vARPAgeCache_CallbackBool;
  CMOCK_vARPAgeCache_CALLBACK vARPAgeCache_CallbackFunctionPointer;
  int vARPAgeCache_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vARPAgeCache_CallInstance;
  char vARPGenerateRequestPacket_IgnoreBool;
  char vARPGenerateRequestPacket_CallbackBool;
  CMOCK_vARPGenerateRequestPacket_CALLBACK vARPGenerateRequestPacket_CallbackFunctionPointer;
  int vARPGenerateRequestPacket_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vARPGenerateRequestPacket_CallInstance;
  char vARPSendGratuitous_IgnoreBool;
  char vARPSendGratuitous_CallbackBool;
  CMOCK_vARPSendGratuitous_CALLBACK vARPSendGratuitous_CallbackFunctionPointer;
  int vARPSendGratuitous_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vARPSendGratuitous_CallInstance;
  char xCheckLoopback_IgnoreBool;
  BaseType_t xCheckLoopback_FinalReturn;
  char xCheckLoopback_CallbackBool;
  CMOCK_xCheckLoopback_CALLBACK xCheckLoopback_CallbackFunctionPointer;
  int xCheckLoopback_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xCheckLoopback_CallInstance;
  char FreeRTOS_OutputARPRequest_IgnoreBool;
  char FreeRTOS_OutputARPRequest_CallbackBool;
  CMOCK_FreeRTOS_OutputARPRequest_CALLBACK FreeRTOS_OutputARPRequest_CallbackFunctionPointer;
  int FreeRTOS_OutputARPRequest_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE FreeRTOS_OutputARPRequest_CallInstance;
  char FreeRTOS_ClearARP_IgnoreBool;
  char FreeRTOS_ClearARP_CallbackBool;
  CMOCK_FreeRTOS_ClearARP_CALLBACK FreeRTOS_ClearARP_CallbackFunctionPointer;
  int FreeRTOS_ClearARP_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE FreeRTOS_ClearARP_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_FreeRTOS_ARP_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.vARPRefreshCacheEntry_CallInstance;
  if (Mock.vARPRefreshCacheEntry_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vARPRefreshCacheEntry);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vARPRefreshCacheEntry_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ulARPRemoveCacheEntryByMac_CallInstance;
  if (Mock.ulARPRemoveCacheEntryByMac_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ulARPRemoveCacheEntryByMac);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ulARPRemoveCacheEntryByMac_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xIsIPInARPCache_CallInstance;
  if (Mock.xIsIPInARPCache_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xIsIPInARPCache);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xIsIPInARPCache_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xCheckRequiresARPResolution_CallInstance;
  if (Mock.xCheckRequiresARPResolution_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xCheckRequiresARPResolution);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xCheckRequiresARPResolution_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.eARPGetCacheEntry_CallInstance;
  if (Mock.eARPGetCacheEntry_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_eARPGetCacheEntry);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.eARPGetCacheEntry_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.eARPGetCacheEntryByMac_CallInstance;
  if (Mock.eARPGetCacheEntryByMac_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_eARPGetCacheEntryByMac);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.eARPGetCacheEntryByMac_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vARPAgeCache_CallInstance;
  if (Mock.vARPAgeCache_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vARPAgeCache);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vARPAgeCache_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vARPGenerateRequestPacket_CallInstance;
  if (Mock.vARPGenerateRequestPacket_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vARPGenerateRequestPacket);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vARPGenerateRequestPacket_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vARPSendGratuitous_CallInstance;
  if (Mock.vARPSendGratuitous_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vARPSendGratuitous);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vARPSendGratuitous_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xCheckLoopback_CallInstance;
  if (Mock.xCheckLoopback_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xCheckLoopback);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xCheckLoopback_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.FreeRTOS_OutputARPRequest_CallInstance;
  if (Mock.FreeRTOS_OutputARPRequest_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_FreeRTOS_OutputARPRequest);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.FreeRTOS_OutputARPRequest_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.FreeRTOS_ClearARP_CallInstance;
  if (Mock.FreeRTOS_ClearARP_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_FreeRTOS_ClearARP);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.FreeRTOS_ClearARP_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_FreeRTOS_ARP_Init(void)
{
  mock_FreeRTOS_ARP_Destroy();
}

void mock_FreeRTOS_ARP_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vARPRefreshCacheEntry
#else
void vARPRefreshCacheEntry(const MACAddress_t* pxMACAddress, const uint32_t ulIPAddress, struct xNetworkEndPoint* pxEndPoint) __attribute__((weak));
#endif

void vARPRefreshCacheEntry(const MACAddress_t* pxMACAddress, const uint32_t ulIPAddress, struct xNetworkEndPoint* pxEndPoint)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vARPRefreshCacheEntry);
  cmock_call_instance = (CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vARPRefreshCacheEntry_CallInstance);
  Mock.vARPRefreshCacheEntry_CallInstance = CMock_Guts_MemNext(Mock.vARPRefreshCacheEntry_CallInstance);
  if (Mock.vARPRefreshCacheEntry_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vARPRefreshCacheEntry_CallbackBool &&
      Mock.vARPRefreshCacheEntry_CallbackFunctionPointer != NULL)
  {
    Mock.vARPRefreshCacheEntry_CallbackFunctionPointer(pxMACAddress, ulIPAddress, pxEndPoint, Mock.vARPRefreshCacheEntry_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxMACAddress)
  {
    UNITY_SET_DETAILS(CMockString_vARPRefreshCacheEntry,CMockString_pxMACAddress);
    if (cmock_call_instance->Expected_pxMACAddress == NULL)
      { UNITY_TEST_ASSERT_NULL(pxMACAddress, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxMACAddress), (void*)(pxMACAddress), sizeof(const MACAddress_t), cmock_call_instance->Expected_pxMACAddress_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ulIPAddress)
  {
    UNITY_SET_DETAILS(CMockString_vARPRefreshCacheEntry,CMockString_ulIPAddress);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulIPAddress, ulIPAddress, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxEndPoint)
  {
    UNITY_SET_DETAILS(CMockString_vARPRefreshCacheEntry,CMockString_pxEndPoint);
    if (cmock_call_instance->Expected_pxEndPoint == NULL)
      { UNITY_TEST_ASSERT_NULL(pxEndPoint, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxEndPoint), (void*)(pxEndPoint), sizeof(struct xNetworkEndPoint), cmock_call_instance->Expected_pxEndPoint_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vARPRefreshCacheEntry_CallbackFunctionPointer != NULL)
  {
    Mock.vARPRefreshCacheEntry_CallbackFunctionPointer(pxMACAddress, ulIPAddress, pxEndPoint, Mock.vARPRefreshCacheEntry_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxEndPoint_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxEndPoint, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxEndPoint, (void*)cmock_call_instance->ReturnThruPtr_pxEndPoint_Val,
      cmock_call_instance->ReturnThruPtr_pxEndPoint_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vARPRefreshCacheEntry(CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance, const MACAddress_t* pxMACAddress, int pxMACAddress_Depth, const uint32_t ulIPAddress, struct xNetworkEndPoint* pxEndPoint, int pxEndPoint_Depth)
{
  cmock_call_instance->Expected_pxMACAddress = pxMACAddress;
  cmock_call_instance->Expected_pxMACAddress_Depth = pxMACAddress_Depth;
  cmock_call_instance->IgnoreArg_pxMACAddress = 0;
  cmock_call_instance->Expected_ulIPAddress = ulIPAddress;
  cmock_call_instance->IgnoreArg_ulIPAddress = 0;
  cmock_call_instance->Expected_pxEndPoint = pxEndPoint;
  cmock_call_instance->Expected_pxEndPoint_Depth = pxEndPoint_Depth;
  cmock_call_instance->IgnoreArg_pxEndPoint = 0;
  cmock_call_instance->ReturnThruPtr_pxEndPoint_Used = 0;
}

void vARPRefreshCacheEntry_CMockIgnore(void)
{
  Mock.vARPRefreshCacheEntry_IgnoreBool = (char)1;
}

void vARPRefreshCacheEntry_CMockStopIgnore(void)
{
  Mock.vARPRefreshCacheEntry_IgnoreBool = (char)0;
}

void vARPRefreshCacheEntry_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE));
  CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vARPRefreshCacheEntry_CallInstance = CMock_Guts_MemChain(Mock.vARPRefreshCacheEntry_CallInstance, cmock_guts_index);
  Mock.vARPRefreshCacheEntry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vARPRefreshCacheEntry_CMockExpect(UNITY_LINE_TYPE cmock_line, const MACAddress_t* pxMACAddress, const uint32_t ulIPAddress, struct xNetworkEndPoint* pxEndPoint)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE));
  CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vARPRefreshCacheEntry_CallInstance = CMock_Guts_MemChain(Mock.vARPRefreshCacheEntry_CallInstance, cmock_guts_index);
  Mock.vARPRefreshCacheEntry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vARPRefreshCacheEntry(cmock_call_instance, pxMACAddress, 1, ulIPAddress, pxEndPoint, 1);
}

void vARPRefreshCacheEntry_AddCallback(CMOCK_vARPRefreshCacheEntry_CALLBACK Callback)
{
  Mock.vARPRefreshCacheEntry_IgnoreBool = (char)0;
  Mock.vARPRefreshCacheEntry_CallbackBool = (char)1;
  Mock.vARPRefreshCacheEntry_CallbackFunctionPointer = Callback;
}

void vARPRefreshCacheEntry_Stub(CMOCK_vARPRefreshCacheEntry_CALLBACK Callback)
{
  Mock.vARPRefreshCacheEntry_IgnoreBool = (char)0;
  Mock.vARPRefreshCacheEntry_CallbackBool = (char)0;
  Mock.vARPRefreshCacheEntry_CallbackFunctionPointer = Callback;
}

void vARPRefreshCacheEntry_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, const MACAddress_t* pxMACAddress, int pxMACAddress_Depth, const uint32_t ulIPAddress, struct xNetworkEndPoint* pxEndPoint, int pxEndPoint_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE));
  CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vARPRefreshCacheEntry_CallInstance = CMock_Guts_MemChain(Mock.vARPRefreshCacheEntry_CallInstance, cmock_guts_index);
  Mock.vARPRefreshCacheEntry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vARPRefreshCacheEntry(cmock_call_instance, pxMACAddress, pxMACAddress_Depth, ulIPAddress, pxEndPoint, pxEndPoint_Depth);
}

void vARPRefreshCacheEntry_CMockReturnMemThruPtr_pxEndPoint(UNITY_LINE_TYPE cmock_line, struct xNetworkEndPoint* pxEndPoint, int cmock_size)
{
  CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vARPRefreshCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxEndPoint_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxEndPoint_Val = pxEndPoint;
  cmock_call_instance->ReturnThruPtr_pxEndPoint_Size = cmock_size;
}

void vARPRefreshCacheEntry_CMockIgnoreArg_pxMACAddress(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vARPRefreshCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxMACAddress = 1;
}

void vARPRefreshCacheEntry_CMockIgnoreArg_ulIPAddress(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vARPRefreshCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulIPAddress = 1;
}

void vARPRefreshCacheEntry_CMockIgnoreArg_pxEndPoint(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPRefreshCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vARPRefreshCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxEndPoint = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak ulARPRemoveCacheEntryByMac
#else
uint32_t ulARPRemoveCacheEntryByMac(const MACAddress_t* pxMACAddress) __attribute__((weak));
#endif

uint32_t ulARPRemoveCacheEntryByMac(const MACAddress_t* pxMACAddress)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ulARPRemoveCacheEntryByMac);
  cmock_call_instance = (CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ulARPRemoveCacheEntryByMac_CallInstance);
  Mock.ulARPRemoveCacheEntryByMac_CallInstance = CMock_Guts_MemNext(Mock.ulARPRemoveCacheEntryByMac_CallInstance);
  if (Mock.ulARPRemoveCacheEntryByMac_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ulARPRemoveCacheEntryByMac_FinalReturn;
    Mock.ulARPRemoveCacheEntryByMac_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ulARPRemoveCacheEntryByMac_CallbackBool &&
      Mock.ulARPRemoveCacheEntryByMac_CallbackFunctionPointer != NULL)
  {
    uint32_t cmock_cb_ret = Mock.ulARPRemoveCacheEntryByMac_CallbackFunctionPointer(pxMACAddress, Mock.ulARPRemoveCacheEntryByMac_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxMACAddress)
  {
    UNITY_SET_DETAILS(CMockString_ulARPRemoveCacheEntryByMac,CMockString_pxMACAddress);
    if (cmock_call_instance->Expected_pxMACAddress == NULL)
      { UNITY_TEST_ASSERT_NULL(pxMACAddress, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxMACAddress), (void*)(pxMACAddress), sizeof(const MACAddress_t), cmock_call_instance->Expected_pxMACAddress_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.ulARPRemoveCacheEntryByMac_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ulARPRemoveCacheEntryByMac_CallbackFunctionPointer(pxMACAddress, Mock.ulARPRemoveCacheEntryByMac_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ulARPRemoveCacheEntryByMac(CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE* cmock_call_instance, const MACAddress_t* pxMACAddress, int pxMACAddress_Depth)
{
  cmock_call_instance->Expected_pxMACAddress = pxMACAddress;
  cmock_call_instance->Expected_pxMACAddress_Depth = pxMACAddress_Depth;
  cmock_call_instance->IgnoreArg_pxMACAddress = 0;
}

void ulARPRemoveCacheEntryByMac_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE));
  CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulARPRemoveCacheEntryByMac_CallInstance = CMock_Guts_MemChain(Mock.ulARPRemoveCacheEntryByMac_CallInstance, cmock_guts_index);
  Mock.ulARPRemoveCacheEntryByMac_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ulARPRemoveCacheEntryByMac_IgnoreBool = (char)1;
}

void ulARPRemoveCacheEntryByMac_CMockStopIgnore(void)
{
  if(Mock.ulARPRemoveCacheEntryByMac_IgnoreBool)
    Mock.ulARPRemoveCacheEntryByMac_CallInstance = CMock_Guts_MemNext(Mock.ulARPRemoveCacheEntryByMac_CallInstance);
  Mock.ulARPRemoveCacheEntryByMac_IgnoreBool = (char)0;
}

void ulARPRemoveCacheEntryByMac_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE));
  CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulARPRemoveCacheEntryByMac_CallInstance = CMock_Guts_MemChain(Mock.ulARPRemoveCacheEntryByMac_CallInstance, cmock_guts_index);
  Mock.ulARPRemoveCacheEntryByMac_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void ulARPRemoveCacheEntryByMac_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const MACAddress_t* pxMACAddress, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE));
  CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulARPRemoveCacheEntryByMac_CallInstance = CMock_Guts_MemChain(Mock.ulARPRemoveCacheEntryByMac_CallInstance, cmock_guts_index);
  Mock.ulARPRemoveCacheEntryByMac_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_ulARPRemoveCacheEntryByMac(cmock_call_instance, pxMACAddress, 1);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ulARPRemoveCacheEntryByMac_AddCallback(CMOCK_ulARPRemoveCacheEntryByMac_CALLBACK Callback)
{
  Mock.ulARPRemoveCacheEntryByMac_IgnoreBool = (char)0;
  Mock.ulARPRemoveCacheEntryByMac_CallbackBool = (char)1;
  Mock.ulARPRemoveCacheEntryByMac_CallbackFunctionPointer = Callback;
}

void ulARPRemoveCacheEntryByMac_Stub(CMOCK_ulARPRemoveCacheEntryByMac_CALLBACK Callback)
{
  Mock.ulARPRemoveCacheEntryByMac_IgnoreBool = (char)0;
  Mock.ulARPRemoveCacheEntryByMac_CallbackBool = (char)0;
  Mock.ulARPRemoveCacheEntryByMac_CallbackFunctionPointer = Callback;
}

void ulARPRemoveCacheEntryByMac_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const MACAddress_t* pxMACAddress, int pxMACAddress_Depth, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE));
  CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ulARPRemoveCacheEntryByMac_CallInstance = CMock_Guts_MemChain(Mock.ulARPRemoveCacheEntryByMac_CallInstance, cmock_guts_index);
  Mock.ulARPRemoveCacheEntryByMac_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_ulARPRemoveCacheEntryByMac(cmock_call_instance, pxMACAddress, pxMACAddress_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ulARPRemoveCacheEntryByMac_CMockIgnoreArg_pxMACAddress(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_ulARPRemoveCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ulARPRemoveCacheEntryByMac_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxMACAddress = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xIsIPInARPCache
#else
BaseType_t xIsIPInARPCache(uint32_t ulAddressToLookup) __attribute__((weak));
#endif

BaseType_t xIsIPInARPCache(uint32_t ulAddressToLookup)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xIsIPInARPCache_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xIsIPInARPCache);
  cmock_call_instance = (CMOCK_xIsIPInARPCache_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xIsIPInARPCache_CallInstance);
  Mock.xIsIPInARPCache_CallInstance = CMock_Guts_MemNext(Mock.xIsIPInARPCache_CallInstance);
  if (Mock.xIsIPInARPCache_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xIsIPInARPCache_FinalReturn;
    memcpy((void*)(&Mock.xIsIPInARPCache_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xIsIPInARPCache_CallbackBool &&
      Mock.xIsIPInARPCache_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xIsIPInARPCache_CallbackFunctionPointer(ulAddressToLookup, Mock.xIsIPInARPCache_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ulAddressToLookup)
  {
    UNITY_SET_DETAILS(CMockString_xIsIPInARPCache,CMockString_ulAddressToLookup);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulAddressToLookup, ulAddressToLookup, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xIsIPInARPCache_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xIsIPInARPCache_CallbackFunctionPointer(ulAddressToLookup, Mock.xIsIPInARPCache_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xIsIPInARPCache(CMOCK_xIsIPInARPCache_CALL_INSTANCE* cmock_call_instance, uint32_t ulAddressToLookup)
{
  cmock_call_instance->Expected_ulAddressToLookup = ulAddressToLookup;
  cmock_call_instance->IgnoreArg_ulAddressToLookup = 0;
}

void xIsIPInARPCache_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xIsIPInARPCache_CALL_INSTANCE));
  CMOCK_xIsIPInARPCache_CALL_INSTANCE* cmock_call_instance = (CMOCK_xIsIPInARPCache_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xIsIPInARPCache_CallInstance = CMock_Guts_MemChain(Mock.xIsIPInARPCache_CallInstance, cmock_guts_index);
  Mock.xIsIPInARPCache_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xIsIPInARPCache_IgnoreBool = (char)1;
}

void xIsIPInARPCache_CMockStopIgnore(void)
{
  if(Mock.xIsIPInARPCache_IgnoreBool)
    Mock.xIsIPInARPCache_CallInstance = CMock_Guts_MemNext(Mock.xIsIPInARPCache_CallInstance);
  Mock.xIsIPInARPCache_IgnoreBool = (char)0;
}

void xIsIPInARPCache_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xIsIPInARPCache_CALL_INSTANCE));
  CMOCK_xIsIPInARPCache_CALL_INSTANCE* cmock_call_instance = (CMOCK_xIsIPInARPCache_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xIsIPInARPCache_CallInstance = CMock_Guts_MemChain(Mock.xIsIPInARPCache_CallInstance, cmock_guts_index);
  Mock.xIsIPInARPCache_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xIsIPInARPCache_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ulAddressToLookup, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xIsIPInARPCache_CALL_INSTANCE));
  CMOCK_xIsIPInARPCache_CALL_INSTANCE* cmock_call_instance = (CMOCK_xIsIPInARPCache_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xIsIPInARPCache_CallInstance = CMock_Guts_MemChain(Mock.xIsIPInARPCache_CallInstance, cmock_guts_index);
  Mock.xIsIPInARPCache_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xIsIPInARPCache(cmock_call_instance, ulAddressToLookup);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xIsIPInARPCache_AddCallback(CMOCK_xIsIPInARPCache_CALLBACK Callback)
{
  Mock.xIsIPInARPCache_IgnoreBool = (char)0;
  Mock.xIsIPInARPCache_CallbackBool = (char)1;
  Mock.xIsIPInARPCache_CallbackFunctionPointer = Callback;
}

void xIsIPInARPCache_Stub(CMOCK_xIsIPInARPCache_CALLBACK Callback)
{
  Mock.xIsIPInARPCache_IgnoreBool = (char)0;
  Mock.xIsIPInARPCache_CallbackBool = (char)0;
  Mock.xIsIPInARPCache_CallbackFunctionPointer = Callback;
}

void xIsIPInARPCache_CMockIgnoreArg_ulAddressToLookup(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xIsIPInARPCache_CALL_INSTANCE* cmock_call_instance = (CMOCK_xIsIPInARPCache_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xIsIPInARPCache_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulAddressToLookup = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xCheckRequiresARPResolution
#else
BaseType_t xCheckRequiresARPResolution(const NetworkBufferDescriptor_t* pxNetworkBuffer) __attribute__((weak));
#endif

BaseType_t xCheckRequiresARPResolution(const NetworkBufferDescriptor_t* pxNetworkBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xCheckRequiresARPResolution);
  cmock_call_instance = (CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xCheckRequiresARPResolution_CallInstance);
  Mock.xCheckRequiresARPResolution_CallInstance = CMock_Guts_MemNext(Mock.xCheckRequiresARPResolution_CallInstance);
  if (Mock.xCheckRequiresARPResolution_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xCheckRequiresARPResolution_FinalReturn;
    memcpy((void*)(&Mock.xCheckRequiresARPResolution_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xCheckRequiresARPResolution_CallbackBool &&
      Mock.xCheckRequiresARPResolution_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xCheckRequiresARPResolution_CallbackFunctionPointer(pxNetworkBuffer, Mock.xCheckRequiresARPResolution_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxNetworkBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xCheckRequiresARPResolution,CMockString_pxNetworkBuffer);
    if (cmock_call_instance->Expected_pxNetworkBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxNetworkBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxNetworkBuffer), (void*)(pxNetworkBuffer), sizeof(const NetworkBufferDescriptor_t), cmock_call_instance->Expected_pxNetworkBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.xCheckRequiresARPResolution_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xCheckRequiresARPResolution_CallbackFunctionPointer(pxNetworkBuffer, Mock.xCheckRequiresARPResolution_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xCheckRequiresARPResolution(CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE* cmock_call_instance, const NetworkBufferDescriptor_t* pxNetworkBuffer, int pxNetworkBuffer_Depth)
{
  cmock_call_instance->Expected_pxNetworkBuffer = pxNetworkBuffer;
  cmock_call_instance->Expected_pxNetworkBuffer_Depth = pxNetworkBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxNetworkBuffer = 0;
}

void xCheckRequiresARPResolution_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE));
  CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xCheckRequiresARPResolution_CallInstance = CMock_Guts_MemChain(Mock.xCheckRequiresARPResolution_CallInstance, cmock_guts_index);
  Mock.xCheckRequiresARPResolution_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xCheckRequiresARPResolution_IgnoreBool = (char)1;
}

void xCheckRequiresARPResolution_CMockStopIgnore(void)
{
  if(Mock.xCheckRequiresARPResolution_IgnoreBool)
    Mock.xCheckRequiresARPResolution_CallInstance = CMock_Guts_MemNext(Mock.xCheckRequiresARPResolution_CallInstance);
  Mock.xCheckRequiresARPResolution_IgnoreBool = (char)0;
}

void xCheckRequiresARPResolution_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE));
  CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xCheckRequiresARPResolution_CallInstance = CMock_Guts_MemChain(Mock.xCheckRequiresARPResolution_CallInstance, cmock_guts_index);
  Mock.xCheckRequiresARPResolution_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xCheckRequiresARPResolution_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const NetworkBufferDescriptor_t* pxNetworkBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE));
  CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xCheckRequiresARPResolution_CallInstance = CMock_Guts_MemChain(Mock.xCheckRequiresARPResolution_CallInstance, cmock_guts_index);
  Mock.xCheckRequiresARPResolution_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xCheckRequiresARPResolution(cmock_call_instance, pxNetworkBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xCheckRequiresARPResolution_AddCallback(CMOCK_xCheckRequiresARPResolution_CALLBACK Callback)
{
  Mock.xCheckRequiresARPResolution_IgnoreBool = (char)0;
  Mock.xCheckRequiresARPResolution_CallbackBool = (char)1;
  Mock.xCheckRequiresARPResolution_CallbackFunctionPointer = Callback;
}

void xCheckRequiresARPResolution_Stub(CMOCK_xCheckRequiresARPResolution_CALLBACK Callback)
{
  Mock.xCheckRequiresARPResolution_IgnoreBool = (char)0;
  Mock.xCheckRequiresARPResolution_CallbackBool = (char)0;
  Mock.xCheckRequiresARPResolution_CallbackFunctionPointer = Callback;
}

void xCheckRequiresARPResolution_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const NetworkBufferDescriptor_t* pxNetworkBuffer, int pxNetworkBuffer_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE));
  CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xCheckRequiresARPResolution_CallInstance = CMock_Guts_MemChain(Mock.xCheckRequiresARPResolution_CallInstance, cmock_guts_index);
  Mock.xCheckRequiresARPResolution_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xCheckRequiresARPResolution(cmock_call_instance, pxNetworkBuffer, pxNetworkBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xCheckRequiresARPResolution_CMockIgnoreArg_pxNetworkBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckRequiresARPResolution_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xCheckRequiresARPResolution_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxNetworkBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak eARPGetCacheEntry
#else
eARPLookupResult_t eARPGetCacheEntry(uint32_t* pulIPAddress, MACAddress_t* const pxMACAddress, struct xNetworkEndPoint** ppxEndPoint) __attribute__((weak));
#endif

eARPLookupResult_t eARPGetCacheEntry(uint32_t* pulIPAddress, MACAddress_t* const pxMACAddress, struct xNetworkEndPoint** ppxEndPoint)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_eARPGetCacheEntry);
  cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.eARPGetCacheEntry_CallInstance);
  Mock.eARPGetCacheEntry_CallInstance = CMock_Guts_MemNext(Mock.eARPGetCacheEntry_CallInstance);
  if (Mock.eARPGetCacheEntry_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.eARPGetCacheEntry_FinalReturn;
    memcpy((void*)(&Mock.eARPGetCacheEntry_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eARPLookupResult_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eARPLookupResult_t) ? 1 : -1])); /* add eARPLookupResult_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.eARPGetCacheEntry_CallbackBool &&
      Mock.eARPGetCacheEntry_CallbackFunctionPointer != NULL)
  {
    eARPLookupResult_t cmock_cb_ret = Mock.eARPGetCacheEntry_CallbackFunctionPointer(pulIPAddress, pxMACAddress, ppxEndPoint, Mock.eARPGetCacheEntry_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pulIPAddress)
  {
    UNITY_SET_DETAILS(CMockString_eARPGetCacheEntry,CMockString_pulIPAddress);
    if (cmock_call_instance->Expected_pulIPAddress == NULL)
      { UNITY_TEST_ASSERT_NULL(pulIPAddress, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulIPAddress, pulIPAddress, cmock_call_instance->Expected_pulIPAddress_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxMACAddress)
  {
    UNITY_SET_DETAILS(CMockString_eARPGetCacheEntry,CMockString_pxMACAddress);
    if (cmock_call_instance->Expected_pxMACAddress == NULL)
      { UNITY_TEST_ASSERT_NULL(pxMACAddress, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxMACAddress), (void*)(pxMACAddress), sizeof(MACAddress_t), cmock_call_instance->Expected_pxMACAddress_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ppxEndPoint)
  {
    UNITY_SET_DETAILS(CMockString_eARPGetCacheEntry,CMockString_ppxEndPoint);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxEndPoint, ppxEndPoint, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.eARPGetCacheEntry_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.eARPGetCacheEntry_CallbackFunctionPointer(pulIPAddress, pxMACAddress, ppxEndPoint, Mock.eARPGetCacheEntry_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pulIPAddress_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pulIPAddress, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pulIPAddress, (void*)cmock_call_instance->ReturnThruPtr_pulIPAddress_Val,
      cmock_call_instance->ReturnThruPtr_pulIPAddress_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxMACAddress_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxMACAddress, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxMACAddress, (void*)cmock_call_instance->ReturnThruPtr_pxMACAddress_Val,
      cmock_call_instance->ReturnThruPtr_pxMACAddress_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_ppxEndPoint_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxEndPoint, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxEndPoint, (void*)cmock_call_instance->ReturnThruPtr_ppxEndPoint_Val,
      cmock_call_instance->ReturnThruPtr_ppxEndPoint_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_eARPGetCacheEntry(CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance, uint32_t* pulIPAddress, int pulIPAddress_Depth, MACAddress_t* const pxMACAddress, int pxMACAddress_Depth, struct xNetworkEndPoint** ppxEndPoint, int ppxEndPoint_Depth)
{
  cmock_call_instance->Expected_pulIPAddress = pulIPAddress;
  cmock_call_instance->Expected_pulIPAddress_Depth = pulIPAddress_Depth;
  cmock_call_instance->IgnoreArg_pulIPAddress = 0;
  cmock_call_instance->ReturnThruPtr_pulIPAddress_Used = 0;
  cmock_call_instance->Expected_pxMACAddress = pxMACAddress;
  cmock_call_instance->Expected_pxMACAddress_Depth = pxMACAddress_Depth;
  cmock_call_instance->IgnoreArg_pxMACAddress = 0;
  cmock_call_instance->ReturnThruPtr_pxMACAddress_Used = 0;
  cmock_call_instance->Expected_ppxEndPoint = ppxEndPoint;
  cmock_call_instance->Expected_ppxEndPoint_Depth = ppxEndPoint_Depth;
  cmock_call_instance->IgnoreArg_ppxEndPoint = 0;
  cmock_call_instance->ReturnThruPtr_ppxEndPoint_Used = 0;
}

void eARPGetCacheEntry_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eARPLookupResult_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eARPGetCacheEntry_CALL_INSTANCE));
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eARPGetCacheEntry_CallInstance = CMock_Guts_MemChain(Mock.eARPGetCacheEntry_CallInstance, cmock_guts_index);
  Mock.eARPGetCacheEntry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.eARPGetCacheEntry_IgnoreBool = (char)1;
}

void eARPGetCacheEntry_CMockStopIgnore(void)
{
  if(Mock.eARPGetCacheEntry_IgnoreBool)
    Mock.eARPGetCacheEntry_CallInstance = CMock_Guts_MemNext(Mock.eARPGetCacheEntry_CallInstance);
  Mock.eARPGetCacheEntry_IgnoreBool = (char)0;
}

void eARPGetCacheEntry_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, eARPLookupResult_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eARPGetCacheEntry_CALL_INSTANCE));
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eARPGetCacheEntry_CallInstance = CMock_Guts_MemChain(Mock.eARPGetCacheEntry_CallInstance, cmock_guts_index);
  Mock.eARPGetCacheEntry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void eARPGetCacheEntry_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* pulIPAddress, MACAddress_t* const pxMACAddress, struct xNetworkEndPoint** ppxEndPoint, eARPLookupResult_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eARPGetCacheEntry_CALL_INSTANCE));
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eARPGetCacheEntry_CallInstance = CMock_Guts_MemChain(Mock.eARPGetCacheEntry_CallInstance, cmock_guts_index);
  Mock.eARPGetCacheEntry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_eARPGetCacheEntry(cmock_call_instance, pulIPAddress, 1, pxMACAddress, 1, ppxEndPoint, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eARPLookupResult_t[sizeof(cmock_to_return) == sizeof(eARPLookupResult_t) ? 1 : -1])); /* add eARPLookupResult_t to :treat_as_array if this causes an error */
}

void eARPGetCacheEntry_AddCallback(CMOCK_eARPGetCacheEntry_CALLBACK Callback)
{
  Mock.eARPGetCacheEntry_IgnoreBool = (char)0;
  Mock.eARPGetCacheEntry_CallbackBool = (char)1;
  Mock.eARPGetCacheEntry_CallbackFunctionPointer = Callback;
}

void eARPGetCacheEntry_Stub(CMOCK_eARPGetCacheEntry_CALLBACK Callback)
{
  Mock.eARPGetCacheEntry_IgnoreBool = (char)0;
  Mock.eARPGetCacheEntry_CallbackBool = (char)0;
  Mock.eARPGetCacheEntry_CallbackFunctionPointer = Callback;
}

void eARPGetCacheEntry_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t* pulIPAddress, int pulIPAddress_Depth, MACAddress_t* const pxMACAddress, int pxMACAddress_Depth, struct xNetworkEndPoint** ppxEndPoint, int ppxEndPoint_Depth, eARPLookupResult_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eARPGetCacheEntry_CALL_INSTANCE));
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eARPGetCacheEntry_CallInstance = CMock_Guts_MemChain(Mock.eARPGetCacheEntry_CallInstance, cmock_guts_index);
  Mock.eARPGetCacheEntry_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_eARPGetCacheEntry(cmock_call_instance, pulIPAddress, pulIPAddress_Depth, pxMACAddress, pxMACAddress_Depth, ppxEndPoint, ppxEndPoint_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void eARPGetCacheEntry_CMockReturnMemThruPtr_pulIPAddress(UNITY_LINE_TYPE cmock_line, uint32_t* pulIPAddress, int cmock_size)
{
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pulIPAddress_Used = 1;
  cmock_call_instance->ReturnThruPtr_pulIPAddress_Val = pulIPAddress;
  cmock_call_instance->ReturnThruPtr_pulIPAddress_Size = cmock_size;
}

void eARPGetCacheEntry_CMockReturnMemThruPtr_pxMACAddress(UNITY_LINE_TYPE cmock_line, MACAddress_t* pxMACAddress, int cmock_size)
{
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxMACAddress_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxMACAddress_Val = pxMACAddress;
  cmock_call_instance->ReturnThruPtr_pxMACAddress_Size = cmock_size;
}

void eARPGetCacheEntry_CMockReturnMemThruPtr_ppxEndPoint(UNITY_LINE_TYPE cmock_line, struct xNetworkEndPoint** ppxEndPoint, int cmock_size)
{
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxEndPoint_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxEndPoint_Val = ppxEndPoint;
  cmock_call_instance->ReturnThruPtr_ppxEndPoint_Size = cmock_size;
}

void eARPGetCacheEntry_CMockIgnoreArg_pulIPAddress(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pulIPAddress = 1;
}

void eARPGetCacheEntry_CMockIgnoreArg_pxMACAddress(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxMACAddress = 1;
}

void eARPGetCacheEntry_CMockIgnoreArg_ppxEndPoint(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eARPGetCacheEntry_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntry_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntry_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxEndPoint = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak eARPGetCacheEntryByMac
#else
eARPLookupResult_t eARPGetCacheEntryByMac(const MACAddress_t* const pxMACAddress, uint32_t* pulIPAddress, struct xNetworkInterface** ppxInterface) __attribute__((weak));
#endif

eARPLookupResult_t eARPGetCacheEntryByMac(const MACAddress_t* const pxMACAddress, uint32_t* pulIPAddress, struct xNetworkInterface** ppxInterface)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_eARPGetCacheEntryByMac);
  cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.eARPGetCacheEntryByMac_CallInstance);
  Mock.eARPGetCacheEntryByMac_CallInstance = CMock_Guts_MemNext(Mock.eARPGetCacheEntryByMac_CallInstance);
  if (Mock.eARPGetCacheEntryByMac_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.eARPGetCacheEntryByMac_FinalReturn;
    memcpy((void*)(&Mock.eARPGetCacheEntryByMac_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(eARPLookupResult_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(eARPLookupResult_t) ? 1 : -1])); /* add eARPLookupResult_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.eARPGetCacheEntryByMac_CallbackBool &&
      Mock.eARPGetCacheEntryByMac_CallbackFunctionPointer != NULL)
  {
    eARPLookupResult_t cmock_cb_ret = Mock.eARPGetCacheEntryByMac_CallbackFunctionPointer(pxMACAddress, pulIPAddress, ppxInterface, Mock.eARPGetCacheEntryByMac_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxMACAddress)
  {
    UNITY_SET_DETAILS(CMockString_eARPGetCacheEntryByMac,CMockString_pxMACAddress);
    if (cmock_call_instance->Expected_pxMACAddress == NULL)
      { UNITY_TEST_ASSERT_NULL(pxMACAddress, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxMACAddress), (void*)(pxMACAddress), sizeof(const MACAddress_t), cmock_call_instance->Expected_pxMACAddress_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pulIPAddress)
  {
    UNITY_SET_DETAILS(CMockString_eARPGetCacheEntryByMac,CMockString_pulIPAddress);
    if (cmock_call_instance->Expected_pulIPAddress == NULL)
      { UNITY_TEST_ASSERT_NULL(pulIPAddress, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulIPAddress, pulIPAddress, cmock_call_instance->Expected_pulIPAddress_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ppxInterface)
  {
    UNITY_SET_DETAILS(CMockString_eARPGetCacheEntryByMac,CMockString_ppxInterface);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxInterface, ppxInterface, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.eARPGetCacheEntryByMac_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.eARPGetCacheEntryByMac_CallbackFunctionPointer(pxMACAddress, pulIPAddress, ppxInterface, Mock.eARPGetCacheEntryByMac_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pulIPAddress_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pulIPAddress, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pulIPAddress, (void*)cmock_call_instance->ReturnThruPtr_pulIPAddress_Val,
      cmock_call_instance->ReturnThruPtr_pulIPAddress_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_ppxInterface_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxInterface, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxInterface, (void*)cmock_call_instance->ReturnThruPtr_ppxInterface_Val,
      cmock_call_instance->ReturnThruPtr_ppxInterface_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_eARPGetCacheEntryByMac(CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance, const MACAddress_t* const pxMACAddress, int pxMACAddress_Depth, uint32_t* pulIPAddress, int pulIPAddress_Depth, struct xNetworkInterface** ppxInterface, int ppxInterface_Depth)
{
  cmock_call_instance->Expected_pxMACAddress = pxMACAddress;
  cmock_call_instance->Expected_pxMACAddress_Depth = pxMACAddress_Depth;
  cmock_call_instance->IgnoreArg_pxMACAddress = 0;
  cmock_call_instance->Expected_pulIPAddress = pulIPAddress;
  cmock_call_instance->Expected_pulIPAddress_Depth = pulIPAddress_Depth;
  cmock_call_instance->IgnoreArg_pulIPAddress = 0;
  cmock_call_instance->ReturnThruPtr_pulIPAddress_Used = 0;
  cmock_call_instance->Expected_ppxInterface = ppxInterface;
  cmock_call_instance->Expected_ppxInterface_Depth = ppxInterface_Depth;
  cmock_call_instance->IgnoreArg_ppxInterface = 0;
  cmock_call_instance->ReturnThruPtr_ppxInterface_Used = 0;
}

void eARPGetCacheEntryByMac_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, eARPLookupResult_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE));
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eARPGetCacheEntryByMac_CallInstance = CMock_Guts_MemChain(Mock.eARPGetCacheEntryByMac_CallInstance, cmock_guts_index);
  Mock.eARPGetCacheEntryByMac_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.eARPGetCacheEntryByMac_IgnoreBool = (char)1;
}

void eARPGetCacheEntryByMac_CMockStopIgnore(void)
{
  if(Mock.eARPGetCacheEntryByMac_IgnoreBool)
    Mock.eARPGetCacheEntryByMac_CallInstance = CMock_Guts_MemNext(Mock.eARPGetCacheEntryByMac_CallInstance);
  Mock.eARPGetCacheEntryByMac_IgnoreBool = (char)0;
}

void eARPGetCacheEntryByMac_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, eARPLookupResult_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE));
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eARPGetCacheEntryByMac_CallInstance = CMock_Guts_MemChain(Mock.eARPGetCacheEntryByMac_CallInstance, cmock_guts_index);
  Mock.eARPGetCacheEntryByMac_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void eARPGetCacheEntryByMac_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const MACAddress_t* const pxMACAddress, uint32_t* pulIPAddress, struct xNetworkInterface** ppxInterface, eARPLookupResult_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE));
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eARPGetCacheEntryByMac_CallInstance = CMock_Guts_MemChain(Mock.eARPGetCacheEntryByMac_CallInstance, cmock_guts_index);
  Mock.eARPGetCacheEntryByMac_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_eARPGetCacheEntryByMac(cmock_call_instance, pxMACAddress, 1, pulIPAddress, 1, ppxInterface, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(eARPLookupResult_t[sizeof(cmock_to_return) == sizeof(eARPLookupResult_t) ? 1 : -1])); /* add eARPLookupResult_t to :treat_as_array if this causes an error */
}

void eARPGetCacheEntryByMac_AddCallback(CMOCK_eARPGetCacheEntryByMac_CALLBACK Callback)
{
  Mock.eARPGetCacheEntryByMac_IgnoreBool = (char)0;
  Mock.eARPGetCacheEntryByMac_CallbackBool = (char)1;
  Mock.eARPGetCacheEntryByMac_CallbackFunctionPointer = Callback;
}

void eARPGetCacheEntryByMac_Stub(CMOCK_eARPGetCacheEntryByMac_CALLBACK Callback)
{
  Mock.eARPGetCacheEntryByMac_IgnoreBool = (char)0;
  Mock.eARPGetCacheEntryByMac_CallbackBool = (char)0;
  Mock.eARPGetCacheEntryByMac_CallbackFunctionPointer = Callback;
}

void eARPGetCacheEntryByMac_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const MACAddress_t* const pxMACAddress, int pxMACAddress_Depth, uint32_t* pulIPAddress, int pulIPAddress_Depth, struct xNetworkInterface** ppxInterface, int ppxInterface_Depth, eARPLookupResult_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE));
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.eARPGetCacheEntryByMac_CallInstance = CMock_Guts_MemChain(Mock.eARPGetCacheEntryByMac_CallInstance, cmock_guts_index);
  Mock.eARPGetCacheEntryByMac_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_eARPGetCacheEntryByMac(cmock_call_instance, pxMACAddress, pxMACAddress_Depth, pulIPAddress, pulIPAddress_Depth, ppxInterface, ppxInterface_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void eARPGetCacheEntryByMac_CMockReturnMemThruPtr_pulIPAddress(UNITY_LINE_TYPE cmock_line, uint32_t* pulIPAddress, int cmock_size)
{
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntryByMac_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pulIPAddress_Used = 1;
  cmock_call_instance->ReturnThruPtr_pulIPAddress_Val = pulIPAddress;
  cmock_call_instance->ReturnThruPtr_pulIPAddress_Size = cmock_size;
}

void eARPGetCacheEntryByMac_CMockReturnMemThruPtr_ppxInterface(UNITY_LINE_TYPE cmock_line, struct xNetworkInterface** ppxInterface, int cmock_size)
{
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntryByMac_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxInterface_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxInterface_Val = ppxInterface;
  cmock_call_instance->ReturnThruPtr_ppxInterface_Size = cmock_size;
}

void eARPGetCacheEntryByMac_CMockIgnoreArg_pxMACAddress(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntryByMac_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxMACAddress = 1;
}

void eARPGetCacheEntryByMac_CMockIgnoreArg_pulIPAddress(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntryByMac_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pulIPAddress = 1;
}

void eARPGetCacheEntryByMac_CMockIgnoreArg_ppxInterface(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE* cmock_call_instance = (CMOCK_eARPGetCacheEntryByMac_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.eARPGetCacheEntryByMac_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxInterface = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vARPAgeCache
#else
void vARPAgeCache(void) __attribute__((weak));
#endif

void vARPAgeCache(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vARPAgeCache_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vARPAgeCache);
  cmock_call_instance = (CMOCK_vARPAgeCache_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vARPAgeCache_CallInstance);
  Mock.vARPAgeCache_CallInstance = CMock_Guts_MemNext(Mock.vARPAgeCache_CallInstance);
  if (Mock.vARPAgeCache_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vARPAgeCache_CallbackBool &&
      Mock.vARPAgeCache_CallbackFunctionPointer != NULL)
  {
    Mock.vARPAgeCache_CallbackFunctionPointer(Mock.vARPAgeCache_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vARPAgeCache_CallbackFunctionPointer != NULL)
  {
    Mock.vARPAgeCache_CallbackFunctionPointer(Mock.vARPAgeCache_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vARPAgeCache_CMockIgnore(void)
{
  Mock.vARPAgeCache_IgnoreBool = (char)1;
}

void vARPAgeCache_CMockStopIgnore(void)
{
  Mock.vARPAgeCache_IgnoreBool = (char)0;
}

void vARPAgeCache_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vARPAgeCache_CALL_INSTANCE));
  CMOCK_vARPAgeCache_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPAgeCache_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vARPAgeCache_CallInstance = CMock_Guts_MemChain(Mock.vARPAgeCache_CallInstance, cmock_guts_index);
  Mock.vARPAgeCache_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vARPAgeCache_AddCallback(CMOCK_vARPAgeCache_CALLBACK Callback)
{
  Mock.vARPAgeCache_IgnoreBool = (char)0;
  Mock.vARPAgeCache_CallbackBool = (char)1;
  Mock.vARPAgeCache_CallbackFunctionPointer = Callback;
}

void vARPAgeCache_Stub(CMOCK_vARPAgeCache_CALLBACK Callback)
{
  Mock.vARPAgeCache_IgnoreBool = (char)0;
  Mock.vARPAgeCache_CallbackBool = (char)0;
  Mock.vARPAgeCache_CallbackFunctionPointer = Callback;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vARPGenerateRequestPacket
#else
void vARPGenerateRequestPacket(NetworkBufferDescriptor_t* const pxNetworkBuffer) __attribute__((weak));
#endif

void vARPGenerateRequestPacket(NetworkBufferDescriptor_t* const pxNetworkBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vARPGenerateRequestPacket);
  cmock_call_instance = (CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vARPGenerateRequestPacket_CallInstance);
  Mock.vARPGenerateRequestPacket_CallInstance = CMock_Guts_MemNext(Mock.vARPGenerateRequestPacket_CallInstance);
  if (Mock.vARPGenerateRequestPacket_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vARPGenerateRequestPacket_CallbackBool &&
      Mock.vARPGenerateRequestPacket_CallbackFunctionPointer != NULL)
  {
    Mock.vARPGenerateRequestPacket_CallbackFunctionPointer(pxNetworkBuffer, Mock.vARPGenerateRequestPacket_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxNetworkBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vARPGenerateRequestPacket,CMockString_pxNetworkBuffer);
    if (cmock_call_instance->Expected_pxNetworkBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxNetworkBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxNetworkBuffer), (void*)(pxNetworkBuffer), sizeof(NetworkBufferDescriptor_t), cmock_call_instance->Expected_pxNetworkBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.vARPGenerateRequestPacket_CallbackFunctionPointer != NULL)
  {
    Mock.vARPGenerateRequestPacket_CallbackFunctionPointer(pxNetworkBuffer, Mock.vARPGenerateRequestPacket_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxNetworkBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxNetworkBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxNetworkBuffer, (void*)cmock_call_instance->ReturnThruPtr_pxNetworkBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxNetworkBuffer_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vARPGenerateRequestPacket(CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE* cmock_call_instance, NetworkBufferDescriptor_t* const pxNetworkBuffer, int pxNetworkBuffer_Depth)
{
  cmock_call_instance->Expected_pxNetworkBuffer = pxNetworkBuffer;
  cmock_call_instance->Expected_pxNetworkBuffer_Depth = pxNetworkBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxNetworkBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxNetworkBuffer_Used = 0;
}

void vARPGenerateRequestPacket_CMockIgnore(void)
{
  Mock.vARPGenerateRequestPacket_IgnoreBool = (char)1;
}

void vARPGenerateRequestPacket_CMockStopIgnore(void)
{
  Mock.vARPGenerateRequestPacket_IgnoreBool = (char)0;
}

void vARPGenerateRequestPacket_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE));
  CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vARPGenerateRequestPacket_CallInstance = CMock_Guts_MemChain(Mock.vARPGenerateRequestPacket_CallInstance, cmock_guts_index);
  Mock.vARPGenerateRequestPacket_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void vARPGenerateRequestPacket_CMockExpect(UNITY_LINE_TYPE cmock_line, NetworkBufferDescriptor_t* const pxNetworkBuffer)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE));
  CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vARPGenerateRequestPacket_CallInstance = CMock_Guts_MemChain(Mock.vARPGenerateRequestPacket_CallInstance, cmock_guts_index);
  Mock.vARPGenerateRequestPacket_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vARPGenerateRequestPacket(cmock_call_instance, pxNetworkBuffer, 1);
}

void vARPGenerateRequestPacket_AddCallback(CMOCK_vARPGenerateRequestPacket_CALLBACK Callback)
{
  Mock.vARPGenerateRequestPacket_IgnoreBool = (char)0;
  Mock.vARPGenerateRequestPacket_CallbackBool = (char)1;
  Mock.vARPGenerateRequestPacket_CallbackFunctionPointer = Callback;
}

void vARPGenerateRequestPacket_Stub(CMOCK_vARPGenerateRequestPacket_CALLBACK Callback)
{
  Mock.vARPGenerateRequestPacket_IgnoreBool = (char)0;
  Mock.vARPGenerateRequestPacket_CallbackBool = (char)0;
  Mock.vARPGenerateRequestPacket_CallbackFunctionPointer = Callback;
}

void vARPGenerateRequestPacket_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, NetworkBufferDescriptor_t* const pxNetworkBuffer, int pxNetworkBuffer_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE));
  CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vARPGenerateRequestPacket_CallInstance = CMock_Guts_MemChain(Mock.vARPGenerateRequestPacket_CallInstance, cmock_guts_index);
  Mock.vARPGenerateRequestPacket_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_vARPGenerateRequestPacket(cmock_call_instance, pxNetworkBuffer, pxNetworkBuffer_Depth);
}

void vARPGenerateRequestPacket_CMockReturnMemThruPtr_pxNetworkBuffer(UNITY_LINE_TYPE cmock_line, NetworkBufferDescriptor_t* pxNetworkBuffer, int cmock_size)
{
  CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vARPGenerateRequestPacket_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxNetworkBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxNetworkBuffer_Val = pxNetworkBuffer;
  cmock_call_instance->ReturnThruPtr_pxNetworkBuffer_Size = cmock_size;
}

void vARPGenerateRequestPacket_CMockIgnoreArg_pxNetworkBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPGenerateRequestPacket_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vARPGenerateRequestPacket_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxNetworkBuffer = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak vARPSendGratuitous
#else
void vARPSendGratuitous(void) __attribute__((weak));
#endif

void vARPSendGratuitous(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vARPSendGratuitous_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vARPSendGratuitous);
  cmock_call_instance = (CMOCK_vARPSendGratuitous_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vARPSendGratuitous_CallInstance);
  Mock.vARPSendGratuitous_CallInstance = CMock_Guts_MemNext(Mock.vARPSendGratuitous_CallInstance);
  if (Mock.vARPSendGratuitous_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vARPSendGratuitous_CallbackBool &&
      Mock.vARPSendGratuitous_CallbackFunctionPointer != NULL)
  {
    Mock.vARPSendGratuitous_CallbackFunctionPointer(Mock.vARPSendGratuitous_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.vARPSendGratuitous_CallbackFunctionPointer != NULL)
  {
    Mock.vARPSendGratuitous_CallbackFunctionPointer(Mock.vARPSendGratuitous_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void vARPSendGratuitous_CMockIgnore(void)
{
  Mock.vARPSendGratuitous_IgnoreBool = (char)1;
}

void vARPSendGratuitous_CMockStopIgnore(void)
{
  Mock.vARPSendGratuitous_IgnoreBool = (char)0;
}

void vARPSendGratuitous_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vARPSendGratuitous_CALL_INSTANCE));
  CMOCK_vARPSendGratuitous_CALL_INSTANCE* cmock_call_instance = (CMOCK_vARPSendGratuitous_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vARPSendGratuitous_CallInstance = CMock_Guts_MemChain(Mock.vARPSendGratuitous_CallInstance, cmock_guts_index);
  Mock.vARPSendGratuitous_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
}

void vARPSendGratuitous_AddCallback(CMOCK_vARPSendGratuitous_CALLBACK Callback)
{
  Mock.vARPSendGratuitous_IgnoreBool = (char)0;
  Mock.vARPSendGratuitous_CallbackBool = (char)1;
  Mock.vARPSendGratuitous_CallbackFunctionPointer = Callback;
}

void vARPSendGratuitous_Stub(CMOCK_vARPSendGratuitous_CALLBACK Callback)
{
  Mock.vARPSendGratuitous_IgnoreBool = (char)0;
  Mock.vARPSendGratuitous_CallbackBool = (char)0;
  Mock.vARPSendGratuitous_CallbackFunctionPointer = Callback;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak xCheckLoopback
#else
BaseType_t xCheckLoopback(NetworkBufferDescriptor_t* const pxDescriptor, BaseType_t bReleaseAfterSend) __attribute__((weak));
#endif

BaseType_t xCheckLoopback(NetworkBufferDescriptor_t* const pxDescriptor, BaseType_t bReleaseAfterSend)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xCheckLoopback);
  cmock_call_instance = (CMOCK_xCheckLoopback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xCheckLoopback_CallInstance);
  Mock.xCheckLoopback_CallInstance = CMock_Guts_MemNext(Mock.xCheckLoopback_CallInstance);
  if (Mock.xCheckLoopback_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xCheckLoopback_FinalReturn;
    memcpy((void*)(&Mock.xCheckLoopback_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xCheckLoopback_CallbackBool &&
      Mock.xCheckLoopback_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xCheckLoopback_CallbackFunctionPointer(pxDescriptor, bReleaseAfterSend, Mock.xCheckLoopback_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxDescriptor)
  {
    UNITY_SET_DETAILS(CMockString_xCheckLoopback,CMockString_pxDescriptor);
    if (cmock_call_instance->Expected_pxDescriptor == NULL)
      { UNITY_TEST_ASSERT_NULL(pxDescriptor, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxDescriptor), (void*)(pxDescriptor), sizeof(NetworkBufferDescriptor_t), cmock_call_instance->Expected_pxDescriptor_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_bReleaseAfterSend)
  {
    UNITY_SET_DETAILS(CMockString_xCheckLoopback,CMockString_bReleaseAfterSend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_bReleaseAfterSend), (void*)(&bReleaseAfterSend), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.xCheckLoopback_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xCheckLoopback_CallbackFunctionPointer(pxDescriptor, bReleaseAfterSend, Mock.xCheckLoopback_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxDescriptor_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxDescriptor, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxDescriptor, (void*)cmock_call_instance->ReturnThruPtr_pxDescriptor_Val,
      cmock_call_instance->ReturnThruPtr_pxDescriptor_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xCheckLoopback(CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance, NetworkBufferDescriptor_t* const pxDescriptor, int pxDescriptor_Depth, BaseType_t bReleaseAfterSend)
{
  cmock_call_instance->Expected_pxDescriptor = pxDescriptor;
  cmock_call_instance->Expected_pxDescriptor_Depth = pxDescriptor_Depth;
  cmock_call_instance->IgnoreArg_pxDescriptor = 0;
  cmock_call_instance->ReturnThruPtr_pxDescriptor_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_bReleaseAfterSend), (void*)(&bReleaseAfterSend),
         sizeof(BaseType_t[sizeof(bReleaseAfterSend) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_bReleaseAfterSend = 0;
}

void xCheckLoopback_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xCheckLoopback_CALL_INSTANCE));
  CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckLoopback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xCheckLoopback_CallInstance = CMock_Guts_MemChain(Mock.xCheckLoopback_CallInstance, cmock_guts_index);
  Mock.xCheckLoopback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xCheckLoopback_IgnoreBool = (char)1;
}

void xCheckLoopback_CMockStopIgnore(void)
{
  if(Mock.xCheckLoopback_IgnoreBool)
    Mock.xCheckLoopback_CallInstance = CMock_Guts_MemNext(Mock.xCheckLoopback_CallInstance);
  Mock.xCheckLoopback_IgnoreBool = (char)0;
}

void xCheckLoopback_CMockExpectAnyArgsAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xCheckLoopback_CALL_INSTANCE));
  CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckLoopback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xCheckLoopback_CallInstance = CMock_Guts_MemChain(Mock.xCheckLoopback_CallInstance, cmock_guts_index);
  Mock.xCheckLoopback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ReturnVal = cmock_to_return;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void xCheckLoopback_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NetworkBufferDescriptor_t* const pxDescriptor, BaseType_t bReleaseAfterSend, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xCheckLoopback_CALL_INSTANCE));
  CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckLoopback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xCheckLoopback_CallInstance = CMock_Guts_MemChain(Mock.xCheckLoopback_CallInstance, cmock_guts_index);
  Mock.xCheckLoopback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xCheckLoopback(cmock_call_instance, pxDescriptor, 1, bReleaseAfterSend);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xCheckLoopback_AddCallback(CMOCK_xCheckLoopback_CALLBACK Callback)
{
  Mock.xCheckLoopback_IgnoreBool = (char)0;
  Mock.xCheckLoopback_CallbackBool = (char)1;
  Mock.xCheckLoopback_CallbackFunctionPointer = Callback;
}

void xCheckLoopback_Stub(CMOCK_xCheckLoopback_CALLBACK Callback)
{
  Mock.xCheckLoopback_IgnoreBool = (char)0;
  Mock.xCheckLoopback_CallbackBool = (char)0;
  Mock.xCheckLoopback_CallbackFunctionPointer = Callback;
}

void xCheckLoopback_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, NetworkBufferDescriptor_t* const pxDescriptor, int pxDescriptor_Depth, BaseType_t bReleaseAfterSend, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xCheckLoopback_CALL_INSTANCE));
  CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckLoopback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xCheckLoopback_CallInstance = CMock_Guts_MemChain(Mock.xCheckLoopback_CallInstance, cmock_guts_index);
  Mock.xCheckLoopback_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_xCheckLoopback(cmock_call_instance, pxDescriptor, pxDescriptor_Depth, bReleaseAfterSend);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xCheckLoopback_CMockReturnMemThruPtr_pxDescriptor(UNITY_LINE_TYPE cmock_line, NetworkBufferDescriptor_t* pxDescriptor, int cmock_size)
{
  CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckLoopback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xCheckLoopback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxDescriptor_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxDescriptor_Val = pxDescriptor;
  cmock_call_instance->ReturnThruPtr_pxDescriptor_Size = cmock_size;
}

void xCheckLoopback_CMockIgnoreArg_pxDescriptor(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckLoopback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xCheckLoopback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxDescriptor = 1;
}

void xCheckLoopback_CMockIgnoreArg_bReleaseAfterSend(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xCheckLoopback_CALL_INSTANCE* cmock_call_instance = (CMOCK_xCheckLoopback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xCheckLoopback_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_bReleaseAfterSend = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak FreeRTOS_OutputARPRequest
#else
void FreeRTOS_OutputARPRequest(uint32_t ulIPAddress) __attribute__((weak));
#endif

void FreeRTOS_OutputARPRequest(uint32_t ulIPAddress)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_FreeRTOS_OutputARPRequest);
  cmock_call_instance = (CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.FreeRTOS_OutputARPRequest_CallInstance);
  Mock.FreeRTOS_OutputARPRequest_CallInstance = CMock_Guts_MemNext(Mock.FreeRTOS_OutputARPRequest_CallInstance);
  if (Mock.FreeRTOS_OutputARPRequest_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.FreeRTOS_OutputARPRequest_CallbackBool &&
      Mock.FreeRTOS_OutputARPRequest_CallbackFunctionPointer != NULL)
  {
    Mock.FreeRTOS_OutputARPRequest_CallbackFunctionPointer(ulIPAddress, Mock.FreeRTOS_OutputARPRequest_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_ulIPAddress)
  {
    UNITY_SET_DETAILS(CMockString_FreeRTOS_OutputARPRequest,CMockString_ulIPAddress);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulIPAddress, ulIPAddress, cmock_line, CMockStringMismatch);
  }
  }
  if (Mock.FreeRTOS_OutputARPRequest_CallbackFunctionPointer != NULL)
  {
    Mock.FreeRTOS_OutputARPRequest_CallbackFunctionPointer(ulIPAddress, Mock.FreeRTOS_OutputARPRequest_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_FreeRTOS_OutputARPRequest(CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE* cmock_call_instance, uint32_t ulIPAddress)
{
  cmock_call_instance->Expected_ulIPAddress = ulIPAddress;
  cmock_call_instance->IgnoreArg_ulIPAddress = 0;
}

void FreeRTOS_OutputARPRequest_CMockIgnore(void)
{
  Mock.FreeRTOS_OutputARPRequest_IgnoreBool = (char)1;
}

void FreeRTOS_OutputARPRequest_CMockStopIgnore(void)
{
  Mock.FreeRTOS_OutputARPRequest_IgnoreBool = (char)0;
}

void FreeRTOS_OutputARPRequest_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE));
  CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE* cmock_call_instance = (CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.FreeRTOS_OutputARPRequest_CallInstance = CMock_Guts_MemChain(Mock.FreeRTOS_OutputARPRequest_CallInstance, cmock_guts_index);
  Mock.FreeRTOS_OutputARPRequest_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void FreeRTOS_OutputARPRequest_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ulIPAddress)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE));
  CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE* cmock_call_instance = (CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.FreeRTOS_OutputARPRequest_CallInstance = CMock_Guts_MemChain(Mock.FreeRTOS_OutputARPRequest_CallInstance, cmock_guts_index);
  Mock.FreeRTOS_OutputARPRequest_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_FreeRTOS_OutputARPRequest(cmock_call_instance, ulIPAddress);
}

void FreeRTOS_OutputARPRequest_AddCallback(CMOCK_FreeRTOS_OutputARPRequest_CALLBACK Callback)
{
  Mock.FreeRTOS_OutputARPRequest_IgnoreBool = (char)0;
  Mock.FreeRTOS_OutputARPRequest_CallbackBool = (char)1;
  Mock.FreeRTOS_OutputARPRequest_CallbackFunctionPointer = Callback;
}

void FreeRTOS_OutputARPRequest_Stub(CMOCK_FreeRTOS_OutputARPRequest_CALLBACK Callback)
{
  Mock.FreeRTOS_OutputARPRequest_IgnoreBool = (char)0;
  Mock.FreeRTOS_OutputARPRequest_CallbackBool = (char)0;
  Mock.FreeRTOS_OutputARPRequest_CallbackFunctionPointer = Callback;
}

void FreeRTOS_OutputARPRequest_CMockIgnoreArg_ulIPAddress(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE* cmock_call_instance = (CMOCK_FreeRTOS_OutputARPRequest_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.FreeRTOS_OutputARPRequest_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulIPAddress = 1;
}

#if defined (__IAR_SYSTEMS_ICC__)
#pragma weak FreeRTOS_ClearARP
#else
void FreeRTOS_ClearARP(const struct xNetworkEndPoint* pxEndPoint) __attribute__((weak));
#endif

void FreeRTOS_ClearARP(const struct xNetworkEndPoint* pxEndPoint)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_FreeRTOS_ClearARP);
  cmock_call_instance = (CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.FreeRTOS_ClearARP_CallInstance);
  Mock.FreeRTOS_ClearARP_CallInstance = CMock_Guts_MemNext(Mock.FreeRTOS_ClearARP_CallInstance);
  if (Mock.FreeRTOS_ClearARP_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.FreeRTOS_ClearARP_CallbackBool &&
      Mock.FreeRTOS_ClearARP_CallbackFunctionPointer != NULL)
  {
    Mock.FreeRTOS_ClearARP_CallbackFunctionPointer(pxEndPoint, Mock.FreeRTOS_ClearARP_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->ExpectAnyArgsBool)
  {
  if (!cmock_call_instance->IgnoreArg_pxEndPoint)
  {
    UNITY_SET_DETAILS(CMockString_FreeRTOS_ClearARP,CMockString_pxEndPoint);
    if (cmock_call_instance->Expected_pxEndPoint == NULL)
      { UNITY_TEST_ASSERT_NULL(pxEndPoint, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxEndPoint), (void*)(pxEndPoint), sizeof(const struct xNetworkEndPoint), cmock_call_instance->Expected_pxEndPoint_Depth, cmock_line, CMockStringMismatch); }
  }
  }
  if (Mock.FreeRTOS_ClearARP_CallbackFunctionPointer != NULL)
  {
    Mock.FreeRTOS_ClearARP_CallbackFunctionPointer(pxEndPoint, Mock.FreeRTOS_ClearARP_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_FreeRTOS_ClearARP(CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE* cmock_call_instance, const struct xNetworkEndPoint* pxEndPoint, int pxEndPoint_Depth)
{
  cmock_call_instance->Expected_pxEndPoint = pxEndPoint;
  cmock_call_instance->Expected_pxEndPoint_Depth = pxEndPoint_Depth;
  cmock_call_instance->IgnoreArg_pxEndPoint = 0;
}

void FreeRTOS_ClearARP_CMockIgnore(void)
{
  Mock.FreeRTOS_ClearARP_IgnoreBool = (char)1;
}

void FreeRTOS_ClearARP_CMockStopIgnore(void)
{
  Mock.FreeRTOS_ClearARP_IgnoreBool = (char)0;
}

void FreeRTOS_ClearARP_CMockExpectAnyArgs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE));
  CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE* cmock_call_instance = (CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.FreeRTOS_ClearARP_CallInstance = CMock_Guts_MemChain(Mock.FreeRTOS_ClearARP_CallInstance, cmock_guts_index);
  Mock.FreeRTOS_ClearARP_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  cmock_call_instance->ExpectAnyArgsBool = (char)1;
}

void FreeRTOS_ClearARP_CMockExpect(UNITY_LINE_TYPE cmock_line, const struct xNetworkEndPoint* pxEndPoint)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE));
  CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE* cmock_call_instance = (CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.FreeRTOS_ClearARP_CallInstance = CMock_Guts_MemChain(Mock.FreeRTOS_ClearARP_CallInstance, cmock_guts_index);
  Mock.FreeRTOS_ClearARP_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_FreeRTOS_ClearARP(cmock_call_instance, pxEndPoint, 1);
}

void FreeRTOS_ClearARP_AddCallback(CMOCK_FreeRTOS_ClearARP_CALLBACK Callback)
{
  Mock.FreeRTOS_ClearARP_IgnoreBool = (char)0;
  Mock.FreeRTOS_ClearARP_CallbackBool = (char)1;
  Mock.FreeRTOS_ClearARP_CallbackFunctionPointer = Callback;
}

void FreeRTOS_ClearARP_Stub(CMOCK_FreeRTOS_ClearARP_CALLBACK Callback)
{
  Mock.FreeRTOS_ClearARP_IgnoreBool = (char)0;
  Mock.FreeRTOS_ClearARP_CallbackBool = (char)0;
  Mock.FreeRTOS_ClearARP_CallbackFunctionPointer = Callback;
}

void FreeRTOS_ClearARP_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, const struct xNetworkEndPoint* pxEndPoint, int pxEndPoint_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE));
  CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE* cmock_call_instance = (CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.FreeRTOS_ClearARP_CallInstance = CMock_Guts_MemChain(Mock.FreeRTOS_ClearARP_CallInstance, cmock_guts_index);
  Mock.FreeRTOS_ClearARP_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ExpectAnyArgsBool = (char)0;
  CMockExpectParameters_FreeRTOS_ClearARP(cmock_call_instance, pxEndPoint, pxEndPoint_Depth);
}

void FreeRTOS_ClearARP_CMockIgnoreArg_pxEndPoint(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE* cmock_call_instance = (CMOCK_FreeRTOS_ClearARP_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.FreeRTOS_ClearARP_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxEndPoint = 1;
}

