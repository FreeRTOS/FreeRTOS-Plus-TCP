<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_TCP_IP.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V4.2.0</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___t_c_p___i_p_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_TCP_IP.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Module which handles the TCP connections for FreeRTOS+TCP. It depends on <a class="el" href="_free_r_t_o_s___t_c_p___w_i_n_8c.html" title="Module which handles the TCP windowing schemes for FreeRTOS+TCP. Many functions have two versions - o...">FreeRTOS_TCP_WIN.c</a>, which handles the TCP windowing schemes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;queue.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Sockets.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Utils.h&quot;</code><br />
<code>#include &quot;FreeRTOS_UDP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DHCP.h&quot;</code><br />
<code>#include &quot;NetworkInterface.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ARP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_Reception.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_Transmission.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_State_Handling.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_Utils.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0f72e4a79a35a2d8e026e192ba26fabe"><td class="memItemLeft" align="right" valign="top">static IPv46_Address_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a0f72e4a79a35a2d8e026e192ba26fabe">xGetSourceAddrFromBuffer</a> (const uint8_t *const pucEthernetBuffer)</td></tr>
<tr class="memdesc:a0f72e4a79a35a2d8e026e192ba26fabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP frame agnostic helper to obtain the source IP Address from a buffer.  <br /></td></tr>
<tr class="separator:a0f72e4a79a35a2d8e026e192ba26fabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3663f3aa8c64835d9dc23c5209c78fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a3663f3aa8c64835d9dc23c5209c78fc2">vSocketCloseNextTime</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a3663f3aa8c64835d9dc23c5209c78fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket another time.  <br /></td></tr>
<tr class="separator:a3663f3aa8c64835d9dc23c5209c78fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea49984a2c87d90570ed0be8884a0f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a2ea49984a2c87d90570ed0be8884a0f4">vSocketListenNextTime</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a2ea49984a2c87d90570ed0be8884a0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postpone a call to <a class="el" href="_free_r_t_o_s___sockets_8c.html#a1718a2539e0de40d95472ea59859be5c" title="Request to put a socket in listen mode.">FreeRTOS_listen()</a> to avoid recursive calls.  <br /></td></tr>
<tr class="separator:a2ea49984a2c87d90570ed0be8884a0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0ad2de00346e1017a692e4da7c3f0c"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a6f0ad2de00346e1017a692e4da7c3f0c">xTCPSocketCheck</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a6f0ad2de00346e1017a692e4da7c3f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">As soon as a TCP socket timer expires, this function will be called (from xTCPTimerCheck). It can send a delayed ACK or new data.  <br /></td></tr>
<tr class="separator:a6f0ad2de00346e1017a692e4da7c3f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ac6964f3af632cb82f7710ad2bc923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a51ac6964f3af632cb82f7710ad2bc923">prvTCPTouchSocket</a> (<a class="el" href="structstruct.html">struct</a> xSOCKET *pxSocket)</td></tr>
<tr class="memdesc:a51ac6964f3af632cb82f7710ad2bc923"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Touch' the socket to keep it alive/updated.  <br /></td></tr>
<tr class="separator:a51ac6964f3af632cb82f7710ad2bc923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1a9dab690a8da963401fc218e5b6f5"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#ade1a9dab690a8da963401fc218e5b6f5">vTCPRemoveTCPChild</a> (const FreeRTOS_Socket_t *pxChildSocket)</td></tr>
<tr class="separator:ade1a9dab690a8da963401fc218e5b6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d34454b4f1d4b0a4f5e5b998fdf578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a97d34454b4f1d4b0a4f5e5b998fdf578">vTCPStateChange</a> (FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState)</td></tr>
<tr class="memdesc:a97d34454b4f1d4b0a4f5e5b998fdf578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changing to a new state. Centralised here to do specific actions such as resetting the alive timer, calling the user's OnConnect handler to notify that a socket has got (dis)connected, and setting bit to unblock a call to <a class="el" href="_free_r_t_o_s___sockets_8c.html#a659a570c1f1b5a11c17d816cb5541291" title="The select() statement: wait for an event to occur on any of the sockets included in a socket set and...">FreeRTOS_select()</a>.  <br /></td></tr>
<tr class="separator:a97d34454b4f1d4b0a4f5e5b998fdf578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74961b17b29f2fb0f4c8fa02222e6f96"><td class="memItemLeft" align="right" valign="top">TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a74961b17b29f2fb0f4c8fa02222e6f96">prvTCPNextTimeout</a> (<a class="el" href="structstruct.html">struct</a> xSOCKET *pxSocket)</td></tr>
<tr class="memdesc:a74961b17b29f2fb0f4c8fa02222e6f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate after how much time this socket needs to be checked again.  <br /></td></tr>
<tr class="separator:a74961b17b29f2fb0f4c8fa02222e6f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afd3312f86e44f4b4d95ab1e7bd34be"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a3afd3312f86e44f4b4d95ab1e7bd34be">xProcessReceivedTCPPacket</a> (NetworkBufferDescriptor_t *pxDescriptor)</td></tr>
<tr class="memdesc:a3afd3312f86e44f4b4d95ab1e7bd34be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the received TCP packet.  <br /></td></tr>
<tr class="separator:a3afd3312f86e44f4b4d95ab1e7bd34be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9d9857511e8c986d7eb52849cfe73d"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#abd9d9857511e8c986d7eb52849cfe73d">xTCPCheckNewClient</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:abd9d9857511e8c986d7eb52849cfe73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the API accept(), the user asks is there is a new client? As API's can not walk through the xBoundTCPSocketsList the IP-task will do this.  <br /></td></tr>
<tr class="separator:abd9d9857511e8c986d7eb52849cfe73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaddf1f62d216822a9551f5dbce968c01"><td class="memItemLeft" align="right" valign="top"><a id="aaddf1f62d216822a9551f5dbce968c01" name="aaddf1f62d216822a9551f5dbce968c01"></a>
static FreeRTOS_Socket_t *&#160;</td><td class="memItemRight" valign="bottom"><b>xSocketToClose</b> = NULL</td></tr>
<tr class="memdesc:aaddf1f62d216822a9551f5dbce968c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">When closing a socket an event is posted to the Network Event Queue. If the queue is full, then the event is not posted and the socket can be orphaned. To prevent this, the below variable is used to keep track of any socket which needs to be closed. This variable can be accessed by the IP task only. Thus, preventing any race condition. <br /></td></tr>
<tr class="separator:aaddf1f62d216822a9551f5dbce968c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37870f1d776a8d40cc804e12e3913a51"><td class="memItemLeft" align="right" valign="top"><a id="a37870f1d776a8d40cc804e12e3913a51" name="a37870f1d776a8d40cc804e12e3913a51"></a>
_static FreeRTOS_Socket_t *&#160;</td><td class="memItemRight" valign="bottom"><b>xSocketToListen</b> = NULL</td></tr>
<tr class="memdesc:a37870f1d776a8d40cc804e12e3913a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a connection is coming in on a reusable socket, and the SYN phase times out, the socket must be put back into eTCP_LISTEN mode, so it can accept a new connection again. This variable can be accessed by the IP task only. Thus, preventing any race condition. <br /></td></tr>
<tr class="separator:a37870f1d776a8d40cc804e12e3913a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Module which handles the TCP connections for FreeRTOS+TCP. It depends on <a class="el" href="_free_r_t_o_s___t_c_p___w_i_n_8c.html" title="Module which handles the TCP windowing schemes for FreeRTOS+TCP. Many functions have two versions - o...">FreeRTOS_TCP_WIN.c</a>, which handles the TCP windowing schemes. </p>
<p>Endianness: in this module all ports and IP addresses are stored in host byte-order, except fields in the IP-packets </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a0f72e4a79a35a2d8e026e192ba26fabe" name="a0f72e4a79a35a2d8e026e192ba26fabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f72e4a79a35a2d8e026e192ba26fabe">&#9670;&#160;</a></span>xGetSourceAddrFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IPv46_Address_t xGetSourceAddrFromBuffer </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>pucEthernetBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IP frame agnostic helper to obtain the source IP Address from a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucEthernetBuffer</td><td>The Ethernet buffer from which the source address will be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IPv46_Address_t struct containing the source IP address. </dd></dl>

</div>
</div>
<a id="a3663f3aa8c64835d9dc23c5209c78fc2" name="a3663f3aa8c64835d9dc23c5209c78fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3663f3aa8c64835d9dc23c5209c78fc2">&#9670;&#160;</a></span>vSocketCloseNextTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vSocketCloseNextTime </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the socket another time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ea49984a2c87d90570ed0be8884a0f4" name="a2ea49984a2c87d90570ed0be8884a0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea49984a2c87d90570ed0be8884a0f4">&#9670;&#160;</a></span>vSocketListenNextTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vSocketListenNextTime </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Postpone a call to <a class="el" href="_free_r_t_o_s___sockets_8c.html#a1718a2539e0de40d95472ea59859be5c" title="Request to put a socket in listen mode.">FreeRTOS_listen()</a> to avoid recursive calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket to be checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f0ad2de00346e1017a692e4da7c3f0c" name="a6f0ad2de00346e1017a692e4da7c3f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0ad2de00346e1017a692e4da7c3f0c">&#9670;&#160;</a></span>xTCPSocketCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xTCPSocketCheck </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As soon as a TCP socket timer expires, this function will be called (from xTCPTimerCheck). It can send a delayed ACK or new data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>socket to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative error code on failure. A negative value will be returned in case the hang-protection has put the socket in a wait-close state.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Sequence of calling (normally) : IP-Task: <a class="el" href="_free_r_t_o_s___sockets_8c.html#ad3802e1a3603f571bcb185f2afbd48de" title="A TCP timer has expired, now check all TCP sockets for:">xTCPTimerCheck()</a> // Check all sockets ( declared in <a class="el" href="_free_r_t_o_s___sockets_8c.html" title="Implements the Sockets API based on Berkeley sockets for the FreeRTOS+TCP network stack....">FreeRTOS_Sockets.c</a> ) <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a6f0ad2de00346e1017a692e4da7c3f0c" title="As soon as a TCP socket timer expires, this function will be called (from xTCPTimerCheck)....">xTCPSocketCheck()</a> // Either send a delayed ACK or call <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a59dbafb65b4cae84ca1a1b38f9f099fc" title="prvTCPSendPacket() will be called when the socket time-out has been reached.">prvTCPSendPacket()</a> <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a59dbafb65b4cae84ca1a1b38f9f099fc" title="prvTCPSendPacket() will be called when the socket time-out has been reached.">prvTCPSendPacket()</a> // Either send a SYN or call prvTCPSendRepeated ( regular messages ) <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a2b21901fdf5e29d55fa151a2f0d05f10" title="prvTCPSendRepeated will try to send a series of messages, as long as there is data to be sent and as ...">prvTCPSendRepeated()</a> // Send at most 8 messages on a row <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a> // Prepare for returning xNetworkInterfaceOutput() // Sends data to the NIC ( declared in portable/NetworkInterface/xxx ) </dd></dl>

</div>
</div>
<a id="a51ac6964f3af632cb82f7710ad2bc923" name="a51ac6964f3af632cb82f7710ad2bc923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ac6964f3af632cb82f7710ad2bc923">&#9670;&#160;</a></span>prvTCPTouchSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prvTCPTouchSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xSOCKET *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'Touch' the socket to keep it alive/updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket to be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is used for anti-hanging protection and TCP keep-alive messages. Called in two places: after receiving a packet and after a state change. The socket's alive timer may be reset. </dd></dl>

</div>
</div>
<a id="ade1a9dab690a8da963401fc218e5b6f5" name="ade1a9dab690a8da963401fc218e5b6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1a9dab690a8da963401fc218e5b6f5">&#9670;&#160;</a></span>vTCPRemoveTCPChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t vTCPRemoveTCPChild </td>
          <td>(</td>
          <td class="paramtype">const FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxChildSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>&lt; for server socket: child, for child socket: parent</p>

</div>
</div>
<a id="a97d34454b4f1d4b0a4f5e5b998fdf578" name="a97d34454b4f1d4b0a4f5e5b998fdf578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d34454b4f1d4b0a4f5e5b998fdf578">&#9670;&#160;</a></span>vTCPStateChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vTCPStateChange </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum eTCP_STATE&#160;</td>
          <td class="paramname"><em>eTCPState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changing to a new state. Centralised here to do specific actions such as resetting the alive timer, calling the user's OnConnect handler to notify that a socket has got (dis)connected, and setting bit to unblock a call to <a class="el" href="_free_r_t_o_s___sockets_8c.html#a659a570c1f1b5a11c17d816cb5541291" title="The select() statement: wait for an event to occur on any of the sockets included in a socket set and...">FreeRTOS_select()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket whose state we are trying to change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eTCPState</td><td>The state to which we want to change to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74961b17b29f2fb0f4c8fa02222e6f96" name="a74961b17b29f2fb0f4c8fa02222e6f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74961b17b29f2fb0f4c8fa02222e6f96">&#9670;&#160;</a></span>prvTCPNextTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TickType_t prvTCPNextTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xSOCKET *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate after how much time this socket needs to be checked again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of clock ticks before the timer expires. </dd></dl>

</div>
</div>
<a id="a3afd3312f86e44f4b4d95ab1e7bd34be" name="a3afd3312f86e44f4b4d95ab1e7bd34be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afd3312f86e44f4b4d95ab1e7bd34be">&#9670;&#160;</a></span>xProcessReceivedTCPPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xProcessReceivedTCPPacket </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxDescriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the received TCP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxDescriptor</td><td>The descriptor in which the TCP packet is held.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the processing of the packet was successful, then pdPASS is returned or else pdFAIL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>FreeRTOS_TCP_IP has only 2 public functions, this is the second one: <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a3afd3312f86e44f4b4d95ab1e7bd34be" title="Process the received TCP packet.">xProcessReceivedTCPPacket()</a> <a class="el" href="_free_r_t_o_s___t_c_p___state___handling_8c.html#ab9bdd210a90bd874dfbac809478edc93" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a> <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a4d4b994a274e87b07332b08353137ea5" title="Prepare an outgoing message, in case anything has to be sent.">prvTCPPrepareSend()</a> <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a> xNetworkInterfaceOutput() // Sends data to the NIC <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a2b21901fdf5e29d55fa151a2f0d05f10" title="prvTCPSendRepeated will try to send a series of messages, as long as there is data to be sent and as ...">prvTCPSendRepeated()</a> <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a> // Prepare for returning xNetworkInterfaceOutput() // Sends data to the NIC </dd></dl>

</div>
</div>
<a id="abd9d9857511e8c986d7eb52849cfe73d" name="abd9d9857511e8c986d7eb52849cfe73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9d9857511e8c986d7eb52849cfe73d">&#9670;&#160;</a></span>xTCPCheckNewClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xTCPCheckNewClient </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In the API accept(), the user asks is there is a new client? As API's can not walk through the xBoundTCPSocketsList the IP-task will do this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket for which the bound socket list will be iterated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if there is a new client, then pdTRUE is returned or else, pdFALSE. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html">FreeRTOS_TCP_IP.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
