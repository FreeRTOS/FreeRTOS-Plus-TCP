<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_ARP.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V4.2.0</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___a_r_p_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_ARP.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements the Address Resolution Protocol for the FreeRTOS+TCP network stack.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;queue.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Timers.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Sockets.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ARP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_UDP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DHCP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
<code>#include &quot;NetworkInterface.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Routing.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ND.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a22f53fd4d5218d841f6176b29603a955"><td class="memItemLeft" align="right" valign="top"><a id="a22f53fd4d5218d841f6176b29603a955" name="a22f53fd4d5218d841f6176b29603a955"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>arpMAX_ARP_AGE_BEFORE_NEW_ARP_REQUEST</b>&#160;&#160;&#160;( 3U )</td></tr>
<tr class="memdesc:a22f53fd4d5218d841f6176b29603a955"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the age of an entry in the ARP table reaches this value (it counts down to zero, so this is an old entry) an ARP request will be sent to see if the entry is still valid and can therefore be refreshed. <br /></td></tr>
<tr class="separator:a22f53fd4d5218d841f6176b29603a955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4eb297ab0d35cfe95b1879495a3d7f"><td class="memItemLeft" align="right" valign="top"><a id="a7b4eb297ab0d35cfe95b1879495a3d7f" name="a7b4eb297ab0d35cfe95b1879495a3d7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>arpGRATUITOUS_ARP_PERIOD</b>&#160;&#160;&#160;( pdMS_TO_TICKS( 20000U ) )</td></tr>
<tr class="memdesc:a7b4eb297ab0d35cfe95b1879495a3d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time between gratuitous ARPs. <br /></td></tr>
<tr class="separator:a7b4eb297ab0d35cfe95b1879495a3d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51f57e1abecd75f22c0d8eca8d87a4d"><td class="memItemLeft" align="right" valign="top"><a id="ad51f57e1abecd75f22c0d8eca8d87a4d" name="ad51f57e1abecd75f22c0d8eca8d87a4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>arpIP_CLASH_RESET_TIMEOUT_MS</b>&#160;&#160;&#160;10000U</td></tr>
<tr class="memdesc:ad51f57e1abecd75f22c0d8eca8d87a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">When there is another device which has the same IP address as the IP address of this device, a defensive ARP request should be sent out. However, according to RFC 5227 section 1.1, there must be a minimum interval of 10 seconds between consecutive defensive ARP packets. <br /></td></tr>
<tr class="separator:ad51f57e1abecd75f22c0d8eca8d87a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6df3b8e26c0a0849fa35199c82f714"><td class="memItemLeft" align="right" valign="top"><a id="a6a6df3b8e26c0a0849fa35199c82f714" name="a6a6df3b8e26c0a0849fa35199c82f714"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>arpIP_CLASH_MAX_RETRIES</b>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:a6a6df3b8e26c0a0849fa35199c82f714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of defensive ARPs to be sent for an ARP clash per arpIP_CLASH_RESET_TIMEOUT_MS period. The retries are limited to one as outlined by RFC 5227 section 2.4 part b. <br /></td></tr>
<tr class="separator:a6a6df3b8e26c0a0849fa35199c82f714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a06d6be4aeae648863fe666c92c62d420"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a06d6be4aeae648863fe666c92c62d420">vARPProcessPacketRequest</a> (ARPPacket_t *pxARPFrame, NetworkEndPoint_t *pxTargetEndPoint, uint32_t ulSenderProtocolAddress)</td></tr>
<tr class="memdesc:a06d6be4aeae648863fe666c92c62d420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an ARP request packets.  <br /></td></tr>
<tr class="separator:a06d6be4aeae648863fe666c92c62d420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8a842ffc68a87ebd34c4f29de807d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a1b8a842ffc68a87ebd34c4f29de807d3">vARPProcessPacketReply</a> (const ARPPacket_t *pxARPFrame, NetworkEndPoint_t *pxTargetEndPoint, uint32_t ulSenderProtocolAddress)</td></tr>
<tr class="memdesc:a1b8a842ffc68a87ebd34c4f29de807d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A device has sent an ARP reply, process it.  <br /></td></tr>
<tr class="separator:a1b8a842ffc68a87ebd34c4f29de807d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262210979a11be78350a1d6c056d16bd"><td class="memItemLeft" align="right" valign="top">static eARPLookupResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a262210979a11be78350a1d6c056d16bd">prvCacheLookup</a> (uint32_t ulAddressToLookup, MACAddress_t *const pxMACAddress, NetworkEndPoint_t **ppxEndPoint)</td></tr>
<tr class="memdesc:a262210979a11be78350a1d6c056d16bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup an IP address in the ARP cache.  <br /></td></tr>
<tr class="separator:a262210979a11be78350a1d6c056d16bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8197daa452a80977c45b6322bc4d9dfc"><td class="memItemLeft" align="right" valign="top">static eARPLookupResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a8197daa452a80977c45b6322bc4d9dfc">eARPGetCacheEntryGateWay</a> (uint32_t *pulIPAddress, MACAddress_t *const pxMACAddress, <a class="el" href="structstruct.html">struct</a> xNetworkEndPoint **ppxEndPoint)</td></tr>
<tr class="memdesc:a8197daa452a80977c45b6322bc4d9dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IPv4 address is apparently a web-address. Find a gateway..  <br /></td></tr>
<tr class="separator:a8197daa452a80977c45b6322bc4d9dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddd085b5a86f104d453b4f82b92c1f1"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#abddd085b5a86f104d453b4f82b92c1f1">prvFindCacheEntry</a> (const MACAddress_t *pxMACAddress, const uint32_t ulIPAddress, <a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *pxEndPoint, CacheLocation_t *pxLocation)</td></tr>
<tr class="memdesc:abddd085b5a86f104d453b4f82b92c1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The results of an ARP look-up shall be stored in the ARP cache. This helper function looks up the location.  <br /></td></tr>
<tr class="separator:abddd085b5a86f104d453b4f82b92c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9740f8ea6763013cfff8ba416c70184d"><td class="memItemLeft" align="right" valign="top">eFrameProcessingResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a9740f8ea6763013cfff8ba416c70184d">eARPProcessPacket</a> (const NetworkBufferDescriptor_t *pxNetworkBuffer)</td></tr>
<tr class="memdesc:a9740f8ea6763013cfff8ba416c70184d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the ARP packets.  <br /></td></tr>
<tr class="separator:a9740f8ea6763013cfff8ba416c70184d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc995bea37f826daf44d59f5bcd0fc7"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#afdc995bea37f826daf44d59f5bcd0fc7">xIsIPInARPCache</a> (uint32_t ulAddressToLookup)</td></tr>
<tr class="memdesc:afdc995bea37f826daf44d59f5bcd0fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an IP address is in the ARP cache.  <br /></td></tr>
<tr class="separator:afdc995bea37f826daf44d59f5bcd0fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a978aa66440ed327d71f7d4b2daa63"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#ae2a978aa66440ed327d71f7d4b2daa63">xCheckRequiresARPResolution</a> (const NetworkBufferDescriptor_t *pxNetworkBuffer)</td></tr>
<tr class="memdesc:ae2a978aa66440ed327d71f7d4b2daa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a packet needs ARP resolution if it is on local subnet. If required send an ARP request.  <br /></td></tr>
<tr class="separator:ae2a978aa66440ed327d71f7d4b2daa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858a966c87a449b18045ff5308f8f54f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a858a966c87a449b18045ff5308f8f54f">vARPRefreshCacheEntryAge</a> (const MACAddress_t *pxMACAddress, const uint32_t ulIPAddress)</td></tr>
<tr class="memdesc:a858a966c87a449b18045ff5308f8f54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for an IP-MAC couple in ARP cache and reset the 'age' field. If no match is found then no action will be taken.  <br /></td></tr>
<tr class="separator:a858a966c87a449b18045ff5308f8f54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0f48737ff3f80e204cbe24b0f807e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#afc0f48737ff3f80e204cbe24b0f807e0">vARPRefreshCacheEntry</a> (const MACAddress_t *pxMACAddress, const uint32_t ulIPAddress, <a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *pxEndPoint)</td></tr>
<tr class="memdesc:afc0f48737ff3f80e204cbe24b0f807e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/update the ARP cache entry MAC-address to IP-address mapping.  <br /></td></tr>
<tr class="separator:afc0f48737ff3f80e204cbe24b0f807e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9188e74e7a7fe3f9c2191206b1b4490b"><td class="memItemLeft" align="right" valign="top">eARPLookupResult_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a9188e74e7a7fe3f9c2191206b1b4490b">eARPGetCacheEntry</a> (uint32_t *pulIPAddress, MACAddress_t *const pxMACAddress, <a class="el" href="structstruct.html">struct</a> xNetworkEndPoint **ppxEndPoint)</td></tr>
<tr class="memdesc:a9188e74e7a7fe3f9c2191206b1b4490b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for ulIPAddress in the ARP cache.  <br /></td></tr>
<tr class="separator:a9188e74e7a7fe3f9c2191206b1b4490b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3934dd27e4d024ab7a14ed0c80b3cc"><td class="memItemLeft" align="right" valign="top"><a id="a3d3934dd27e4d024ab7a14ed0c80b3cc" name="a3d3934dd27e4d024ab7a14ed0c80b3cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vARPAgeCache</b> (void)</td></tr>
<tr class="memdesc:a3d3934dd27e4d024ab7a14ed0c80b3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to this function will update (or 'Age') the ARP cache entries. The function will also try to prevent a removal of entry by sending an ARP query. It will also check whether we are waiting on an ARP reply - if we are, then an ARP request will be re-sent. In case an ARP entry has 'Aged' to 0, it will be removed from the ARP cache. <br /></td></tr>
<tr class="separator:a3d3934dd27e4d024ab7a14ed0c80b3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96d87a3e4505229094bf3d81330c2f4"><td class="memItemLeft" align="right" valign="top"><a id="aa96d87a3e4505229094bf3d81330c2f4" name="aa96d87a3e4505229094bf3d81330c2f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vARPSendGratuitous</b> (void)</td></tr>
<tr class="memdesc:aa96d87a3e4505229094bf3d81330c2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a Gratuitous ARP packet to allow this node to announce the IP-MAC mapping to the entire network. <br /></td></tr>
<tr class="separator:aa96d87a3e4505229094bf3d81330c2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bebad74f19ae5b2e14dcaca2b79c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a42bebad74f19ae5b2e14dcaca2b79c59">FreeRTOS_OutputARPRequest_Multi</a> (NetworkEndPoint_t *pxEndPoint, uint32_t ulIPAddress)</td></tr>
<tr class="memdesc:a42bebad74f19ae5b2e14dcaca2b79c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and send an ARP request packet to given IPv4 endpoint.  <br /></td></tr>
<tr class="separator:a42bebad74f19ae5b2e14dcaca2b79c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ebc2f32c8cda6cdc24a265df2388c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a87ebc2f32c8cda6cdc24a265df2388c0">FreeRTOS_OutputARPRequest</a> (uint32_t ulIPAddress)</td></tr>
<tr class="memdesc:a87ebc2f32c8cda6cdc24a265df2388c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and send an ARP request packet.  <br /></td></tr>
<tr class="separator:a87ebc2f32c8cda6cdc24a265df2388c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7afccbd744a2ee150ddf209c5582bf"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a1b7afccbd744a2ee150ddf209c5582bf">xARPWaitResolution</a> (uint32_t ulIPAddress, TickType_t uxTicksToWait)</td></tr>
<tr class="memdesc:a1b7afccbd744a2ee150ddf209c5582bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for address resolution: look-up the IP-address in the ARP-cache, and if needed send an ARP request, and wait for a reply. This function is useful when called before <a class="el" href="_free_r_t_o_s___sockets_8c.html#a1493cacf34d993b8b87c41242d7fc6d1" title="Send data to a socket. The socket must have already been created by a successful call to FreeRTOS_soc...">FreeRTOS_sendto()</a>.  <br /></td></tr>
<tr class="separator:a1b7afccbd744a2ee150ddf209c5582bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27861e019fb0f3c1d5579f6806f75b4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#a27861e019fb0f3c1d5579f6806f75b4c">vARPGenerateRequestPacket</a> (NetworkBufferDescriptor_t *const pxNetworkBuffer)</td></tr>
<tr class="memdesc:a27861e019fb0f3c1d5579f6806f75b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an ARP request packet by copying various constant details to the buffer.  <br /></td></tr>
<tr class="separator:a27861e019fb0f3c1d5579f6806f75b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb26d6bbf0f442a076837c0427646ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html#acdb26d6bbf0f442a076837c0427646ea">FreeRTOS_ClearARP</a> (const <a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *pxEndPoint)</td></tr>
<tr class="memdesc:acdb26d6bbf0f442a076837c0427646ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to this function will clear the ARP cache.  <br /></td></tr>
<tr class="separator:acdb26d6bbf0f442a076837c0427646ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afdc43c741d35db756e9a4ca5cd064bf1"><td class="memItemLeft" align="right" valign="top"><a id="afdc43c741d35db756e9a4ca5cd064bf1" name="afdc43c741d35db756e9a4ca5cd064bf1"></a>
_static ARPCacheRow_t&#160;</td><td class="memItemRight" valign="bottom"><b>xARPCache</b> [ipconfigARP_CACHE_ENTRIES]</td></tr>
<tr class="memdesc:afdc43c741d35db756e9a4ca5cd064bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ARP cache. <br /></td></tr>
<tr class="separator:afdc43c741d35db756e9a4ca5cd064bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c3721b546b6d8021730dbc1d49c263"><td class="memItemLeft" align="right" valign="top"><a id="aa9c3721b546b6d8021730dbc1d49c263" name="aa9c3721b546b6d8021730dbc1d49c263"></a>
static TickType_t&#160;</td><td class="memItemRight" valign="bottom"><b>xLastGratuitousARPTime</b> = 0U</td></tr>
<tr class="memdesc:aa9c3721b546b6d8021730dbc1d49c263"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time at which the last gratuitous ARP was sent. Gratuitous ARPs are used to ensure ARP tables are up to date and to detect IP address conflicts. <br /></td></tr>
<tr class="separator:aa9c3721b546b6d8021730dbc1d49c263"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the Address Resolution Protocol for the FreeRTOS+TCP network stack. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a06d6be4aeae648863fe666c92c62d420" name="a06d6be4aeae648863fe666c92c62d420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d6be4aeae648863fe666c92c62d420">&#9670;&#160;</a></span>vARPProcessPacketRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vARPProcessPacketRequest </td>
          <td>(</td>
          <td class="paramtype">ARPPacket_t *&#160;</td>
          <td class="paramname"><em>pxARPFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkEndPoint_t *&#160;</td>
          <td class="paramname"><em>pxTargetEndPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulSenderProtocolAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process an ARP request packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxARPFrame</td><td>the complete ARP-frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxTargetEndPoint</td><td>the end-point that handles the peer's address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulSenderProtocolAddress</td><td>the IP-address of the sender. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b8a842ffc68a87ebd34c4f29de807d3" name="a1b8a842ffc68a87ebd34c4f29de807d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8a842ffc68a87ebd34c4f29de807d3">&#9670;&#160;</a></span>vARPProcessPacketReply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void vARPProcessPacketReply </td>
          <td>(</td>
          <td class="paramtype">const ARPPacket_t *&#160;</td>
          <td class="paramname"><em>pxARPFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkEndPoint_t *&#160;</td>
          <td class="paramname"><em>pxTargetEndPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulSenderProtocolAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A device has sent an ARP reply, process it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxARPFrame</td><td>The ARP packet received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxTargetEndPoint</td><td>The end-point on which it is received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulSenderProtocolAddress</td><td>The IPv4 address involved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a262210979a11be78350a1d6c056d16bd" name="a262210979a11be78350a1d6c056d16bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262210979a11be78350a1d6c056d16bd">&#9670;&#160;</a></span>prvCacheLookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static eARPLookupResult_t prvCacheLookup </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulAddressToLookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MACAddress_t *const&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkEndPoint_t **&#160;</td>
          <td class="paramname"><em>ppxEndPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup an IP address in the ARP cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulAddressToLookup</td><td>The 32-bit representation of an IP address to lookup. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxMACAddress</td><td>A pointer to MACAddress_t variable where, if there is an ARP cache hit, the MAC address corresponding to the IP address will be stored. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxEndPoint</td><td>a pointer to the end-point will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When the IP-address is found: eARPCacheHit, when not found: eARPCacheMiss, and when waiting for a ARP reply: eCantSendPacket. </dd></dl>

</div>
</div>
<a id="a8197daa452a80977c45b6322bc4d9dfc" name="a8197daa452a80977c45b6322bc4d9dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8197daa452a80977c45b6322bc4d9dfc">&#9670;&#160;</a></span>eARPGetCacheEntryGateWay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static eARPLookupResult_t eARPGetCacheEntryGateWay </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MACAddress_t *const&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xNetworkEndPoint **&#160;</td>
          <td class="paramname"><em>ppxEndPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The IPv4 address is apparently a web-address. Find a gateway.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pulIPAddress</td><td>The target IP-address. It may be replaced with the IP address of a gateway. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxMACAddress</td><td>In case the MAC-address is found in cache, it will be stored to the buffer provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppxEndPoint</td><td>The end-point of the gateway will be copy to the pointee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abddd085b5a86f104d453b4f82b92c1f1" name="abddd085b5a86f104d453b4f82b92c1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddd085b5a86f104d453b4f82b92c1f1">&#9670;&#160;</a></span>prvFindCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvFindCacheEntry </td>
          <td>(</td>
          <td class="paramtype">const MACAddress_t *&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *&#160;</td>
          <td class="paramname"><em>pxEndPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CacheLocation_t *&#160;</td>
          <td class="paramname"><em>pxLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The results of an ARP look-up shall be stored in the ARP cache. This helper function looks up the location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxMACAddress</td><td>The MAC-address belonging to the IP-address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>The IP-address of the entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEndPoint</td><td>The end-point that will stored in the table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pxLocation</td><td>The results of this search are written in this struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9740f8ea6763013cfff8ba416c70184d" name="a9740f8ea6763013cfff8ba416c70184d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9740f8ea6763013cfff8ba416c70184d">&#9670;&#160;</a></span>eARPProcessPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eFrameProcessingResult_t eARPProcessPacket </td>
          <td>(</td>
          <td class="paramtype">const NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process the ARP packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer with the packet to be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An enum which says whether to return the frame or to release it. </dd></dl>

</div>
</div>
<a id="afdc995bea37f826daf44d59f5bcd0fc7" name="afdc995bea37f826daf44d59f5bcd0fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc995bea37f826daf44d59f5bcd0fc7">&#9670;&#160;</a></span>xIsIPInARPCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xIsIPInARPCache </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulAddressToLookup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an IP address is in the ARP cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulAddressToLookup</td><td>The 32-bit representation of an IP address to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When the IP-address is found: pdTRUE, else pdFALSE. </dd></dl>

</div>
</div>
<a id="ae2a978aa66440ed327d71f7d4b2daa63" name="ae2a978aa66440ed327d71f7d4b2daa63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a978aa66440ed327d71f7d4b2daa63">&#9670;&#160;</a></span>xCheckRequiresARPResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xCheckRequiresARPResolution </td>
          <td>(</td>
          <td class="paramtype">const NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a packet needs ARP resolution if it is on local subnet. If required send an ARP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer with the packet to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the packet needs ARP resolution, pdFALSE otherwise. </dd></dl>

</div>
</div>
<a id="a858a966c87a449b18045ff5308f8f54f" name="a858a966c87a449b18045ff5308f8f54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858a966c87a449b18045ff5308f8f54f">&#9670;&#160;</a></span>vARPRefreshCacheEntryAge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vARPRefreshCacheEntryAge </td>
          <td>(</td>
          <td class="paramtype">const MACAddress_t *&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for an IP-MAC couple in ARP cache and reset the 'age' field. If no match is found then no action will be taken. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxMACAddress</td><td>Pointer to the MAC address whose entry needs to be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>the IP address whose corresponding entry needs to be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc0f48737ff3f80e204cbe24b0f807e0" name="afc0f48737ff3f80e204cbe24b0f807e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0f48737ff3f80e204cbe24b0f807e0">&#9670;&#160;</a></span>vARPRefreshCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vARPRefreshCacheEntry </td>
          <td>(</td>
          <td class="paramtype">const MACAddress_t *&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *&#160;</td>
          <td class="paramname"><em>pxEndPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add/update the ARP cache entry MAC-address to IP-address mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxMACAddress</td><td>Pointer to the MAC address whose mapping is being updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>32-bit representation of the IP-address whose mapping is being updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEndPoint</td><td>The end-point stored in the table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9188e74e7a7fe3f9c2191206b1b4490b" name="a9188e74e7a7fe3f9c2191206b1b4490b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9188e74e7a7fe3f9c2191206b1b4490b">&#9670;&#160;</a></span>eARPGetCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eARPLookupResult_t eARPGetCacheEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MACAddress_t *const&#160;</td>
          <td class="paramname"><em>pxMACAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xNetworkEndPoint **&#160;</td>
          <td class="paramname"><em>ppxEndPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for ulIPAddress in the ARP cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pulIPAddress</td><td>Pointer to the IP-address to be queried to the ARP cache. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pxMACAddress</td><td>Pointer to a MACAddress_t variable where the MAC address will be stored, if found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppxEndPoint</td><td>Pointer to the end-point of the gateway will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the IP address exists, copy the associated MAC address into pxMACAddress, refresh the ARP cache entry's age, and return eARPCacheHit. If the IP address does not exist in the ARP cache return eARPCacheMiss. If the packet cannot be sent for any reason (maybe DHCP is still in process, or the addressing needs a gateway but there isn't a gateway defined) then return eCantSendPacket. </dd></dl>

</div>
</div>
<a id="a42bebad74f19ae5b2e14dcaca2b79c59" name="a42bebad74f19ae5b2e14dcaca2b79c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bebad74f19ae5b2e14dcaca2b79c59">&#9670;&#160;</a></span>FreeRTOS_OutputARPRequest_Multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_OutputARPRequest_Multi </td>
          <td>(</td>
          <td class="paramtype">NetworkEndPoint_t *&#160;</td>
          <td class="paramname"><em>pxEndPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and send an ARP request packet to given IPv4 endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEndPoint</td><td>Endpoint through which the requests should be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>A 32-bit representation of the IP-address whose physical (MAC) address is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87ebc2f32c8cda6cdc24a265df2388c0" name="a87ebc2f32c8cda6cdc24a265df2388c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ebc2f32c8cda6cdc24a265df2388c0">&#9670;&#160;</a></span>FreeRTOS_OutputARPRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_OutputARPRequest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and send an ARP request packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>A 32-bit representation of the IP-address whose physical (MAC) address is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b7afccbd744a2ee150ddf209c5582bf" name="a1b7afccbd744a2ee150ddf209c5582bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7afccbd744a2ee150ddf209c5582bf">&#9670;&#160;</a></span>xARPWaitResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xARPWaitResolution </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxTicksToWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for address resolution: look-up the IP-address in the ARP-cache, and if needed send an ARP request, and wait for a reply. This function is useful when called before <a class="el" href="_free_r_t_o_s___sockets_8c.html#a1493cacf34d993b8b87c41242d7fc6d1" title="Send data to a socket. The socket must have already been created by a successful call to FreeRTOS_soc...">FreeRTOS_sendto()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ulIPAddress</td><td>The IP-address to look-up. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxTicksToWait</td><td>The maximum number of clock ticks to wait for a reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero when successful. </dd></dl>

</div>
</div>
<a id="a27861e019fb0f3c1d5579f6806f75b4c" name="a27861e019fb0f3c1d5579f6806f75b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27861e019fb0f3c1d5579f6806f75b4c">&#9670;&#160;</a></span>vARPGenerateRequestPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vARPGenerateRequestPacket </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t *const&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an ARP request packet by copying various constant details to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pxNetworkBuffer</td><td>Pointer to the buffer which has to be filled with the ARP request packet details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdb26d6bbf0f442a076837c0427646ea" name="acdb26d6bbf0f442a076837c0427646ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb26d6bbf0f442a076837c0427646ea">&#9670;&#160;</a></span>FreeRTOS_ClearARP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_ClearARP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *&#160;</td>
          <td class="paramname"><em>pxEndPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A call to this function will clear the ARP cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEndPoint</td><td>only clean entries with this end-point, or when NULL, clear the entire ARP cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="_free_r_t_o_s___a_r_p_8c.html">FreeRTOS_ARP.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
