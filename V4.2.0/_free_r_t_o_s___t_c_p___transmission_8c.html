<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_TCP_Transmission.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V4.2.0</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___t_c_p___transmission_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_TCP_Transmission.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Module which prepares the packet to be sent through a socket for FreeRTOS+TCP. It depends on <a class="el" href="_free_r_t_o_s___t_c_p___w_i_n_8c.html" title="Module which handles the TCP windowing schemes for FreeRTOS+TCP. Many functions have two versions - o...">FreeRTOS_TCP_WIN.c</a>, which handles the TCP windowing schemes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;queue.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Sockets.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;NetworkInterface.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ARP.h&quot;</code><br />
<code>#include &quot;FreeRTOSIPConfigDefaults.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_Reception.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_Transmission.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_State_Handling.h&quot;</code><br />
<code>#include &quot;FreeRTOS_TCP_Utils.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3ea0dd4d630dc26f7eb5b2db32b4616b"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a3ea0dd4d630dc26f7eb5b2db32b4616b">prvTCPMakeSurePrepared</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a3ea0dd4d630dc26f7eb5b2db32b4616b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the outgoing connection is already prepared, if not call <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a259d393932637c52fd7e1eb22c10b3c6" title="Let ARP look-up the MAC-address of the peer and initialise the first SYN packet.">prvTCPPrepareConnect()</a> to continue the preparation.  <br /></td></tr>
<tr class="separator:a3ea0dd4d630dc26f7eb5b2db32b4616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259d393932637c52fd7e1eb22c10b3c6"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a259d393932637c52fd7e1eb22c10b3c6">prvTCPPrepareConnect</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a259d393932637c52fd7e1eb22c10b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let ARP look-up the MAC-address of the peer and initialise the first SYN packet.  <br /></td></tr>
<tr class="separator:a259d393932637c52fd7e1eb22c10b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dbafb65b4cae84ca1a1b38f9f099fc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a59dbafb65b4cae84ca1a1b38f9f099fc">prvTCPSendPacket</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a59dbafb65b4cae84ca1a1b38f9f099fc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a59dbafb65b4cae84ca1a1b38f9f099fc" title="prvTCPSendPacket() will be called when the socket time-out has been reached.">prvTCPSendPacket()</a> will be called when the socket time-out has been reached.  <br /></td></tr>
<tr class="separator:a59dbafb65b4cae84ca1a1b38f9f099fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b21901fdf5e29d55fa151a2f0d05f10"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a2b21901fdf5e29d55fa151a2f0d05f10">prvTCPSendRepeated</a> (FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer)</td></tr>
<tr class="memdesc:a2b21901fdf5e29d55fa151a2f0d05f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">prvTCPSendRepeated will try to send a series of messages, as long as there is data to be sent and as long as the transmit window isn't full.  <br /></td></tr>
<tr class="separator:a2b21901fdf5e29d55fa151a2f0d05f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb0d2de80d881f555d3191973ccd69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69">prvTCPReturnPacket</a> (FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxDescriptor, uint32_t ulLen, BaseType_t xReleaseAfterSend)</td></tr>
<tr class="memdesc:a32cb0d2de80d881f555d3191973ccd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a real network buffer or to a TCP socket field called 'xTCP.xPacket'. A temporary xNetworkBuffer will be used to pass the data to the NIC.  <br /></td></tr>
<tr class="separator:a32cb0d2de80d881f555d3191973ccd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce20ac8db15356bd8a29f60ea781036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#acce20ac8db15356bd8a29f60ea781036">prvTCPReturn_CheckTCPWindow</a> (FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer, size_t uxIPHeaderSize)</td></tr>
<tr class="memdesc:acce20ac8db15356bd8a29f60ea781036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a>, this function will set the the window size on this side: 'xTCPHeader.usWindow'.  <br /></td></tr>
<tr class="separator:acce20ac8db15356bd8a29f60ea781036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab78a8fa1dbfc0a793a5abf60ebc407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a3ab78a8fa1dbfc0a793a5abf60ebc407">prvTCPReturn_SetSequenceNumber</a> (FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer, size_t uxIPHeaderSize, uint32_t ulLen)</td></tr>
<tr class="memdesc:a3ab78a8fa1dbfc0a793a5abf60ebc407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a>, this function sets the sequence and ack numbers in the TCP-header.  <br /></td></tr>
<tr class="separator:a3ab78a8fa1dbfc0a793a5abf60ebc407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e6f04f594cde189d5602323d95f3ed"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#ab6e6f04f594cde189d5602323d95f3ed">prvTCPCreateWindow</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:ab6e6f04f594cde189d5602323d95f3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the TCP window for the given socket.  <br /></td></tr>
<tr class="separator:ab6e6f04f594cde189d5602323d95f3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3d321465a45d65a96c7762cd5a8612"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#aed3d321465a45d65a96c7762cd5a8612">prvWinScaleFactor</a> (const FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:aed3d321465a45d65a96c7762cd5a8612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the window scaling factor for the TCP connection.  <br /></td></tr>
<tr class="separator:aed3d321465a45d65a96c7762cd5a8612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afda6d47aedbb3e2b57bf62cc7a96fc"><td class="memItemLeft" align="right" valign="top">UBaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a0afda6d47aedbb3e2b57bf62cc7a96fc">prvSetSynAckOptions</a> (FreeRTOS_Socket_t *pxSocket, TCPHeader_t *pxTCPHeader)</td></tr>
<tr class="memdesc:a0afda6d47aedbb3e2b57bf62cc7a96fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">When opening a TCP connection, while SYN's are being sent, the parties may communicate what MSS (Maximum Segment Size) they intend to use, whether Selective ACK's ( SACK ) are supported, and the size of the reception window ( WSOPT ).  <br /></td></tr>
<tr class="separator:a0afda6d47aedbb3e2b57bf62cc7a96fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa090f2ad2506d8e3336fc6f63278feb5"><td class="memItemLeft" align="right" valign="top">NetworkBufferDescriptor_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#aa090f2ad2506d8e3336fc6f63278feb5">prvTCPBufferResize</a> (const FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer, int32_t lDataLen, UBaseType_t uxOptionsLength)</td></tr>
<tr class="memdesc:aa090f2ad2506d8e3336fc6f63278feb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the size of a network buffer is big enough to hold the outgoing message. Allocate a new bigger network buffer when necessary.  <br /></td></tr>
<tr class="separator:aa090f2ad2506d8e3336fc6f63278feb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b27f066e7154969436da6382b624baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a4b27f066e7154969436da6382b624baa">prvTCPReturn_SetEndPoint</a> (const FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer, size_t uxIPHeaderSize)</td></tr>
<tr class="memdesc:a4b27f066e7154969436da6382b624baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a>, this function makes sure that the network buffer has 'pxEndPoint' set properly.  <br /></td></tr>
<tr class="separator:a4b27f066e7154969436da6382b624baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4b994a274e87b07332b08353137ea5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a4d4b994a274e87b07332b08353137ea5">prvTCPPrepareSend</a> (FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, UBaseType_t uxOptionsLength)</td></tr>
<tr class="memdesc:a4d4b994a274e87b07332b08353137ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare an outgoing message, in case anything has to be sent.  <br /></td></tr>
<tr class="separator:a4d4b994a274e87b07332b08353137ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9ad490c427652182bfe046f048f8ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a5b9ad490c427652182bfe046f048f8ff">prvTCPAddTxData</a> (FreeRTOS_Socket_t *pxSocket)</td></tr>
<tr class="memdesc:a5b9ad490c427652182bfe046f048f8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API <a class="el" href="_free_r_t_o_s___sockets_8c.html#abfb04a35d27c55380be674ebd8204351" title="Send data using a TCP socket. It is not necessary to have the socket connected already....">FreeRTOS_send()</a> adds data to the TX stream. Add this data to the windowing system to it can be transmitted.  <br /></td></tr>
<tr class="separator:a5b9ad490c427652182bfe046f048f8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab577a58c3cb609f3951777845581c06c"><td class="memItemLeft" align="right" valign="top">UBaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#ab577a58c3cb609f3951777845581c06c">prvSetOptions</a> (FreeRTOS_Socket_t *pxSocket, const NetworkBufferDescriptor_t *pxNetworkBuffer)</td></tr>
<tr class="memdesc:ab577a58c3cb609f3951777845581c06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TCP options (if any) for the outgoing packet.  <br /></td></tr>
<tr class="separator:ab577a58c3cb609f3951777845581c06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b74fbac3fa3e96746fa265b62850fa"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a99b74fbac3fa3e96746fa265b62850fa">prvSendData</a> (FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, uint32_t ulReceiveLength, BaseType_t xByteCount)</td></tr>
<tr class="memdesc:a99b74fbac3fa3e96746fa265b62850fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called from <a class="el" href="_free_r_t_o_s___t_c_p___state___handling_8c.html#ab9bdd210a90bd874dfbac809478edc93" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. There is data to be sent. If ipconfigUSE_TCP_WIN is defined, and if only an ACK must be sent, it will be checked if it would better be postponed for efficiency.  <br /></td></tr>
<tr class="separator:a99b74fbac3fa3e96746fa265b62850fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ecf89c3a0fc87aa1e5781bf47f88d9"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a53ecf89c3a0fc87aa1e5781bf47f88d9">prvTCPSendSpecialPacketHelper</a> (NetworkBufferDescriptor_t *pxNetworkBuffer, uint8_t ucTCPFlags)</td></tr>
<tr class="memdesc:a53ecf89c3a0fc87aa1e5781bf47f88d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common code for sending a TCP protocol control packet (i.e. no options, no payload, just flags).  <br /></td></tr>
<tr class="separator:a53ecf89c3a0fc87aa1e5781bf47f88d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9067b98a7ea9cc43c47c37301b87e15"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#aa9067b98a7ea9cc43c47c37301b87e15">prvTCPSendChallengeAck</a> (NetworkBufferDescriptor_t *pxNetworkBuffer)</td></tr>
<tr class="memdesc:aa9067b98a7ea9cc43c47c37301b87e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "challenge ACK" is as per <a href="https://tools.ietf.org/html/rfc5961#section-3.2">https://tools.ietf.org/html/rfc5961#section-3.2</a>, case #3. In summary, an RST was received with a sequence number that is unexpected but still within the window.  <br /></td></tr>
<tr class="separator:aa9067b98a7ea9cc43c47c37301b87e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bec9dce69a957e333a0294f95d8d3ab"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a8bec9dce69a957e333a0294f95d8d3ab">prvTCPSendReset</a> (NetworkBufferDescriptor_t *pxNetworkBuffer)</td></tr>
<tr class="memdesc:a8bec9dce69a957e333a0294f95d8d3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a RST (Reset) to peer in case the packet cannot be handled.  <br /></td></tr>
<tr class="separator:a8bec9dce69a957e333a0294f95d8d3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Module which prepares the packet to be sent through a socket for FreeRTOS+TCP. It depends on <a class="el" href="_free_r_t_o_s___t_c_p___w_i_n_8c.html" title="Module which handles the TCP windowing schemes for FreeRTOS+TCP. Many functions have two versions - o...">FreeRTOS_TCP_WIN.c</a>, which handles the TCP windowing schemes. </p>
<p>Endianness: in this module all ports and IP addresses are stored in host byte-order, except fields in the IP-packets </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3ea0dd4d630dc26f7eb5b2db32b4616b" name="a3ea0dd4d630dc26f7eb5b2db32b4616b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea0dd4d630dc26f7eb5b2db32b4616b">&#9670;&#160;</a></span>prvTCPMakeSurePrepared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPMakeSurePrepared </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the outgoing connection is already prepared, if not call <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a259d393932637c52fd7e1eb22c10b3c6" title="Let ARP look-up the MAC-address of the peer and initialise the first SYN packet.">prvTCPPrepareConnect()</a> to continue the preparation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket that wants to connect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns pdTRUE if the connection is prepared, i.e. the MAC- address of the peer is already known. </dd></dl>

</div>
</div>
<a id="a259d393932637c52fd7e1eb22c10b3c6" name="a259d393932637c52fd7e1eb22c10b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259d393932637c52fd7e1eb22c10b3c6">&#9670;&#160;</a></span>prvTCPPrepareConnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvTCPPrepareConnect </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Let ARP look-up the MAC-address of the peer and initialise the first SYN packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the TCP connection. The first packet shall be created in this socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE: if the packet was successfully created and the first SYN can be sent. Else pdFALSE.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Connecting sockets have a special state: eCONNECT_SYN. In this phase, the Ethernet address of the target will be found using ARP. In case the target IP address is not within the netmask, the hardware address of the gateway will be used. </dd></dl>

</div>
</div>
<a id="a59dbafb65b4cae84ca1a1b38f9f099fc" name="a59dbafb65b4cae84ca1a1b38f9f099fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dbafb65b4cae84ca1a1b38f9f099fc">&#9670;&#160;</a></span>prvTCPSendPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t prvTCPSendPacket </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a59dbafb65b4cae84ca1a1b38f9f099fc" title="prvTCPSendPacket() will be called when the socket time-out has been reached.">prvTCPSendPacket()</a> will be called when the socket time-out has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes to be sent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is only called by <a class="el" href="_free_r_t_o_s___t_c_p___i_p_8c.html#a6f0ad2de00346e1017a692e4da7c3f0c" title="As soon as a TCP socket timer expires, this function will be called (from xTCPTimerCheck)....">xTCPSocketCheck()</a>. </dd></dl>

</div>
</div>
<a id="a2b21901fdf5e29d55fa151a2f0d05f10" name="a2b21901fdf5e29d55fa151a2f0d05f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b21901fdf5e29d55fa151a2f0d05f10">&#9670;&#160;</a></span>prvTCPSendRepeated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t prvTCPSendRepeated </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkBufferDescriptor_t **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prvTCPSendRepeated will try to send a series of messages, as long as there is data to be sent and as long as the transmit window isn't full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxNetworkBuffer</td><td>Pointer to pointer to the network buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of bytes sent. </dd></dl>

</div>
</div>
<a id="a32cb0d2de80d881f555d3191973ccd69" name="a32cb0d2de80d881f555d3191973ccd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cb0d2de80d881f555d3191973ccd69">&#9670;&#160;</a></span>prvTCPReturnPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prvTCPReturnPacket </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xReleaseAfterSend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a real network buffer or to a TCP socket field called 'xTCP.xPacket'. A temporary xNetworkBuffer will be used to pass the data to the NIC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxDescriptor</td><td>The network buffer descriptor carrying the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulLen</td><td>Length of the packet being sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xReleaseAfterSend</td><td>pdTRUE if the ownership of the descriptor is transferred to the network interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acce20ac8db15356bd8a29f60ea781036" name="acce20ac8db15356bd8a29f60ea781036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce20ac8db15356bd8a29f60ea781036">&#9670;&#160;</a></span>prvTCPReturn_CheckTCPWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prvTCPReturn_CheckTCPWindow </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxIPHeaderSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a>, this function will set the the window size on this side: 'xTCPHeader.usWindow'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket on which the packet is being sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer carrying the outgoing message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIPHeaderSize</td><td>The size of the IP-header, which depends on the IP-type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ab78a8fa1dbfc0a793a5abf60ebc407" name="a3ab78a8fa1dbfc0a793a5abf60ebc407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab78a8fa1dbfc0a793a5abf60ebc407">&#9670;&#160;</a></span>prvTCPReturn_SetSequenceNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prvTCPReturn_SetSequenceNumber </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxIPHeaderSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a>, this function sets the sequence and ack numbers in the TCP-header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket on which the packet is being sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer carrying the outgoing message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIPHeaderSize</td><td>The size of the IP-header, which depends on the IP-type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulLen</td><td>The size of the packet minus the size of the Ethernet header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6e6f04f594cde189d5602323d95f3ed" name="ab6e6f04f594cde189d5602323d95f3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e6f04f594cde189d5602323d95f3ed">&#9670;&#160;</a></span>prvTCPCreateWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t prvTCPCreateWindow </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the TCP window for the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket for which the window is being created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The SYN event is very important: the sequence numbers, which have a kind of random starting value, are being synchronized. The sliding window manager (in <a class="el" href="_free_r_t_o_s___t_c_p___w_i_n_8c.html" title="Module which handles the TCP windowing schemes for FreeRTOS+TCP. Many functions have two versions - o...">FreeRTOS_TCP_WIN.c</a>) needs to know them, along with the Maximum Segment Size (MSS). </dd></dl>

</div>
</div>
<a id="aed3d321465a45d65a96c7762cd5a8612" name="aed3d321465a45d65a96c7762cd5a8612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3d321465a45d65a96c7762cd5a8612">&#9670;&#160;</a></span>prvWinScaleFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t prvWinScaleFactor </td>
          <td>(</td>
          <td class="paramtype">const FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the window scaling factor for the TCP connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the TCP connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaling factor. </dd></dl>

</div>
</div>
<a id="a0afda6d47aedbb3e2b57bf62cc7a96fc" name="a0afda6d47aedbb3e2b57bf62cc7a96fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afda6d47aedbb3e2b57bf62cc7a96fc">&#9670;&#160;</a></span>prvSetSynAckOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UBaseType_t prvSetSynAckOptions </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCPHeader_t *&#160;</td>
          <td class="paramname"><em>pxTCPHeader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When opening a TCP connection, while SYN's are being sent, the parties may communicate what MSS (Maximum Segment Size) they intend to use, whether Selective ACK's ( SACK ) are supported, and the size of the reception window ( WSOPT ). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket being used for communication. It is used to set the MSS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pxTCPHeader</td><td>The TCP packet header being used in the SYN transmission. The MSS and corresponding options shall be set in this header itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The option length after the TCP header was updated.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>MSS is the net size of the payload, an is always smaller than MTU. </dd></dl>

</div>
</div>
<a id="aa090f2ad2506d8e3336fc6f63278feb5" name="aa090f2ad2506d8e3336fc6f63278feb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa090f2ad2506d8e3336fc6f63278feb5">&#9670;&#160;</a></span>prvTCPBufferResize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetworkBufferDescriptor_t * prvTCPBufferResize </td>
          <td>(</td>
          <td class="paramtype">const FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>lDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxOptionsLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the size of a network buffer is big enough to hold the outgoing message. Allocate a new bigger network buffer when necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>Socket whose buffer is being resized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer whose size is being increased. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lDataLen</td><td>Length of the data to be put in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOptionsLength</td><td>Length of options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the resizing is successful: The new buffer with the size being asked for with old data copied in it. Else, NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The old network buffer will be released if the resizing is successful and cannot be used any longer. </dd></dl>

</div>
</div>
<a id="a4b27f066e7154969436da6382b624baa" name="a4b27f066e7154969436da6382b624baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b27f066e7154969436da6382b624baa">&#9670;&#160;</a></span>prvTCPReturn_SetEndPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prvTCPReturn_SetEndPoint </td>
          <td>(</td>
          <td class="paramtype">const FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxIPHeaderSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a32cb0d2de80d881f555d3191973ccd69" title="Return (or send) a packet to the peer. The data is stored in pxBuffer, which may either point to a re...">prvTCPReturnPacket()</a>, this function makes sure that the network buffer has 'pxEndPoint' set properly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket on which the packet is being sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer carrying the outgoing message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIPHeaderSize</td><td>The size of the IP-header, which depends on the IP-type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d4b994a274e87b07332b08353137ea5" name="a4d4b994a274e87b07332b08353137ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4b994a274e87b07332b08353137ea5">&#9670;&#160;</a></span>prvTCPPrepareSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t prvTCPPrepareSend </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkBufferDescriptor_t **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxOptionsLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare an outgoing message, in case anything has to be sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxNetworkBuffer</td><td>Pointer to the pointer to the network buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOptionsLength</td><td>The length of the TCP options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the data to be sent if everything is correct. Else, -1 is returned in case of any error. </dd></dl>

</div>
</div>
<a id="a5b9ad490c427652182bfe046f048f8ff" name="a5b9ad490c427652182bfe046f048f8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9ad490c427652182bfe046f048f8ff">&#9670;&#160;</a></span>prvTCPAddTxData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prvTCPAddTxData </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The API <a class="el" href="_free_r_t_o_s___sockets_8c.html#abfb04a35d27c55380be674ebd8204351" title="Send data using a TCP socket. It is not necessary to have the socket connected already....">FreeRTOS_send()</a> adds data to the TX stream. Add this data to the windowing system to it can be transmitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab577a58c3cb609f3951777845581c06c" name="ab577a58c3cb609f3951777845581c06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab577a58c3cb609f3951777845581c06c">&#9670;&#160;</a></span>prvSetOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UBaseType_t prvSetOptions </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the TCP options (if any) for the outgoing packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer holding the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the TCP options after they are set. </dd></dl>

</div>
</div>
<a id="a99b74fbac3fa3e96746fa265b62850fa" name="a99b74fbac3fa3e96746fa265b62850fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b74fbac3fa3e96746fa265b62850fa">&#9670;&#160;</a></span>prvSendData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t prvSendData </td>
          <td>(</td>
          <td class="paramtype">FreeRTOS_Socket_t *&#160;</td>
          <td class="paramname"><em>pxSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NetworkBufferDescriptor_t **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulReceiveLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called from <a class="el" href="_free_r_t_o_s___t_c_p___state___handling_8c.html#ab9bdd210a90bd874dfbac809478edc93" title="Check incoming packets for valid data and handle the state of the TCP connection and respond accordin...">prvTCPHandleState()</a>. There is data to be sent. If ipconfigUSE_TCP_WIN is defined, and if only an ACK must be sent, it will be checked if it would better be postponed for efficiency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSocket</td><td>The socket owning the TCP connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ppxNetworkBuffer</td><td>Pointer to pointer to the network buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ulReceiveLength</td><td>The length of the received buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xByteCount</td><td>Length of the data to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually sent. </dd></dl>

</div>
</div>
<a id="a53ecf89c3a0fc87aa1e5781bf47f88d9" name="a53ecf89c3a0fc87aa1e5781bf47f88d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ecf89c3a0fc87aa1e5781bf47f88d9">&#9670;&#160;</a></span>prvTCPSendSpecialPacketHelper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t prvTCPSendSpecialPacketHelper </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTCPFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common code for sending a TCP protocol control packet (i.e. no options, no payload, just flags). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer received from the peer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTCPFlags</td><td>The flags to determine what kind of packet this is.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL always indicating that the packet was not consumed. </dd></dl>

</div>
</div>
<a id="aa9067b98a7ea9cc43c47c37301b87e15" name="aa9067b98a7ea9cc43c47c37301b87e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9067b98a7ea9cc43c47c37301b87e15">&#9670;&#160;</a></span>prvTCPSendChallengeAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t prvTCPSendChallengeAck </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A "challenge ACK" is as per <a href="https://tools.ietf.org/html/rfc5961#section-3.2">https://tools.ietf.org/html/rfc5961#section-3.2</a>, case #3. In summary, an RST was received with a sequence number that is unexpected but still within the window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer descriptor with the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value back from <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a53ecf89c3a0fc87aa1e5781bf47f88d9" title="Common code for sending a TCP protocol control packet (i.e. no options, no payload,...">prvTCPSendSpecialPacketHelper</a>. </dd></dl>

</div>
</div>
<a id="a8bec9dce69a957e333a0294f95d8d3ab" name="a8bec9dce69a957e333a0294f95d8d3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bec9dce69a957e333a0294f95d8d3ab">&#9670;&#160;</a></span>prvTCPSendReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t prvTCPSendReset </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a RST (Reset) to peer in case the packet cannot be handled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer descriptor with the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value back from <a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html#a53ecf89c3a0fc87aa1e5781bf47f88d9" title="Common code for sending a TCP protocol control packet (i.e. no options, no payload,...">prvTCPSendSpecialPacketHelper</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="_free_r_t_o_s___t_c_p___transmission_8c.html">FreeRTOS_TCP_Transmission.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
