<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_DNS.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V4.3.0</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___d_n_s_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_DNS.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements the Domain Name System for the FreeRTOS+TCP network stack.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Timers.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;FreeRTOS_UDP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DHCP.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Routing.h&quot;</code><br />
<code>#include &quot;NetworkInterface.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS_Globals.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS_Cache.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS_Parser.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS_Networking.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS_Callback.h&quot;</code><br />
<code>#include &quot;pack_struct_start.h&quot;</code><br />
<code>#include &quot;pack_struct_end.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstruct.html">struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A DNS query consists of a header, as described in 'struct xDNSMessage' It is followed by 1 or more queries, each one consisting of a name and a tail, with two fields: type and class.  <a href="structstruct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1bff86ae7d967cab8be4d8369279dd75"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a1bff86ae7d967cab8be4d8369279dd75">prvCreateDNSMessage</a> (uint8_t *pucUDPPayloadBuffer, const char *pcHostName, TickType_t uxIdentifier, UBaseType_t uxHostType)</td></tr>
<tr class="memdesc:a1bff86ae7d967cab8be4d8369279dd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the DNS message in the zero copy buffer passed in the first parameter.  <br /></td></tr>
<tr class="separator:a1bff86ae7d967cab8be4d8369279dd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6518b8b614c65029b30532e54d2052fc"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a6518b8b614c65029b30532e54d2052fc">prvPrepareLookup</a> (const char *pcHostName, <a class="el" href="structstruct.html">struct</a> freertos_addrinfo **ppxAddressInfo, BaseType_t xFamily, FOnDNSEvent pCallbackFunction, void *pvSearchID, TickType_t uxTimeout)</td></tr>
<tr class="memdesc:a6518b8b614c65029b30532e54d2052fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if hostname is already known. If not, call <a class="el" href="_free_r_t_o_s___d_n_s_8c.html#aae00df5cb0d4351f877dd9c27cdca254" title="Prepare and send a message to a DNS server. &#39;uxReadTimeOut_ticks&#39; will be passed as zero,...">prvGetHostByName()</a> to send a DNS request.  <br /></td></tr>
<tr class="separator:a6518b8b614c65029b30532e54d2052fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae00df5cb0d4351f877dd9c27cdca254"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#aae00df5cb0d4351f877dd9c27cdca254">prvGetHostByName</a> (const char *pcHostName, TickType_t uxIdentifier, TickType_t uxReadTimeOut_ticks, <a class="el" href="structstruct.html">struct</a> freertos_addrinfo **ppxAddressInfo, BaseType_t xFamily)</td></tr>
<tr class="memdesc:aae00df5cb0d4351f877dd9c27cdca254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare and send a message to a DNS server. 'uxReadTimeOut_ticks' will be passed as zero, in case the user has supplied a call-back function.  <br /></td></tr>
<tr class="separator:aae00df5cb0d4351f877dd9c27cdca254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25ac051a64099fc2336de41526aee68"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#ad25ac051a64099fc2336de41526aee68">prvIncreaseDNS4Index</a> (NetworkEndPoint_t *pxEndPoint)</td></tr>
<tr class="memdesc:ad25ac051a64099fc2336de41526aee68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the field 'ucDNSIndex', which is an index in the array.  <br /></td></tr>
<tr class="separator:ad25ac051a64099fc2336de41526aee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e0f0cfa46b54efecf8089cf02c6701"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a14e0f0cfa46b54efecf8089cf02c6701">prvIncreaseDNS6Index</a> (NetworkEndPoint_t *pxEndPoint)</td></tr>
<tr class="memdesc:a14e0f0cfa46b54efecf8089cf02c6701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the field 'ucDNSIndex', which is an index in the array.  <br /></td></tr>
<tr class="separator:a14e0f0cfa46b54efecf8089cf02c6701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b77cb5028f171304f1535f7406766f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a71b77cb5028f171304f1535f7406766f">FreeRTOS_gethostbyname</a> (const char *pcHostName)</td></tr>
<tr class="memdesc:a71b77cb5028f171304f1535f7406766f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define <a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a71b77cb5028f171304f1535f7406766f" title="Define FreeRTOS_gethostbyname() as a normal blocking call.">FreeRTOS_gethostbyname()</a> as a normal blocking call.  <br /></td></tr>
<tr class="separator:a71b77cb5028f171304f1535f7406766f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cd6ab9c87ad7e087c0ec09b118c9b7"><td class="memItemLeft" align="right" valign="top"><a id="ad8cd6ab9c87ad7e087c0ec09b118c9b7" name="ad8cd6ab9c87ad7e087c0ec09b118c9b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vDNSInitialise</b> (void)</td></tr>
<tr class="memdesc:ad8cd6ab9c87ad7e087c0ec09b118c9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the list of call-back structures. <br /></td></tr>
<tr class="separator:ad8cd6ab9c87ad7e087c0ec09b118c9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6746bbebd1cca52f8a6d4cafcc5bbcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#ad6746bbebd1cca52f8a6d4cafcc5bbcf">FreeRTOS_gethostbyname_cancel</a> (void *pvSearchID)</td></tr>
<tr class="memdesc:ad6746bbebd1cca52f8a6d4cafcc5bbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the entry defined by the search ID to cancel a DNS request.  <br /></td></tr>
<tr class="separator:ad6746bbebd1cca52f8a6d4cafcc5bbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d1e7b3400b84a3babd9a4ccadcff1e"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a03d1e7b3400b84a3babd9a4ccadcff1e">FreeRTOS_getaddrinfo</a> (const char *pcName, const char *pcService, const <a class="el" href="structstruct.html">struct</a> freertos_addrinfo *pxHints, <a class="el" href="structstruct.html">struct</a> freertos_addrinfo **ppxResult)</td></tr>
<tr class="memdesc:a03d1e7b3400b84a3babd9a4ccadcff1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up the IP-address of a host.  <br /></td></tr>
<tr class="separator:a03d1e7b3400b84a3babd9a4ccadcff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c3f105cd946cc194c3f7e340868faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a23c3f105cd946cc194c3f7e340868faf">pxNew_AddrInfo</a> (const char *pcName, BaseType_t xFamily, const uint8_t *pucAddress)</td></tr>
<tr class="memdesc:a23c3f105cd946cc194c3f7e340868faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function: allocate and initialise a new struct of type freertos_addrinfo.  <br /></td></tr>
<tr class="separator:a23c3f105cd946cc194c3f7e340868faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c5f7fe9d7591f3e8054e5d80225995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a87c5f7fe9d7591f3e8054e5d80225995">FreeRTOS_freeaddrinfo</a> (<a class="el" href="structstruct.html">struct</a> freertos_addrinfo *pxInfo)</td></tr>
<tr class="memdesc:a87c5f7fe9d7591f3e8054e5d80225995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a chain of structs of type 'freertos_addrinfo'.  <br /></td></tr>
<tr class="separator:a87c5f7fe9d7591f3e8054e5d80225995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23d695ac8334f39dfd49db9268502d2"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#ab23d695ac8334f39dfd49db9268502d2">FreeRTOS_getaddrinfo_a</a> (const char *pcName, const char *pcService, const <a class="el" href="structstruct.html">struct</a> freertos_addrinfo *pxHints, <a class="el" href="structstruct.html">struct</a> freertos_addrinfo **ppxResult, FOnDNSEvent pCallback, void *pvSearchID, TickType_t uxTimeout)</td></tr>
<tr class="memdesc:ab23d695ac8334f39dfd49db9268502d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous version of getaddrinfo().  <br /></td></tr>
<tr class="separator:ab23d695ac8334f39dfd49db9268502d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585a2b637e9683132af556a2b3147ad0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a585a2b637e9683132af556a2b3147ad0">FreeRTOS_gethostbyname_a</a> (const char *pcHostName, FOnDNSEvent pCallback, void *pvSearchID, TickType_t uxTimeout)</td></tr>
<tr class="memdesc:a585a2b637e9683132af556a2b3147ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IP-address corresponding to the given hostname.  <br /></td></tr>
<tr class="separator:a585a2b637e9683132af556a2b3147ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83fd4564829d4495ee1345bb7de6ee7"><td class="memItemLeft" align="right" valign="top">static uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#ab83fd4564829d4495ee1345bb7de6ee7">prvGetPayloadBuffer</a> (NetworkBufferDescriptor_t **ppxNetworkBuffer, const char *pcHostName, size_t uxHeaderBytes)</td></tr>
<tr class="memdesc:ab83fd4564829d4495ee1345bb7de6ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a payload buffer and return it through the parameter  <br /></td></tr>
<tr class="separator:ab83fd4564829d4495ee1345bb7de6ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac912dabeefa1427f8ea2dae4ac390d9b"><td class="memItemLeft" align="right" valign="top">static NetworkEndPoint_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#ac912dabeefa1427f8ea2dae4ac390d9b">prvFillSockAddress</a> (<a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxAddress, const char *pcHostName)</td></tr>
<tr class="memdesc:ac912dabeefa1427f8ea2dae4ac390d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill pxAddress from pucUDPPayloadBuffer  <br /></td></tr>
<tr class="separator:ac912dabeefa1427f8ea2dae4ac390d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c4c2d5f3778e0994daed50802515eb"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a61c4c2d5f3778e0994daed50802515eb">prvDNSReply</a> (const <a class="el" href="structstruct.html">struct</a> xDNSBuffer *pxReceiveBuffer, <a class="el" href="structstruct.html">struct</a> freertos_addrinfo **ppxAddressInfo, TickType_t uxIdentifier, uint16_t usPort)</td></tr>
<tr class="memdesc:a61c4c2d5f3778e0994daed50802515eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return ip address from the dns reply message  <br /></td></tr>
<tr class="separator:a61c4c2d5f3778e0994daed50802515eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33866cbc083796274436528d88b5e3b"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#ab33866cbc083796274436528d88b5e3b">prvSendBuffer</a> (const char *pcHostName, TickType_t uxIdentifier, Socket_t xDNSSocket, BaseType_t xFamily, const <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *pxAddress)</td></tr>
<tr class="memdesc:ab33866cbc083796274436528d88b5e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepare the buffer before sending  <br /></td></tr>
<tr class="separator:ab33866cbc083796274436528d88b5e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a7649d02e497d1f35519a7ea533ec3"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a47a7649d02e497d1f35519a7ea533ec3">prvGetHostByNameOp</a> (const char *pcHostName, TickType_t uxIdentifier, Socket_t xDNSSocket, <a class="el" href="structstruct.html">struct</a> freertos_addrinfo **ppxAddressInfo, BaseType_t xFamily, TickType_t uxReadTimeOut_ticks)</td></tr>
<tr class="memdesc:a47a7649d02e497d1f35519a7ea533ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">main dns operation description function  <br /></td></tr>
<tr class="separator:a47a7649d02e497d1f35519a7ea533ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44442f1111fa24e375378dceaa91fa22"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a44442f1111fa24e375378dceaa91fa22">prvGetHostByNameOp_WithRetry</a> (const char *pcHostName, TickType_t uxIdentifier, Socket_t xDNSSocket, <a class="el" href="structstruct.html">struct</a> freertos_addrinfo **ppxAddressInfo, BaseType_t xFamily, TickType_t uxReadTimeOut_ticks)</td></tr>
<tr class="memdesc:a44442f1111fa24e375378dceaa91fa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to prvGetHostByNameOP with multiple retries equal to ipconfigDNS_REQUEST_ATTEMPTS  <br /></td></tr>
<tr class="separator:a44442f1111fa24e375378dceaa91fa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae560e9af4e296059183eb6ddbe9458a1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#ae560e9af4e296059183eb6ddbe9458a1">ulDNSHandlePacket</a> (const NetworkBufferDescriptor_t *pxNetworkBuffer)</td></tr>
<tr class="memdesc:ae560e9af4e296059183eb6ddbe9458a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform some preliminary checks and then parse the DNS packet.  <br /></td></tr>
<tr class="separator:ae560e9af4e296059183eb6ddbe9458a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da21a35903e781448c9d2bc89075beb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a9da21a35903e781448c9d2bc89075beb">ulNBNSHandlePacket</a> (NetworkBufferDescriptor_t *pxNetworkBuffer)</td></tr>
<tr class="memdesc:a9da21a35903e781448c9d2bc89075beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle an NBNS packet.  <br /></td></tr>
<tr class="separator:a9da21a35903e781448c9d2bc89075beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77247177eee55cde80f32bafe380ae7"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#aa77247177eee55cde80f32bafe380ae7">FreeRTOS_SetDNSIPPreference</a> (IPPreference_t eIPPreference)</td></tr>
<tr class="memdesc:aa77247177eee55cde80f32bafe380ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the DNS IP preference while doing DNS lookup to indicate the preference for a DNS server: either IPv4 or IPv6. Defaults to xPreferenceIPv4.  <br /></td></tr>
<tr class="separator:aa77247177eee55cde80f32bafe380ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af63a177ae183fc7ce8275622fe811f88"><td class="memItemLeft" align="right" valign="top"><a id="af63a177ae183fc7ce8275622fe811f88" name="af63a177ae183fc7ce8275622fe811f88"></a>
const MACAddress_t&#160;</td><td class="memItemRight" valign="bottom"><b>xLLMNR_MacAddress</b> = { { 0x01, 0x00, 0x5e, 0x00, 0x00, 0xfc } }</td></tr>
<tr class="memdesc:af63a177ae183fc7ce8275622fe811f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MAC address used for LLMNR. <br /></td></tr>
<tr class="separator:af63a177ae183fc7ce8275622fe811f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b9cdc1a1247aa85df23eabdc927539"><td class="memItemLeft" align="right" valign="top"><a id="a82b9cdc1a1247aa85df23eabdc927539" name="a82b9cdc1a1247aa85df23eabdc927539"></a>
const MACAddress_t&#160;</td><td class="memItemRight" valign="bottom"><b>xLLMNR_MacAddressIPv6</b> = { { 0x33, 0x33, 0x00, 0x01, 0x00, 0x03 } }</td></tr>
<tr class="memdesc:a82b9cdc1a1247aa85df23eabdc927539"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IPv6 link-scope multicast MAC address. <br /></td></tr>
<tr class="separator:a82b9cdc1a1247aa85df23eabdc927539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd3cd50dbeb75c98d82d6850019f1cf"><td class="memItemLeft" align="right" valign="top">const IPv6_Address_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a7fd3cd50dbeb75c98d82d6850019f1cf">ipLLMNR_IP_ADDR_IPv6</a></td></tr>
<tr class="memdesc:a7fd3cd50dbeb75c98d82d6850019f1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IPv6 link-scope multicast address.  <br /></td></tr>
<tr class="separator:a7fd3cd50dbeb75c98d82d6850019f1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640abe8a906f6ed9637f697bc529afb9"><td class="memItemLeft" align="right" valign="top"><a id="a640abe8a906f6ed9637f697bc529afb9" name="a640abe8a906f6ed9637f697bc529afb9"></a>
const MACAddress_t&#160;</td><td class="memItemRight" valign="bottom"><b>xMDNS_MacAddress</b> = { { 0x01, 0x00, 0x5e, 0x00, 0x00, 0xfb } }</td></tr>
<tr class="memdesc:a640abe8a906f6ed9637f697bc529afb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MAC address used for MDNS. <br /></td></tr>
<tr class="separator:a640abe8a906f6ed9637f697bc529afb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40098d119b1bb80059a0b76d03f6a2a7"><td class="memItemLeft" align="right" valign="top"><a id="a40098d119b1bb80059a0b76d03f6a2a7" name="a40098d119b1bb80059a0b76d03f6a2a7"></a>
const MACAddress_t&#160;</td><td class="memItemRight" valign="bottom"><b>xMDNS_MacAddressIPv6</b> = { { 0x33, 0x33, 0x00, 0x00, 0x00, 0xFB } }</td></tr>
<tr class="memdesc:a40098d119b1bb80059a0b76d03f6a2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IPv6 multicast DNS MAC address. <br /></td></tr>
<tr class="separator:a40098d119b1bb80059a0b76d03f6a2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f44bf35c84240e99e18ea5db2938c2"><td class="memItemLeft" align="right" valign="top"><a id="a66f44bf35c84240e99e18ea5db2938c2" name="a66f44bf35c84240e99e18ea5db2938c2"></a>
IPPreference_t&#160;</td><td class="memItemRight" valign="bottom"><b>xDNS_IP_Preference</b> = xPreferenceIPv4</td></tr>
<tr class="memdesc:a66f44bf35c84240e99e18ea5db2938c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This global variable is being used to indicate to the driver which IP type is preferred for name service lookup, either IPv6 or IPv4. <br /></td></tr>
<tr class="separator:a66f44bf35c84240e99e18ea5db2938c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the Domain Name System for the FreeRTOS+TCP network stack. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1bff86ae7d967cab8be4d8369279dd75" name="a1bff86ae7d967cab8be4d8369279dd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bff86ae7d967cab8be4d8369279dd75">&#9670;&#160;</a></span>prvCreateDNSMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t prvCreateDNSMessage </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucUDPPayloadBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UBaseType_t&#160;</td>
          <td class="paramname"><em>uxHostType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the DNS message in the zero copy buffer passed in the first parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pucUDPPayloadBuffer</td><td>The zero copy buffer where the DNS message will be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>Hostname to be looked up. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIdentifier</td><td>Identifier to match sent and received packets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxHostType</td><td>dnsTYPE_A_HOST ( IPv4 ) or dnsTYPE_AAAA_HOST ( IPv6 ). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size of the generated message, which is the space from the last written byte to the beginning of the buffer. </dd></dl>

</div>
</div>
<a id="a6518b8b614c65029b30532e54d2052fc" name="a6518b8b614c65029b30532e54d2052fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6518b8b614c65029b30532e54d2052fc">&#9670;&#160;</a></span>prvPrepareLookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t prvPrepareLookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo **&#160;</td>
          <td class="paramname"><em>ppxAddressInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnDNSEvent&#160;</td>
          <td class="paramname"><em>pCallbackFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvSearchID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if hostname is already known. If not, call <a class="el" href="_free_r_t_o_s___d_n_s_8c.html#aae00df5cb0d4351f877dd9c27cdca254" title="Prepare and send a message to a DNS server. &#39;uxReadTimeOut_ticks&#39; will be passed as zero,...">prvGetHostByName()</a> to send a DNS request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>The hostname whose IP address is being queried. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxAddressInfo</td><td>A pointer to a pointer where the find results will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFamily</td><td>indicate what type of record is needed: FREERTOS_AF_INET4 or FREERTOS_AF_INET6. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCallbackFunction</td><td>The callback function which will be called upon DNS response. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvSearchID</td><td>Search ID for the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxTimeout</td><td>Timeout for the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IP-address corresponding to the hostname. </dd></dl>

</div>
</div>
<a id="aae00df5cb0d4351f877dd9c27cdca254" name="aae00df5cb0d4351f877dd9c27cdca254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae00df5cb0d4351f877dd9c27cdca254">&#9670;&#160;</a></span>prvGetHostByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t prvGetHostByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxReadTimeOut_ticks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo **&#160;</td>
          <td class="paramname"><em>ppxAddressInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFamily</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare and send a message to a DNS server. 'uxReadTimeOut_ticks' will be passed as zero, in case the user has supplied a call-back function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>The hostname for which an IP address is required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIdentifier</td><td>Identifier to match sent and received packets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxReadTimeOut_ticks</td><td>The timeout in ticks for waiting. In case the user has supplied a call-back function, this value should be zero. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxAddressInfo</td><td>A pointer to a pointer where the find results will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFamily</td><td>Either FREERTOS_AF_INET4 or FREERTOS_AF_INET6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IPv4 IP address for the hostname being queried. It will be zero if there is no reply. </dd></dl>

</div>
</div>
<a id="ad25ac051a64099fc2336de41526aee68" name="ad25ac051a64099fc2336de41526aee68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25ac051a64099fc2336de41526aee68">&#9670;&#160;</a></span>prvIncreaseDNS4Index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvIncreaseDNS4Index </td>
          <td>(</td>
          <td class="paramtype">NetworkEndPoint_t *&#160;</td>
          <td class="paramname"><em>pxEndPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the field 'ucDNSIndex', which is an index in the array. </p>
<p>Increment the field 'ucDNSIndex', which is an index in the array of DNS addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEndPoint</td><td>The end-point of which the DNS index should be incremented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e0f0cfa46b54efecf8089cf02c6701" name="a14e0f0cfa46b54efecf8089cf02c6701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e0f0cfa46b54efecf8089cf02c6701">&#9670;&#160;</a></span>prvIncreaseDNS6Index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvIncreaseDNS6Index </td>
          <td>(</td>
          <td class="paramtype">NetworkEndPoint_t *&#160;</td>
          <td class="paramname"><em>pxEndPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the field 'ucDNSIndex', which is an index in the array. </p>
<p>Increment the field 'ucDNSIndex', which is an index in the array of DNS addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEndPoint</td><td>The end-point of which the DNS index should be incremented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71b77cb5028f171304f1535f7406766f" name="a71b77cb5028f171304f1535f7406766f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b77cb5028f171304f1535f7406766f">&#9670;&#160;</a></span>FreeRTOS_gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define <a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a71b77cb5028f171304f1535f7406766f" title="Define FreeRTOS_gethostbyname() as a normal blocking call.">FreeRTOS_gethostbyname()</a> as a normal blocking call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>The hostname whose IP address is being searched for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IP-address of the hostname. </dd></dl>

</div>
</div>
<a id="ad6746bbebd1cca52f8a6d4cafcc5bbcf" name="ad6746bbebd1cca52f8a6d4cafcc5bbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6746bbebd1cca52f8a6d4cafcc5bbcf">&#9670;&#160;</a></span>FreeRTOS_gethostbyname_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_gethostbyname_cancel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvSearchID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the entry defined by the search ID to cancel a DNS request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvSearchID</td><td>The search ID of the callback function associated with the DNS request being cancelled. Note that the value of the pointer matters, not the pointee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03d1e7b3400b84a3babd9a4ccadcff1e" name="a03d1e7b3400b84a3babd9a4ccadcff1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d1e7b3400b84a3babd9a4ccadcff1e">&#9670;&#160;</a></span>FreeRTOS_getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcService</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> freertos_addrinfo *&#160;</td>
          <td class="paramname"><em>pxHints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo **&#160;</td>
          <td class="paramname"><em>ppxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look-up the IP-address of a host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcName</td><td>The name of the node or device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcService</td><td>Ignored for now. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxHints</td><td>If not NULL preferences. Can be used to indicate the preferred type if IP ( v4 or v6 ). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppxResult</td><td>An allocated struct, containing the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero when the operation was successful, otherwise a negative errno value. </dd></dl>

</div>
</div>
<a id="a23c3f105cd946cc194c3f7e340868faf" name="a23c3f105cd946cc194c3f7e340868faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c3f105cd946cc194c3f7e340868faf">&#9670;&#160;</a></span>pxNew_AddrInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo * pxNew_AddrInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function: allocate and initialise a new struct of type freertos_addrinfo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcName</td><td>the name of the host. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFamily</td><td>the type of IP-address: FREERTOS_AF_INET4 or FREERTOS_AF_INET6. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pucAddress</td><td>The IP-address of the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated struct, or NULL in case malloc failed.. </dd></dl>

</div>
</div>
<a id="a87c5f7fe9d7591f3e8054e5d80225995" name="a87c5f7fe9d7591f3e8054e5d80225995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c5f7fe9d7591f3e8054e5d80225995">&#9670;&#160;</a></span>FreeRTOS_freeaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS_freeaddrinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo *&#160;</td>
          <td class="paramname"><em>pxInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a chain of structs of type 'freertos_addrinfo'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxInfo</td><td>The first find result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab23d695ac8334f39dfd49db9268502d2" name="ab23d695ac8334f39dfd49db9268502d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23d695ac8334f39dfd49db9268502d2">&#9670;&#160;</a></span>FreeRTOS_getaddrinfo_a()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_getaddrinfo_a </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcService</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> freertos_addrinfo *&#160;</td>
          <td class="paramname"><em>pxHints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo **&#160;</td>
          <td class="paramname"><em>ppxResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnDNSEvent&#160;</td>
          <td class="paramname"><em>pCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvSearchID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous version of getaddrinfo(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcName</td><td>The name of the node or device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcService</td><td>Ignored for now. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxHints</td><td>If not NULL preferences. Can be used to indicate the preferred type if IP ( v4 or v6 ). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppxResult</td><td>An allocated struct, containing the results. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCallback</td><td>A user-defined function which will be called on completion, either when found or after a time-out. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvSearchID</td><td>A user provided void pointer that will be communicated on completion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxTimeout</td><td>The maximum number of clock ticks that must be waited for a reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero when the operation was successful, otherwise a negative errno value. </dd></dl>

</div>
</div>
<a id="a585a2b637e9683132af556a2b3147ad0" name="a585a2b637e9683132af556a2b3147ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585a2b637e9683132af556a2b3147ad0">&#9670;&#160;</a></span>FreeRTOS_gethostbyname_a()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_gethostbyname_a </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FOnDNSEvent&#160;</td>
          <td class="paramname"><em>pCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvSearchID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the IP-address corresponding to the given hostname. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>The hostname whose IP address is being queried. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCallback</td><td>The callback function which will be called upon DNS response. It will be called with pcHostName, pvSearchID and pxAddressInfo which points to address info. The pxAddressInfo should be freed by the application once the callback has been called by the <a class="el" href="_free_r_t_o_s___d_n_s_8c.html#a87c5f7fe9d7591f3e8054e5d80225995" title="Free a chain of structs of type &#39;freertos_addrinfo&#39;.">FreeRTOS_freeaddrinfo()</a>. In case of timeouts pxAddressInfo can be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvSearchID</td><td>Search ID for the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxTimeout</td><td>Timeout for the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IP-address corresponding to the hostname. 0 is returned in case of failure. </dd></dl>

</div>
</div>
<a id="ab83fd4564829d4495ee1345bb7de6ee7" name="ab83fd4564829d4495ee1345bb7de6ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83fd4564829d4495ee1345bb7de6ee7">&#9670;&#160;</a></span>prvGetPayloadBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t * prvGetPayloadBuffer </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t **&#160;</td>
          <td class="paramname"><em>ppxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxHeaderBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a payload buffer and return it through the parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ppxNetworkBuffer</td><td>network buffer to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>hostname to get its length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxHeaderBytes</td><td>Size of the header (IPv4/IPv6) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer address to the payload buffer </dd></dl>

</div>
</div>
<a id="ac912dabeefa1427f8ea2dae4ac390d9b" name="ac912dabeefa1427f8ea2dae4ac390d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac912dabeefa1427f8ea2dae4ac390d9b">&#9670;&#160;</a></span>prvFillSockAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static NetworkEndPoint_t * prvFillSockAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fill pxAddress from pucUDPPayloadBuffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pxAddress</td><td>ip address and port ... structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>hostname to get its length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end-point that holds the DNS address. </dd></dl>

</div>
</div>
<a id="a61c4c2d5f3778e0994daed50802515eb" name="a61c4c2d5f3778e0994daed50802515eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c4c2d5f3778e0994daed50802515eb">&#9670;&#160;</a></span>prvDNSReply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t prvDNSReply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> xDNSBuffer *&#160;</td>
          <td class="paramname"><em>pxReceiveBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo **&#160;</td>
          <td class="paramname"><em>ppxAddressInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return ip address from the dns reply message </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxReceiveBuffer</td><td>received buffer from the DNS server </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxAddressInfo</td><td>A pointer to a pointer where the find results will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIdentifier</td><td>matches sent and received packets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usPort</td><td>Port from which DNS reply was read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ip address or zero on error </dd></dl>

</div>
</div>
<a id="ab33866cbc083796274436528d88b5e3b" name="ab33866cbc083796274436528d88b5e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33866cbc083796274436528d88b5e3b">&#9670;&#160;</a></span>prvSendBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvSendBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xDNSSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> freertos_sockaddr *&#160;</td>
          <td class="paramname"><em>pxAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prepare the buffer before sending </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>hostname to be looked up </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIdentifier</td><td>matches sent and received packets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDNSSocket</td><td>a valid socket </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFamily</td><td>indicate what type of record is needed: FREERTOS_AF_INET4 or FREERTOS_AF_INET6. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxAddress</td><td>address structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if sending the data was successful, pdFALSE otherwise. </dd></dl>

</div>
</div>
<a id="a47a7649d02e497d1f35519a7ea533ec3" name="a47a7649d02e497d1f35519a7ea533ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a7649d02e497d1f35519a7ea533ec3">&#9670;&#160;</a></span>prvGetHostByNameOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t prvGetHostByNameOp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xDNSSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo **&#160;</td>
          <td class="paramname"><em>ppxAddressInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxReadTimeOut_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>main dns operation description function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>hostname to get its ip address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIdentifier</td><td>Identifier to match sent and received packets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDNSSocket</td><td>socket </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxAddressInfo</td><td>A pointer to a pointer where the find results will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFamily</td><td>Either FREERTOS_AF_INET4 or FREERTOS_AF_INET6. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxReadTimeOut_ticks</td><td>The timeout in ticks for waiting. In case the user has supplied a call-back function, this value should be zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ip address or zero on error </dd></dl>

</div>
</div>
<a id="a44442f1111fa24e375378dceaa91fa22" name="a44442f1111fa24e375378dceaa91fa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44442f1111fa24e375378dceaa91fa22">&#9670;&#160;</a></span>prvGetHostByNameOp_WithRetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t prvGetHostByNameOp_WithRetry </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Socket_t&#160;</td>
          <td class="paramname"><em>xDNSSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> freertos_addrinfo **&#160;</td>
          <td class="paramname"><em>ppxAddressInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TickType_t&#160;</td>
          <td class="paramname"><em>uxReadTimeOut_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function to prvGetHostByNameOP with multiple retries equal to ipconfigDNS_REQUEST_ATTEMPTS </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcHostName</td><td>hostname to get its ip address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxIdentifier</td><td>Identifier to match sent and received packets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDNSSocket</td><td>socket </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppxAddressInfo</td><td>A pointer to a pointer where the find results will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xFamily</td><td>Either FREERTOS_AF_INET4 or FREERTOS_AF_INET6. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxReadTimeOut_ticks</td><td>The timeout in ticks for waiting. In case the user has supplied a call-back function, this value should be zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ip address or zero on error </dd></dl>

</div>
</div>
<a id="ae560e9af4e296059183eb6ddbe9458a1" name="ae560e9af4e296059183eb6ddbe9458a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae560e9af4e296059183eb6ddbe9458a1">&#9670;&#160;</a></span>ulDNSHandlePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ulDNSHandlePacket </td>
          <td>(</td>
          <td class="paramtype">const NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform some preliminary checks and then parse the DNS packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer to be parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always pdFAIL to indicate that the packet was not consumed and must be released by the caller. </dd></dl>

</div>
</div>
<a id="a9da21a35903e781448c9d2bc89075beb" name="a9da21a35903e781448c9d2bc89075beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da21a35903e781448c9d2bc89075beb">&#9670;&#160;</a></span>ulNBNSHandlePacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ulNBNSHandlePacket </td>
          <td>(</td>
          <td class="paramtype">NetworkBufferDescriptor_t *&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle an NBNS packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer holding the NBNS packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL to show that the packet was not consumed. </dd></dl>

</div>
</div>
<a id="aa77247177eee55cde80f32bafe380ae7" name="aa77247177eee55cde80f32bafe380ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77247177eee55cde80f32bafe380ae7">&#9670;&#160;</a></span>FreeRTOS_SetDNSIPPreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS_SetDNSIPPreference </td>
          <td>(</td>
          <td class="paramtype">IPPreference_t&#160;</td>
          <td class="paramname"><em>eIPPreference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the DNS IP preference while doing DNS lookup to indicate the preference for a DNS server: either IPv4 or IPv6. Defaults to xPreferenceIPv4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eIPPreference</td><td>IP preference, can be either xPreferenceIPv4 or xPreferenceIPv6 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS on success and pdFAIL on failure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7fd3cd50dbeb75c98d82d6850019f1cf" name="a7fd3cd50dbeb75c98d82d6850019f1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd3cd50dbeb75c98d82d6850019f1cf">&#9670;&#160;</a></span>ipLLMNR_IP_ADDR_IPv6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IPv6_Address_t ipLLMNR_IP_ADDR_IPv6</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    {</div>
<div class="line">        { </div>
<div class="line">            0xff, 0x02,</div>
<div class="line">            0x00, 0x00,</div>
<div class="line">            0x00, 0x00,</div>
<div class="line">            0x00, 0x00,</div>
<div class="line">            0x00, 0x00,</div>
<div class="line">            0x00, 0x00,</div>
<div class="line">            0x00, 0x01,</div>
<div class="line">            0x00, 0x03,</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>The IPv6 link-scope multicast address. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="_free_r_t_o_s___d_n_s_8c.html">FreeRTOS_DNS.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
